{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TI 2.0 Prim\u00e4rsystem Implementierungsleitfaden","text":"<p>Release Notes: v1.1.0</p> <p>Diese Dokumentation beschreibt den Implementierungsleitfaden f\u00fcr Prim\u00e4rsysteme in der TI 2.0. Sie richtet sich an Entwickler, Integratoren und Administratoren, die TI 2.0 Anwendungen in ihre Systeme integrieren oder verwalten m\u00f6chten.</p>"},{"location":"branch-modell/","title":"Branch Modell","text":"<p>Im ZETA GitHub Repository werden Branches verwendet um den Status der Weiterentwicklung und das Review von \u00c4nderungen abzubilden.</p> <p>Folgende Branches werden verwendet:</p> <ul> <li>main (enth\u00e4lt den letzten freigegebenen Stand der Entwicklung; besteht permanent)</li> <li>develop (enth\u00e4lt den Stand der fertig entwickelten Features und wird zum Review durch Industriepartner und Gesellschafter verwendet; basiert auf main; nach Freigabe erfolgt ein merge in main und ein Release wird erzeugt; besteht permanent)</li> <li>feature/name (in feature branches werden neue Features entwickelt; basiert auf develop; nach Fertigstellung erfolgt ein merge in develop; wird nach dem merge gel\u00f6scht)</li> <li>hotfix/name (in hotfix branches werden Hotfixes entwickelt; basiert auf main; nach Fertigstellung erfolgt ein merge in develop und in main; wird nach dem merge gel\u00f6scht)</li> <li>concept/name (in concept branches werden neue Konzepte entwickelt; basiert auf develop; dient der Abstimmung mit Dritten; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> <li>misc/name (nur f\u00fcr internen Gebrauch der gematik; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> </ul>"},{"location":"license/","title":"License","text":"<p>Copyright (c) 2022 gematik GmbH</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#zeta-api","title":"ZETA API","text":"<p>Die Release Notes bieten einen \u00dcberblick \u00fcber die \u00c4nderungen und Neuerungen in der ZETA API.</p>"},{"location":"release-notes/#v100","title":"v1.0.0","text":""},{"location":"release-notes/#whats-changed","title":"What's Changed","text":"<ul> <li>Feature/qs by @gem-cp in https://github.com/gematik/ZETA/pull/1</li> <li>Develop by @gem-cp in https://github.com/gematik/ZETA/pull/2</li> <li>Develop by @gem-cp in https://github.com/gematik/ZETA/pull/3</li> <li>fix: Update Jekyll configuration for GitHub Pages and comment out unu\u2026 by @gem-cp in https://github.com/gematik/ZETA/pull/4</li> <li>fix: Remove optional logo and favicon configuration from Jekyll config by @gem-cp in https://github.com/gematik/ZETA/pull/5</li> <li>fix: Update README and API documentation structure for clarity and co\u2026 by @gem-cp in https://github.com/gematik/ZETA/pull/6</li> <li>update: remove v2 index page by @gem-cp in https://github.com/gematik/ZETA/pull/7</li> <li>fix: Update ZETA API documentation link to point to the correct index\u2026 by @gem-cp in https://github.com/gematik/ZETA/pull/8</li> <li>fix: Clean up Jekyll configuration by removing commented-out code and\u2026 by @gem-cp in https://github.com/gematik/ZETA/pull/9</li> </ul> <p>Full Changelog</p>"},{"location":"release-notes/#zeta-guard","title":"ZETA Guard","text":"<p>Die Release Notes bieten einen \u00dcberblick \u00fcber die \u00c4nderungen und Neuerungen im ZETA Guard.</p>"},{"location":"release-notes/#v100_1","title":"v1.0.0","text":"<p>Erste Version des ZETA Guards ver\u00f6ffentlicht.</p>"},{"location":"api/zeta-api-versionen/","title":"ZETA API Versionen","text":"<ul> <li>ZETA API v1</li> </ul>"},{"location":"api/v1/","title":"ZETA API v1","text":"<p>Die ZETA API erm\u00f6glicht es ZETA Clients, auf gesch\u00fctzte Ressourcen zuzugreifen und dabei Sicherheits- und Authentifizierungsmechanismen zu nutzen. Der ZETA Client nutzt Endpunkte des ZETA Guard f\u00fcr die Client-Registrierung, Authentifizierung und Autorisierung.</p> <p>Station\u00e4re Clients verwenden bei der Authentifizierung Endpunkte des Konnektors/TI-Gateways und des ZETA Attestation Service.</p> <p>Mobile Clients verwenden Endpunkte der betriebssystem-spezifischen Attestierung. Die Authentifizierung erfolgt mit OpenID Connect (OIDC) und der ZETA Guard API.</p> <p>Die ZETA API ist so konzipiert, dass sie eine sichere und flexible Interaktion zwischen ZETA Clients und gesch\u00fctzten Ressourcen erm\u00f6glicht. ZETA basiert auf den Standards des OAuth 2.0 Frameworks und erweitert es um spezifische Anforderungen der gematik.</p>"},{"location":"api/v1/#voraussetzungen-fur-die-zeta-client-nutzung","title":"Voraussetzungen f\u00fcr die ZETA Client Nutzung","text":"<p>Folgende Voraussetzungen m\u00fcssen f\u00fcr die Nutzung des ZETA Clients erf\u00fcllt sein:</p> <ul> <li>Der FQDN des Resource Servers wird vom ZETA Client ben\u00f6tigt, um die ZETA Guard API zu erreichen.</li> <li>Die roots.json Datei wird vom ZETA Client ben\u00f6tigt, um die Trust Chain zu validieren. Diese Datei muss w\u00f6chentlich aktualisiert werden.</li> </ul> <p>Zus\u00e4tzlich gibt es anwendungsspezifische Voraussetzungen, die f\u00fcr die Nutzung der ZETA Guard API erforderlich sind.</p> <ul> <li>VSDM2: F\u00fcr VSDM2 Requests wird ein PoPP (Proof of Patient Presence) Token ben\u00f6tigt. Das PoPP Token muss im Header PoPP an den ZETA Client \u00fcbergeben werden.</li> </ul>"},{"location":"api/v1/#ablauf","title":"Ablauf","text":"<p>Abh\u00e4ngig vom Zustand des ZETA Clients m\u00fcssen verschiedene Teilabl\u00e4ufe ausgef\u00fchrt werden, oder k\u00f6nnen \u00fcbersprungen werden. Die ZETA API besteht aus mehreren Endpunkten, die verschiedene Funktionen bereitstellen. Diese Endpunkte sind in verschiedene Unter-Abl\u00e4ufe aufgeteilt:</p> <ul> <li>Konfiguration und Discovery: Der ZETA Client muss die Konfiguration des ZETA Guards ermitteln, um die richtigen Endpunkte zu erreichen.</li> <li>Client-Registrierung: Jeder ZETA Client muss sich einmalig beim ZETA Guard registrieren, um eine <code>client_id</code> zu erhalten und seinen \u00f6ffentlichen Schl\u00fcssel zu hinterlegen.</li> <li>Authentifizierung und Autorisierung: Der Client muss sich authentifizieren und die Integrit\u00e4t seiner Plattform nachweisen. Zus\u00e4tzlich muss sich der Nutzer oder beim Prim\u00e4rsystem die Organisation authentifizieren, um ein Access Token f\u00fcr den Zugriff auf gesch\u00fctzte Ressourcen zu erhalten.</li> </ul> <p>Der Gesamtprozess beginnt damit, dass ein Nutzer auf einen Endpunkt eines Resource Servers zugreifen m\u00f6chte. Dieser Zugriff wird \u00fcber das Prim\u00e4rsystem vom ZETA Client im Auftrag des Nutzers ausgef\u00fchrt; siehe folgende Abbildung.</p> <p> Abbildung 1: Ablauf TPM Attestation und Token Exchange \u00dcberblick </p>"},{"location":"api/v1/#konfiguration-und-discovery","title":"Konfiguration und Discovery","text":"<p>In dieser Phase ermittelt der ZETA Client die notwendigen Endpunkte und Konfigurationen von den ZETA Guard Komponenten (PEP http Proxy und PDP Authorization Server). Der Client fragt bekannte Endpunkte (<code>/.well-known/oauth-protected-resource</code> und <code>/.well-known/oauth-authorization-server</code>) ab, um die Konfiguration des Resource Servers und des Authorization Servers zu erhalten. Das folgende Bild zeigt den Ablauf.</p> <p> Abbildung 2: Ablauf Discovery and Configuration </p>"},{"location":"api/v1/#client-registrierung","title":"Client-Registrierung","text":""},{"location":"api/v1/#stationare-clients","title":"Station\u00e4re Clients","text":"<p>Jeder ZETA Client muss sich am ZETA Guard registrieren, \u00fcber den er auf gesch\u00fctzte Ressourcen zugreifen m\u00f6chte. Dieser Prozess findet einmalig pro ZETA Guard-Instanz statt. Der gesamte Prozess ist zweistufig, um die administrative Einrichtung von der technischen Inbetriebnahme zu trennen:</p> <ul> <li>Initiale Registrierung: Der Client erzeugt ein langlebiges kryptographisches Schl\u00fcsselpaar (Client Instance Key), sendet den \u00f6ffentlichen Teil an den Authorization Server und erh\u00e4lt im Gegenzug eine <code>client_id</code>. Der Client ist danach im System bekannt, aber sein Status ist <code>pending_attestation</code>, d.h. er ist noch nicht f\u00fcr den Zugriff auf Ressourcen freigeschaltet.</li> <li>Aktivierung (Erster Token Exchange): Der Client wird aktiviert, indem er zum ersten Mal einen Token Exchange mit einer erfolgreichen Attestierung durchf\u00fchrt. Damit beweist er nicht nur den Besitz des privaten Schl\u00fcssels, sondern (bei der TPM-Attestierung) auch die Integrit\u00e4t der Plattform, auf der er l\u00e4uft. Nach erfolgreicher Pr\u00fcfung wird sein Status im ZETA Guard auf <code>active</code> gesetzt.</li> </ul> <p>Die Client Registrierung ist in der folgenden Abbildung dargestellt.</p> <p> Abbildung 3: Ablauf Client Registrierung </p> <p>F\u00fcr die initiale Registrierung sendet der ZETA Client eine Anfrage an den Dynamic Client Registration (DCR) Endpoint. Diese Anfrage enth\u00e4lt alle notwendigen Metadaten, um den Client f\u00fcr die <code>private_key_jwt</code> Authentifizierungsmethode vorzubereiten:</p> <ul> <li><code>client_name</code>: Ein f\u00fcr Menschen lesbarer Name f\u00fcr den Client.</li> <li><code>token_endpoint_auth_method</code>: Die geplante Authentifizierungsmethode, hier <code>private_key_jwt</code>.</li> <li><code>grant_types</code>: Die erlaubten Grant Types (z.B. <code>urn:ietf:params:oauth:grant-type:token-exchange</code>, <code>refresh_token</code>).</li> <li><code>jwks</code>: Ein JSON Web Key Set, das den \u00f6ffentlichen Client Instance Key enth\u00e4lt. Dieser Schl\u00fcssel wird vom Authorization Server verwendet, um die Signatur der Client Assertions zu \u00fcberpr\u00fcfen.</li> </ul>"},{"location":"api/v1/#mobile-clients","title":"Mobile Clients","text":"<p>Hinweis: Der Prozess f\u00fcr Mobile Clients wird in zuk\u00fcnftigen Versionen der API detaillierter beschrieben, sobald die Entwicklung von ZETA Stufe 2 abgeschlossen ist.</p>"},{"location":"api/v1/#authentifizierung-und-autorisierung","title":"Authentifizierung und Autorisierung","text":"<p>Nach erfolgreicher Registrierung besitzt der ZETA Client eine <code>client_id</code> und ein zugeh\u00f6riges Schl\u00fcsselpaar. Um auf einen Fachdienst zugreifen zu k\u00f6nnen, ben\u00f6tigt der Client ein Access Token vom Authorization Server (AS). Station\u00e4re ZETA Clients verwenden daf\u00fcr den Token Exchange Flow, w\u00e4hrend mobile ZETA Clients den Authorization Code Flow mit OpenID Connect nutzen.</p>"},{"location":"api/v1/#stationare-clients_1","title":"Station\u00e4re Clients","text":"<p>Die Authentifizierung und Autorisierung f\u00fcr station\u00e4re Clients unterscheidet zwei Hauptf\u00e4lle:</p> <ol> <li>Token-Austausch mit Attestierung: Hier wird die Identit\u00e4t der Institution (mittels <code>subject_token</code> von der SM(C)-B) nachgewiesen und die Integrit\u00e4t des Clients durch eine Attestierung \u00fcberpr\u00fcft. Dieser aufw\u00e4ndigere Prozess wird zu Beginn einer neuen Session (oder zur Re-Attestierung) durchgef\u00fchrt, um sicherzustellen, dass der ZETA Client und das Prim\u00e4rsystem vertrauensw\u00fcrdig sind.</li> <li>Token-Erneuerung (Refresh Token): Hier wird ein vorhandenes Refresh Token genutzt, um ein neues Access Token zu erhalten. Dieser Prozess ist performanter und verzichtet auf eine erneute Attestierung.</li> </ol> <p>Diese Trennung schafft eine Balance zwischen h\u00f6chster Sicherheit beim initialen Zugriff und Effizienz bei der Erneuerung bestehender Sitzungen.</p> <p>Die folgende Abbildung zeigt den Ablauf des Token-Austauschs mit Client Assertion JWT Authentifizierung und DPoP.</p> <p> Abbildung 4: Ablauf Authentifizierung und TPM-Attestation </p>"},{"location":"api/v1/#pfad-a-token-austausch-mit-attestierung","title":"Pfad A: Token-Austausch mit Attestierung","text":"<p>Dieser Pfad wird beschritten, wenn der Client keine bestehende Session (d.h. kein g\u00fcltiges Refresh Token) hat.</p> <ol> <li> <p>Vorbereitung:</p> <ul> <li>Der Client fordert eine frische, einmalig g\u00fcltige <code>nonce</code> vom Authorization Server an (<code>GET /nonce</code>).</li> <li>Der Client erzeugt ein tempor\u00e4res, nur f\u00fcr diese Session g\u00fcltiges DPoP-Schl\u00fcsselpaar.</li> </ul> </li> <li> <p>Integrit\u00e4tspr\u00fcfung und kryptografische Bindung:</p> <ul> <li>Um zu beweisen, dass die Attestierung f\u00fcr genau diesen Client und diese Transaktion erstellt wurde, erzeugt der Client eine <code>attestation_challenge</code>. Diese bindet den Zustand des TPMs an den \u00f6ffentlichen Client Instance Key und die <code>nonce</code> des AS: <code>attestation_challenge = HASH( HASH(Client_Instance_Public_Key_JWK) + nonce )</code>.</li> <li>Der Client fordert beim ZETA Attestation Service eine TPM Quote an, die diese <code>attestation_challenge</code> als <code>qualifyingData</code> enth\u00e4lt. Das TPM signiert somit eine Aussage, die mit der Identit\u00e4t des Clients verbunden ist.</li> </ul> </li> <li> <p>Erstellen des Client Statement: Die Attestierungsartefakte (TPM Quote, Event Log, Zertifikatskette) werden in eine <code>client_statement</code>-Struktur gepackt. Im Falle des Fallbacks (Software-Attestierung) enth\u00e4lt diese Struktur andere, softwarebasierte Evidenz.</p> </li> <li> <p>Erstellen der Client Assertion (mit Attestierung): F\u00fcr die Authentifizierung am Token-Endpoint erstellt der Client eine Client Assertion. Dieses JWT, mit dem privaten Client Instance Key signiert, dient als \"Umschlag\":</p> <ul> <li>Es authentifiziert den Client gegen\u00fcber dem AS (<code>iss</code> und <code>sub</code> sind die <code>client_id</code>).</li> <li>Es enth\u00e4lt die <code>client_statement</code>-Struktur als Beweis f\u00fcr die Ger\u00e4teintegrit\u00e4t, verpackt in einem spezifischen Claim (<code>urn:gematik:params:oauth:client-attestation:tpm2</code> oder <code>...:software</code>).</li> </ul> <pre><code>// Client Assertion f\u00fcr initialen Token-Austausch (Beispiel TPM)\n{\n  \"iss\": \"&lt;client_id&gt;\", \"sub\": \"&lt;client_id&gt;\",\n  \"aud\": \"&lt;AS_Token_Endpoint_URL&gt;\",\n  \"exp\": ..., \"jti\": \"...\",\n  // Kapselung des Attestierungsnachweises\n  \"urn:gematik:params:oauth:client-attestation:tpm2\": {\n     \"attestation_data\": \"&lt;Base64(client_statement)&gt;\",\n     \"client_statement_format\": \"client-statement\"\n   }\n}\n</code></pre> </li> <li> <p>Authentisierung der Institution (SM(C)-B Token): Parallel dazu erstellt der Client das <code>subject_token</code>. Dies ist ein vom ZETA Client erzeugtes JWT, dessen Hash vom Konnektor mittels der SM(C)-B signiert wird und die Identit\u00e4t der Institution (z.B. Praxis) belegt. Die Audience (<code>aud</code>) dieses Tokens ist der Ziel-Fachdienst (Resource Server).</p> </li> <li> <p>Token Request: Der Client sendet eine <code>POST</code>-Anfrage an den <code>/token</code>-Endpoint, die alle Teile kombiniert: <code>grant_type=token-exchange</code>, das <code>subject_token</code>, die <code>client_assertion</code> (mit der eingebetteten Attestierung) und den DPoP-Proof.</p> </li> <li> <p>Validierung durch den AS: Der AS f\u00fchrt eine umfassende Pr\u00fcfung durch: Validierung der Client Assertion (Signatur gegen den bei der DCR hinterlegten Public Key), des DPoP-Proofs, des Subject Tokens und insbesondere der eingebetteten Attestierung (Pr\u00fcfung der Quote, der <code>attestation_challenge</code> und der PCR-Werte gegen die Sicherheits-Policy).</p> </li> </ol>"},{"location":"api/v1/#pfad-b-token-erneuerung-via-refresh-token","title":"Pfad B: Token-Erneuerung via Refresh Token","text":"<p>Dieser effiziente Pfad wird genutzt, wenn ein g\u00fcltiges Refresh Token vorhanden ist.</p> <ol> <li> <p>Erstellen der Client Assertion (ohne Attestierung): Der Client erstellt eine einfache <code>client_assertion</code>. Sie beweist durch ihre Signatur mit dem Client Instance Key die Identit\u00e4t des Clients. Diese Assertion enth\u00e4lt keine Attestierungsdaten.</p> <pre><code>// Client Assertion f\u00fcr Refresh-Token-Nutzung\n{\n  \"iss\": \"&lt;client_id&gt;\",\n  \"sub\": \"&lt;client_id&gt;\",\n  \"aud\": \"&lt;AS_Token_Endpoint_URL&gt;\",\n  \"exp\": ..., \"jti\": \"...\"\n}\n</code></pre> </li> <li> <p>Token Request: Der Client sendet eine <code>POST</code>-Anfrage an den <code>/token</code>-Endpoint mit <code>grant_type=refresh_token</code>, dem Refresh Token und der einfachen <code>client_assertion</code>.</p> </li> <li> <p>Validierung durch den AS: Der AS validiert das Refresh Token, die Signatur der Client Assertion und den DPoP-Proof. Die Pr\u00fcfung einer TPM-Attestierung entf\u00e4llt. Bei Erfolg wird das alte Refresh Token invalidiert (Rotation).</p> </li> </ol>"},{"location":"api/v1/#gemeinsame-nachfolgende-schritte","title":"Gemeinsame nachfolgende Schritte","text":"<p>Nach erfolgreicher Validierung in einem der beiden Pfade fragt der AS bei der Policy Engine (PE) an, ob der Zugriff gew\u00e4hrt werden soll. Ist die Entscheidung positiv, stellt der AS ein neues Access Token (gebunden an den DPoP-Schl\u00fcssel) und ein neues Refresh Token aus.</p>"},{"location":"api/v1/#mobile-clients_1","title":"Mobile Clients","text":"<p>Die Authentifizierung f\u00fcr mobile Clients erfolgt mit OpenID Connect und OAuth2 Authorization Code Flow. Die Beschreibung wird erg\u00e4nzt, wenn die Entwicklung von ZETA Stufe 2 abgeschlossen ist.</p>"},{"location":"api/v1/#endpunkte","title":"Endpunkte","text":"<p>Die ZETA API besteht aus mehreren Endpunkten, die verschiedene Funktionen bereitstellen. Diese Endpunkte sind in verschiedene Kategorien unterteilt:</p> <ul> <li>ZETA Guard API Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem ZETA Guard, einschlie\u00dflich der Registrierung von Clients, der Authentifizierung und der Autorisierung.</li> <li>Konnektor/TI-Gateway Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem Konnektor/TI-Gateway, um Karteninformationen zu lesen und Authentifizierungsanfragen zu stellen.</li> <li>ZETA Attestation Service Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem ZETA Attestation Service, um TPM-Attestierungen durchzuf\u00fchren.</li> </ul>"},{"location":"api/v1/#zeta-guard-api-endpunkte","title":"ZETA Guard API Endpunkte","text":"<p>Die ZETA Guard API Endpunkte sind f\u00fcr die Interaktion mit dem ZETA Guard zust\u00e4ndig. Sie erm\u00f6glichen die Registrierung von Clients, die Authentifizierung und Autorisierung sowie den Zugriff auf gesch\u00fctzte Ressourcen. Die ZETA Guard API Endpunkte sind \u00fcber HTTPS erreichbar und erfordern eine g\u00fcltige TLS-Verbindung. Der ZETA Client muss die folgenden Sicherheitsanforderungen erf\u00fcllen:</p> <ul> <li>ZETA Clients m\u00fcssen TLS 1.3 oder h\u00f6her unterst\u00fctzen.</li> <li>Es m\u00fcssen die TLS Anforderungen aus gemSpec_Krypt Kapitel 3.3.2 erf\u00fcllt werden.</li> </ul>"},{"location":"api/v1/#oauth-protected-resource-well-known-endpoint","title":"OAuth Protected Resource Well-Known Endpoint","text":"<p>Dieser Endpunkt bietet eine standardisierte Methode f\u00fcr OAuth Protected Resources (OPR), um ihre F\u00e4higkeiten und Konfigurationsdetails zu ver\u00f6ffentlichen (RFC 9728). Er erm\u00f6glicht es Clients, die notwendigen Informationen \u00fcber die OPR abzurufen, wie z.B. unterst\u00fctzte Schemata, Verifizierungsmethoden, Token-Introspektion-Endpunkte und unterst\u00fctzte Scopes. Der Endpunkt ist unter dem Pfad <code>/.well-known/oauth-protected-resource</code> relativ zur Basis-URL der Protected Resource erreichbar.</p>"},{"location":"api/v1/#anfragen","title":"Anfragen","text":"<p>Der Endpunkt wird \u00fcber eine einfache HTTP GET-Anfrage ohne Body aufgerufen.</p> <pre><code>GET /.well-known/oauth-protected-resource HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"api/v1/#antworten","title":"Antworten","text":"<p>Wie im obigen Abschnitt dargestellt, ist die typische erfolgreiche API-Antwort ein JSON-Objekt, das der im <code>opr-well-known.yaml</code>-Schema definierten Struktur entspricht. Der <code>Content-Type</code>-Header der Antwort ist <code>application/json</code>.</p> <p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und die Konfigurationsdaten der Protected Resource wurden als JSON-Objekt im Antwort-Body zur\u00fcckgegeben.   Eine erfolgreiche Anfrage liefert ein JSON-Objekt, das die Konfiguration der Protected Resource beschreibt. Die genauen Felder h\u00e4ngen von der Implementierung und den unterst\u00fctzten F\u00e4higkeiten der gesch\u00fctzten Resource ab.</li> <li>Beispielantwort:</li> </ul> <p>Content-Type: application/json</p> <pre><code>{\n  \"resource\": \"https://api.example.com\",\n  \"authorization_servers\": [\n    \"https://auth1.example.com\",\n    \"https://auth2.example.com\"\n  ],\n  \"jwks_uri\": \"https://api.example.com/.well-known/jwks.json\",\n  \"scopes_supported\": [\n    \"read\",\n    \"write\",\n    \"delete\"\n  ],\n  \"bearer_methods_supported\": [\n    \"header\",\n    \"body\"\n  ],\n  \"resource_signing_alg_values_supported\": [\n    \"RS256\",\n    \"ES256\"\n  ],\n  \"resource_name\": \"Example Protected API\",\n  \"resource_documentation\": \"https://docs.example.com/api\",\n  \"resource_policy_uri\": \"https://www.example.com/privacy\",\n  \"resource_tos_uri\": \"https://www.example.com/terms\",\n  \"tls_client_certificate_bound_access_tokens\": true,\n  \"authorization_details_types_supported\": [\n    \"payment_initiation\",\n    \"account_access\"\n  ],\n  \"dpop_signing_alg_values_supported\": [\n    \"ES256\",\n    \"RS512\"\n  ],\n  \"dpop_bound_access_tokens_required\": true,\n  \"signed_metadata\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJyZXNvdXJjZSI6Imh0dHBzOi8vYXBpLmV4YW1wbGUuY29tIn0.XYZ123abc456def789\",\n  \"zeta_asl_use\": \"required\",\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ]\n}\n</code></pre> <ul> <li>404 Not Found:</li> <li>Bedeutung: Der angeforderte Well-Known Endpoint konnte auf dem Server nicht gefunden werden. Dies kann daran liegen, dass die Protected Resource diesen Endpunkt nicht hostet oder falsch konfiguriert ist.</li> <li>Beispielantwort:</li> </ul> <p>Content-Type: application/problem+json</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"OAuth Protected Resource Configuration Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested OAuth Protected Resource Well-Known configuration could not be found at this path.\",\n  \"instance\": \"/.well-known/oauth-protected-resource\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server der Protected Resource aufgetreten, der die Verarbeitung der Anfrage verhindert hat.</li> <li>Beispielantwort: Ein leerer Body, ein generischer Content-Type: application/problem+json</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/.well-known/oauth-protected-resource\"\n}\n</code></pre>"},{"location":"api/v1/#authorization-server-well-known-endpoint","title":"Authorization Server Well-Known Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht Clients und anderen Parteien die einfache Entdeckung der Konfigurationsmetadaten eines ZETA Guard OAuth 2.0 Autorisierungsservers (AS) und seiner F\u00e4higkeiten. Er ist gem\u00e4\u00df RFC 8414 definiert und bietet eine standardisierte Methode, um Informationen wie Endpunkt-URIs, unterst\u00fctzte Grant Types und Scopes abzurufen.</p>"},{"location":"api/v1/#anfragen_1","title":"Anfragen","text":"<p>Dieser Endpunkt wird \u00fcber eine HTTP GET-Anfrage ohne Parameter aufgerufen.</p> <p>Methode: <code>GET</code></p> <p>Header: Ein <code>Accept</code>-Header mit <code>application/json</code> wird empfohlen, um die bevorzugte Antwortformat anzugeben.</p> <p>Beispiel Anfrage:</p> <pre><code>GET /.well-known/oauth-authorization-server HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"api/v1/#antworten_1","title":"Antworten","text":"<p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt die Konfigurationsmetadaten des Autorisierungsservers als JSON-Objekt zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"issuer\": \"https://api.example.com\",\n  \"authorization_endpoint\": \"https://api.example.com/auth\",\n  \"token_endpoint\": \"https://api.example.com/token\",\n  \"jwks_uri\": \"https://api.example.com/certs\",\n  \"response_types_supported\": [\n    \"code\",\n    \"token\"\n  ],\n  \"response_modes_supported\": [\n    \"query\",\n    \"fragment\",\n    \"form_post\"\n  ],\n  \"grant_types_supported\": [\n    \"authorization_code\",\n    \"token-exchange\",\n    \"refresh_token\"\n  ],\n  \"token_endpoint_auth_methods_supported\": [\n    \"private_key_jwt\"\n  ],\n  \"token_endpoint_auth_signing_alg_values_supported\": [\n    \"ES256\"\n  ],\n  \"service_documentation\": \"https://api.example.com/docs\",\n  \"code_challenge_methods_supported\": [\n    \"S256\"\n  ],\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ],\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ]\n}\n</code></pre> <p>404 Not Found:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn der Endpunkt unter der angefragten URL nicht gefunden werden kann.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested resource was not found on this server.\",\n  \"instance\": \"/.well-known/oauth-authorization-server\"\n}\n</code></pre> <p>500 Internal Server Error:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn ein unerwarteter Fehler auf dem Server auftritt, der die Anfrage nicht verarbeiten konnte.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/.well-known/oauth-authorization-server\"\n}\n</code></pre>"},{"location":"api/v1/#nonce-endpoint","title":"Nonce Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht Clients das Abrufen eines einmaligen kryptographischen Werts, einer \"Nonce\". Im Kontext der ZETA-Architektur dient diese Nonce prim\u00e4r dazu, eine spezifische TPM-Attestierung an eine aktuelle Transaktion zu binden, um Replay-Angriffe zu verhindern. Sie wird Teil der <code>attestation_challenge</code>, die vom TPM signiert wird.</p> <p>Beim Token Endpunkt wird ebenfalls eine Nonce ben\u00f6tigt, um die Integrit\u00e4t der Transaktion zu gew\u00e4hrleisten. Diese Nonce wird in der Client Assertion verwendet, um Replay-Angriffe zu verhindern und die Bindung zwischen der Client Authentifizierung und der Transaktion sicherzustellen.</p>"},{"location":"api/v1/#anfragen_2","title":"Anfragen","text":"<p>Beispiel Anfrage:</p> <pre><code>GET /nonce HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"api/v1/#antworten_2","title":"Antworten","text":"<p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt die Nonce als JSON-Objekt zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"nonce\": \"s.fRzE3M0J_QxL-x.6gA~x\",\n  \"expires_in\": 30\n}\n</code></pre> <p>Felder der erfolgreichen Antwort:</p> <ul> <li><code>nonce</code> (String): Der generierte, einmalige kryptographische Wert.</li> <li><code>expires_in</code> (Integer): Die G\u00fcltigkeitsdauer der Nonce in Sekunden, ab dem Zeitpunkt der Ausstellung. Nach Ablauf dieser Zeit sollte die Nonce vom Server nicht mehr akzeptiert werden.</li> </ul> <p>404 Not Found:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn der Endpunkt unter der angefragten URL nicht gefunden werden kann.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested resource was not found on this server.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre> <p>429 Too Many Requests:</p> <p>Dieser Fehler tritt auf, wenn der Client die vom Server festgelegten Ratenbegrenzungen \u00fcberschreitet.</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Retry-After: 60</p> <pre><code>{\n  \"type\": \"tag:authorization.example.com,2023:oauth:nonce:rate_limit_exceeded\",\n  \"title\": \"Rate Limit Exceeded\",\n  \"status\": 429,\n  \"detail\": \"You have exceeded the allowed number of nonce requests. Please try again after 60 seconds.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre> <ul> <li><code>Retry-After</code> Header (optional): Gibt an, wie viele Sekunden der Client warten sollte, bevor er eine weitere Anfrage stellt.</li> </ul> <p>500 Internal Server Error:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn ein unerwarteter Fehler auf dem Server auftritt, der die Anfrage nicht verarbeiten konnte.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre>"},{"location":"api/v1/#dynamic-client-registration-endpoint","title":"Dynamic Client Registration Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht die dynamische Registrierung neuer OAuth 2.0 Clients beim Authorization Server gem\u00e4\u00df RFC 7591. Der Prozess dient dazu, eine <code>client_id</code> zu erhalten und den \u00f6ffentlichen Client Instance Key zu registrieren, der f\u00fcr die <code>private_key_jwt</code> Client-Authentifizierung verwendet wird.</p> <p>Die Registrierung selbst erfordert keine Attestierung. Der Client erh\u00e4lt den Status <code>pending_attestation</code> und muss seine Integrit\u00e4t beim ersten Token Exchange beweisen, um aktiviert zu werden. Die Registrierung muss \u00fcber eine TLS-gesch\u00fctzte Verbindung erfolgen.</p> <p>Hinweis: Es fehlen noch die Operationen zur Verwaltung von bestehenden Client Registrierungen (z.B. Aktualisierung, L\u00f6schung). Diese werden in zuk\u00fcnftigen Versionen der API erg\u00e4nzt.</p>"},{"location":"api/v1/#anfragen-fur-stationare-clients","title":"Anfragen f\u00fcr station\u00e4re Clients","text":"<p>Der Client sendet eine <code>POST</code>-Anfrage an den <code>/register</code>-Endpunkt. Der Anfrage-Body ist ein JSON-Objekt, das die Metadaten des zu registrierenden Clients enth\u00e4lt.</p> <p>Beispiel Anfrage:</p> <pre><code>POST /register HTTP/1.1\nHost: api.example.com\nAccept: application/json\nContent-type: application/json\n</code></pre> <pre><code>{\n  \"client_name\": \"Praxis-PC-123\",\n  \"token_endpoint_auth_method\": \"private_key_jwt\",\n  \"grant_types\": [\n    \"urn:ietf:params:oauth:grant-type:token-exchange\",\n    \"refresh_token\"\n  ],\n  \"jwks\": {\n    \"keys\": [\n      {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"...\",\n        \"y\": \"...\",\n        \"use\": \"sig\",\n        \"kid\": \"...\"\n      }\n    ]\n  },\n  \"redirect_uris\": [\n    \"https://client.example.org/cb\"\n  ]\n}\n</code></pre> <p>Erforderliche Parameter im Anfrage-Body:</p> Parameter Typ Beschreibung <code>grant_types</code> <code>array</code> Eine Liste der Grant Types, die der Client verwenden darf. <code>jwks</code> <code>object</code> Das JSON Web Key Set [RFC7517] des Clients, das den \u00f6ffentlichen Client Instance Key enth\u00e4lt. <code>token_endpoint_auth_method</code> <code>string</code> Muss <code>private_key_jwt</code> sein, um die Client-Authentifizierung mittels signierter JWTs zu erzwingen. <code>redirect_uris</code> <code>array</code> Optional f\u00fcr reine Backend-Clients, aber empfohlen. Mindestens eine URI, die f\u00fcr interaktive Flows (z.B. zuk\u00fcnftige mobile Clients) verwendet wird. <code>client_name</code> <code>string</code> Optional. Ein f\u00fcr Menschen lesbarer Name f\u00fcr den Client."},{"location":"api/v1/#antworten_3","title":"Antworten","text":"<p>Der Authorization Server antwortet mit verschiedenen HTTP-Statuscodes und entsprechenden JSON-Objekten, die entweder die erfolgreiche Registrierung oder Fehlermeldungen gem\u00e4\u00df RFC 9457 (\"Problem Details for HTTP APIs\") beschreiben.</p> <p>Statuscodes:</p> <ul> <li>201 Created:</li> <li>Bedeutung: Die Registrierung war erfolgreich. Der Server gibt die <code>client_id</code> und die registrierten Metadaten zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li> <p>Beispiel Antwort:</p> <pre><code>{\n  \"client_id\": \"1234567890abcdef\",\n  \"client_id_issued_at\": 1678886400,\n  \"grant_types\": [\n    \"urn:ietf:params:oauth:grant-type:token-exchange\",\n    \"refresh_token\"\n  ],\n  \"token_endpoint_auth_method\": \"private_key_jwt\",\n  \"client_name\": \"Praxis-PC-123\",\n  \"jwks\": {\n    \"keys\": [\n      {\n        \"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"...\", \"y\": \"...\", \"use\": \"sig\", \"kid\": \"...\"\n      }\n    ]\n  },\n   \"redirect_uris\": [\n    \"https://client.example.org/cb\"\n  ]\n}\n</code></pre> </li> <li> <p>400 Bad Request:</p> </li> <li>Bedeutung: Die Anfrage war fehlerhaft, z.B. fehlende oder ung\u00fcltige Parameter.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/400\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"Invalid request parameters.\",\n  \"instance\": \"/register\"\n}\n</code></pre> <ul> <li>409 Conflict  :</li> <li>Bedeutung: Ein Client mit dem angegebenen <code>Client_Instance_Public_Key</code> existiert bereits.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/409\",\n  \"title\": \"Conflict\",\n  \"status\": 409,\n  \"detail\": \"A client with the provided Client_Instance_Public_Key already exists.\",\n  \"instance\": \"/register\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server aufgetreten, der die Anfrage nicht verarbeiten konnte.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/register\"\n}\n</code></pre>"},{"location":"api/v1/#anfragen-fur-mobile-clients","title":"Anfragen f\u00fcr mobile Clients","text":"<p>Die Registrierung f\u00fcr mobile Clients erfolgt \u00e4hnlich wie bei station\u00e4ren Clients, jedoch mit anderen Anforderungen an die Client-Attestation, die auf den jeweiligen Plattformen basieren. Mobile Clients verwenden eine spezifische Attestierungsmethode, die auf den Betriebssystemen basiert (z.B. Android SafetyNet, iOS DeviceCheck).</p> <p>Die Beschreibung wird in Stufe 2 der ZETA API erg\u00e4nzt.</p>"},{"location":"api/v1/#token-endpoint","title":"Token Endpoint","text":"<p>Der Token Endpoint des Autorisierungsservers (AS) erm\u00f6glicht den Austausch eines Tokens gegen ein vom Authorizationserver ausgestelltes Access Token, gem\u00e4\u00df dem OAuth 2.0 Token Exchange (RFC 8693) oder die Erneuerung von Token (<code>refresh_token</code>). Der Client muss sich mit einer JWT Client Assertion gegen\u00fcber den Authorization Server authentifizieren.</p> <p>Der Endpunkt ist ein POST-Endpunkt, der Formular-kodierte Daten (<code>application/x-www-form-urlencoded</code>) im Body erwartet und JSON-Objekte im Erfolgsfall oder \"Problem Details\" im Fehlerfall zur\u00fcckgibt.</p> <p>Der Endpunkt unterst\u00fctzt verschiedene Grant Types, einschlie\u00dflich <code>authorization_code</code> (ab ZETA Stufe 2), <code>urn:ietf:params:oauth:grant-type:token-exchange</code>, <code>refresh_token</code> und <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p>"},{"location":"api/v1/#anfragen_3","title":"Anfragen","text":"<p>Der Token Endpoint empf\u00e4ngt POST-Anfragen mit dem Content-Type <code>application/x-www-form-urlencoded</code>. Die Anfrage muss die notwendigen Parameter f\u00fcr den Token Exchange Grant Type enthalten, sowie die Client-Authentifizierung mittels JWT Bearer Client Assertion.</p> <p>HTTP Methode: <code>POST</code></p> <p>Pfad: <code>/token</code></p> <p>Content-Type: <code>application/x-www-form-urlencoded</code></p> <p>Anfrageparameter:</p> Parameter Typ Erforderlich Beschreibung <code>grant_type</code> <code>string</code> Ja Der Grant Type. F\u00fcr Token Exchange ist dies immer <code>urn:ietf:params:oauth:grant-type:token-exchange</code>. <code>client_assertion_type</code> <code>string</code> Ja Gibt den Typ der Client Assertion an. F\u00fcr JWT Bearer Client Assertion ist dies immer <code>urn:ietf:params:oauth:client-assertion-type:jwt-bearer</code>. <code>client_assertion</code> <code>string</code> Ja Die JWT, die zur Authentifizierung des Clients dient. Diese JWT muss vom Client signiert sein und folgende Claims enthalten: - <code>iss</code> (Issuer): Die Client ID.- <code>sub</code> (Subject): Die Client ID.- <code>aud</code> (Audience): Die URL des Token Endpoints.- <code>exp</code> (Expiration Time): Die Zeit, nach der die JWT ung\u00fcltig wird.- <code>jti</code> (JWT ID): Ein eindeutiger Bezeichner f\u00fcr diese JWT, um Replay-Angriffe zu verhindern.- <code>iat</code> (Issued At): Zeitpunkt der Ausstellung der JWT. <code>resource</code> <code>string</code> Ja Eine URI, die den Zieldienst oder die Zielressource angibt, f\u00fcr die der Client das angeforderte Sicherheitstoken verwenden m\u00f6chte. Dadurch kann der Autorisierungsserver die f\u00fcr das Ziel geeigneten Richtlinien anwenden, z. B. den Typ und Inhalt des auszugebenden Tokens bestimmen oder festlegen, ob und wie das Token verschl\u00fcsselt werden soll. <code>subject_token_type</code> <code>string</code> Ja Der Typ des Tokens, das ausgetauscht werden soll. Beispiele k\u00f6nnten sein: <code>urn:ietf:params:oauth:token-type:access_token</code>, <code>urn:ietf:params:oauth:token-type:jwt</code> oder andere spezifische URIs. <code>subject_token</code> <code>string</code> Ja Das eigentliche Token, das ausgetauscht werden soll. Dies kann ein JWT, ein Referenz-Token oder ein anderes Format sein, abh\u00e4ngig vom <code>subject_token_type</code>. <code>scope</code> <code>string</code> Optional Eine durch Leerzeichen getrennte Liste von Scopes, f\u00fcr die der Access Token ausgestellt werden soll. Wenn nicht angegeben, werden die mit dem <code>subject_token</code> und/oder Client verbundenen Standard-Scopes verwendet. <p>Beispiel Anfrage:</p> <pre><code>curl -X POST \\\n  https://as.example.com/token \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -H 'DPoP: &lt;signed_dpop_jwt&gt;' \\\n  -d 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange&amp;' \\\n  -d 'client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&amp;' \\\n  -d 'client_assertion=eyJhbGciOiJFUzI1NiIsImtpZCI6InNvbWVfa2V5X2lkIn0.eyJpc3MiOiJjbGllbnRfaWQwMDEiLCJzdWIiOiJjbGllbnRfaWQwMDEiLCJhdWQiOiJodHRwczovL2F1dGhvcml6YXRpb24uc2VydmVyLmRlL3Rva2VuIiwiZXhwIjoxNjk1NTA0NjAwLCJpYXQiOjE2OTU1MDI4MDAsImp0aSI6ImFiYzEyMzQ1NiJ9.SOME_SIGNATURE_PART_ONE.SOME_SIGNATURE_PART_TWO&amp;' \\\n  -d 'resource=https%3A%2F%2Fapi.example.com%2F/resource&amp;' \\\n  -d 'subject_token_type=urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Ajwt&amp;' \\\n  -d 'subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6InNvbWVfc3ViamVjdF9rZXlfaWQifQ.eyJpc3MiOiJzb21lX3N1YmplY3RfYXV0aG9yaXR5Iiwic3ViIjoiMTIzNDU2Nzg5MCIsImF1ZCI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi5zZXJ2ZXIuZGUvdG9rZW4iLCJleHAiOjE2OTU1MDI4NjAsImlhdCI6MTY5NTUwMjgwMH0.SM(C)-B_SIGNATURE&amp;' \\\n  -d 'scope=resource.read%20resource.write'\n</code></pre>"},{"location":"api/v1/#antworten_4","title":"Antworten","text":"<p>Antworten werden als JSON-Objekte mit dem <code>Content-Type: application/json</code> im Erfolgsfall und <code>application/problem+json</code> im Fehlerfall zur\u00fcckgegeben. Fehlerantworten folgen dem \"Problem Details for HTTP APIs\"-Standard (RFC 9457).</p> <p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt das Access Token und andere Metadaten zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"access_token\": \"eyJhbGciOiJFUzI1NiIsImtpZCI6InRva2VuX2tleV9pZCJ9.eyJpc3MiOiJhdXRoLnNlcnZlci5kZSIsImV4cCI6MTY5NTUwMjgwMCwiYXVkIjpbInJlc291cmNlLnNlcnZlci5kZSJdLCJzdWIiOiIxMjM0NTY3ODkwIiwiY2xpZW50X2lkIjoiZXhhbXBsZV9jbGllbnRfaWQiLCJpYXQiOjE2OTU1MDI4MDAsImp0aSI6ImV4YW1wbGVfamRpX3ZhbHVlIiwic2NvcGUiOiJyZXNvdXJjZS5yZWFkIHJlc291cmNlLndyaXRlIiwiY25mIjp7ImprdCI6ImV4YW1wbGVfamt0X2hhc2gifX0.NEW_SIGNATURE_PLACEHOLDER\",\n  \"token_type\": \"DPoP\",\n  \"expires_in\": 3600,\n  \"scope\": \"resource.read resource.write\",\n  \"refresh_token\": \"some_refresh_token_string\",\n  \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\"\n}\n</code></pre> <p>Inhalt des Access Tokens:</p> <pre><code>{\n  \"iss\": \"auth.server.de\",\n  \"exp\": 1695502800,\n  \"aud\": [\"resource.server.de\"],\n  \"sub\": \"1234567890\",\n  \"client_id\": \"my_oauth_client_id\",\n  \"iat\": 1695502800,\n  \"jti\": \"a_unique_jwt_identifier_12345\",\n  \"scope\": \"resource.read resource.write\",\n  \"cnf\": {\n    \"jkt\": \"S7uGv0kQ0g2J_2z8Y_yXm-X_yL0_yXk_Xk_yY1W_Xk\"\n  }\n}\n</code></pre> <ul> <li>400 Bad Request:</li> <li>Bedeutung: Die Anfrage war fehlerhaft, z.B. fehlende oder ung\u00fcltige Parameter.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/400\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"Invalid request parameters.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>401 Unauthorized:</li> <li>Bedeutung: Die Client-Authentifizierung ist fehlgeschlagen, z.B. ung\u00fcltige Client Assertion.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/401\",\n  \"title\": \"Unauthorized\",\n  \"status\": 401,\n  \"detail\": \"Client authentication failed.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>403 Forbidden:</li> <li>Bedeutung: Der Client ist nicht berechtigt, den Token Exchange durchzuf\u00fchren, z.B. wenn der <code>subject_token</code> nicht g\u00fcltig ist oder der Client nicht die erforderlichen Berechtigungen hat.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/403\",\n  \"title\": \"Forbidden\",\n  \"status\": 403,\n  \"detail\": \"The client is not authorized to perform this token exchange.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>429 Too Many Requests:</li> <li>Bedeutung: Der Client hat die Rate-Limits \u00fcberschritten.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/429\",\n  \"title\": \"Too Many Requests\",\n  \"status\": 429,\n  \"detail\": \"Rate limit exceeded. Please try again later.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server aufgetreten, der die Anfrage nicht verarbeiten konnte.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/token\"\n}\n</code></pre>"},{"location":"api/v1/#resource-endpoint","title":"Resource Endpoint","text":"<p>Der Resource Endpoint ist der Endpunkt, der von der gesch\u00fctzten Ressource (Protected Resource) bereitgestellt wird, um auf gesch\u00fctzte Daten zuzugreifen. Er ist durch den ZETA Guard PEP vor unberechtigtem Zugriff gesch\u00fctzt. F\u00fcr den Zugriff auf die gesch\u00fctzte Ressource wird ein g\u00fcltiges Access Token und ein g\u00fcltiges DPoP Proof ben\u00f6tigt. Zus\u00e4tzlich kann eine Anwendung ein g\u00fcltiges PoPP Proof erfordern.</p> <p>Der Resource Endpoint unterst\u00fctzt neben TLS eine zus\u00e4tzliche Verschl\u00fcsselungsschicht ZETA/ASL (ZETA/Additional Security Layer). Im Well-Known JSON Dokument der gesch\u00fctzten Ressource wird angegeben, ob der Endpunkt ZETA/ASL unterst\u00fctzt. Der ZETA/ASL Kanal wird nach dem TLS Verbindungsaufbau aufgebaut und verwendet, um die Kommunikation zwischen Client und Resource Endpoint zu sichern.</p>"},{"location":"api/v1/#anfragen_4","title":"Anfragen","text":"<p>Der ZETA Guard PEP empf\u00e4ngt die Anfragen und pr\u00fcft das Access Token im Authentication Header sowie das DPoP Proof im DPoP Header.</p> <p>HTTP Methode: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>).</p> <p>Pfad: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>/api/resource</code>).</p> <p>Content-Type: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>application/json</code>).</p>"},{"location":"api/v1/#antworten_5","title":"Antworten","text":"<p>Die Antwort des Resource Endpoints h\u00e4ngt von der gesch\u00fctzten Ressource ab und kann verschiedene Statuscodes und Datenformate zur\u00fcckgeben.</p>"},{"location":"api/v1/#konnektorti-gateway-endpunkte","title":"Konnektor/TI-Gateway Endpunkte","text":"<p>Die Endpunkte im Konnektor oder im Highspeed Konnektoren des TI-Gateways werden f\u00fcr die Erstellung von Signaturen mit Der SM(C)-B sowie f\u00fcr die Abfrage des SM(C)-B Zertifikats w\u00e4hrend der Authentifizierung am ZETA Guard verwendet.</p> <p>Hinweis: Perspektivisch ist vorgesehen, dass der Zugriff auf das TI-Gateway \u00fcber den ZETA Guard erfolgt, um die Sicherheit und Integrit\u00e4t der Kommunikation zu gew\u00e4hrleisten. W\u00e4hrend der Authentifizierung wird anstatt der SM(C)-B Identit\u00e4t eine TI-Gateway Identit\u00e4t verwendet.</p>"},{"location":"api/v1/#readcardcertificate","title":"ReadCardCertificate","text":"<p>Die Operation ReadCardCertificate ist in der Konnektor Spezifikation definiert.</p>"},{"location":"api/v1/#externalauthenticate","title":"ExternalAuthenticate","text":"<p>Die Operation ExternalAuthenticate ist in der Konnektor Spezifikation definiert.</p>"},{"location":"api/v1/#zeta-attestation-service-endpunkte","title":"ZETA Attestation Service Endpunkte","text":"<p>Der <code>ZetaAttestationService</code> stellt einen gRPC-Dienst zur Verf\u00fcgung, der es station\u00e4ren Clients (Prim\u00e4rsystem) erm\u00f6glicht, TPM-signierte Attestierungsinformationen f\u00fcr den Client abzurufen. Diese Informationen basieren auf Integrit\u00e4tsmessungen, die in ausgew\u00e4hlten Platform Configuration Registers (PCRs) des Trusted Platform Module (TPM) gespeichert sind. Der ZETA Guard Authorization Server verwendet diese Attestierungsdaten, um die Integrit\u00e4t und Authentizit\u00e4t der Softwareumgebung des Clients zu verifizieren, bevor Zugriff auf gesch\u00fctzte Ressourcen gew\u00e4hrt wird.</p> <p>Der ZETA Attestation Service wird vom Hersteller des station\u00e4ren Clients bereitgestellt und es muss eine Vertrauensbeziehung zwischen station\u00e4ren Client und ZETA Attestation Service bestehen, um zu gew\u00e4hrleisten, dass die Attestation \u00fcber die vorgesehenen Software-Komponenten erfolgt.</p> <p>Hinweis: W\u00e4hrend der Installation oder bei Updates des station\u00e4ren Clients muss auch ein Update des ZETA Attestation Service erfolgen um eine neue Baseline f\u00fcr die Integrit\u00e4t des station\u00e4ren Clients zu setzen. Die Baseline besteht aus einem Hash \u00fcber alle unver\u00e4nderlichen Komponenten des station\u00e4ren Clients, inkl. ZETA Attestation Service.</p> <p>Hinweis: Der ZETA Attestation Service muss bei jedem Start des Clients die Messung \u00fcber die Integrit\u00e4t des Clients durchf\u00fchren und in das PCR schreiben.</p> <p>Hinweis: Der ZETA Attestation Service ist nicht f\u00fcr mobile Clients vorgesehen. Mobile Clients verwenden eine andere Attestierungsmethode, die auf den jeweiligen Plattformen basiert (z.B. Android SafetyNet, iOS DeviceCheck).</p> <p>Hinweis: TODO Umgang mit Messung des Clients weicht von Baseline ab; empfohlenes Verhalten f\u00fcr Client und ZetaAttestationService (z. B. automatisch Support informieren)</p>"},{"location":"api/v1/#dienstdefinition","title":"Dienstdefinition","text":"<ul> <li>Service Name: <code>zeta.attestation.service.v1.ZetaAttestationService</code></li> <li>Proto Buffer Spezifikation: zeta-attestation-service.proto</li> </ul>"},{"location":"api/v1/#rpc-methoden","title":"RPC Methoden","text":""},{"location":"api/v1/#getattestation","title":"GetAttestation","text":"<p>Diese RPC-Methode erm\u00f6glicht es Clients, eine signierte Attestierungs-Quote vom TPM des Systems anzufordern, die spezifische PCR-Werte und eine vom Client bereitgestellte Challenge enth\u00e4lt.</p>"},{"location":"api/v1/#request-nachricht-getattestationrequest","title":"Request-Nachricht: <code>GetAttestationRequest</code>","text":"<p>Die <code>GetAttestationRequest</code>-Nachricht enth\u00e4lt die Parameter, die f\u00fcr die Anforderung einer Attestierung ben\u00f6tigt werden.</p> Feld Typ Erforderlich Beschreibung <code>attestation_challenge</code> <code>bytes</code> Ja Ein SHA-256 Hashwert, berechnet aus der Verkettung des SHA-256 Fingerabdrucks des Public Client Instance Keys und einer Nonce vom ZETA Guard Authorization Server. Dient zur Verhinderung von Replay-Angriffen und zur Korrelation. <code>pcr_indices</code> <code>repeated uint32</code> Ja Eine Liste von TPM PCR-Indizes, deren aktuelle Werte in die Attestierungs-Quote aufgenommen und zur\u00fcckgegeben werden sollen. <p>Berechnung der <code>attestation_challenge</code>: Der Client ist f\u00fcr die korrekte Berechnung dieses Wertes verantwortlich.</p> <pre><code>data_to_hash = sha256_thumbprint_of_public_client_instance_key_bytes || nonce_from_zeta_guard_bytes\nattestation_challenge = SHA-256(data_to_hash)\n</code></pre> <p>Beispiel (Python) f\u00fcr die Berechnung der <code>attestation_challenge</code>:</p> <pre><code>import hashlib\n\n# Beispielwerte\nthumbprint_hex = \"9f3d4f2a6c5e4e21d84c8a713d3c37cfb1a2f3a4b14ad9d8d8d9c0e7c8e7e6f5\" # SHA-256 Fingerabdruck\nnonce_hex = \"a1b2c3d4e5f60718293a4b5c6d7e8f90\"\n\nthumbprint_bytes = bytes.fromhex(thumbprint_hex)\nnonce_bytes = bytes.fromhex(nonce_hex)\n\ndata_to_hash = thumbprint_bytes + nonce_bytes\nattestation_challenge_bytes = hashlib.sha256(data_to_hash).digest() # als Bytes\nattestation_challenge_hex = hashlib.sha256(data_to_hash).hexdigest() # als Hex-String\n\nprint(f\"attestation_challenge (hex): {attestation_challenge_hex}\")\n# In der gRPC Anfrage wird `attestation_challenge_bytes` verwendet.\n</code></pre> <p>Empfohlene PCR-Indizes:</p> <ul> <li>PCR 4: Boot Loader Code, Digest</li> <li>PCR 5: Boot Loader Configuration, Digest</li> <li>PCR 7: Secure Boot State / Policy, Digest</li> <li>PCR 10:OS Kernel / IMA, Digest</li> <li>PCR 11: OS Components / VSM, Digest,</li> <li>PCR 22 or 23 (if available) Client Data</li> </ul>"},{"location":"api/v1/#response-nachricht-getattestationresponse","title":"Response-Nachricht: <code>GetAttestationResponse</code>","text":"<p>Die <code>GetAttestationResponse</code>-Nachricht enth\u00e4lt die vom Dienst generierten Attestierungsdaten.</p> Feld Typ Beschreibung <code>attestation_quote</code> <code>bytes</code> Die rohe, signierte Attestierungs-Quote des TPMs (eine TPM2_ATTEST Struktur). Diese Quote enth\u00e4lt die angefragten PCR-Werte sowie den <code>attestation_challenge</code> Wert. Muss clientseitig geparst werden. <code>current_pcr_values</code> <code>map&lt;uint32, bytes&gt;</code> Eine Abbildung der angefragten PCR-Indizes auf ihre aktuellen, gemessenen Werte. Die L\u00e4nge der <code>bytes</code> h\u00e4ngt vom aktiven Hashing-Algorithmus der jeweiligen PCR-Bank ab (z.B. 20 Bytes f\u00fcr SHA-1, 32 Bytes f\u00fcr SHA-256). <code>status</code> <code>AttestationStatus</code> (enum) Der vom ZETA Attestation Service intern ermittelte Status der Attestierung. Gibt an, ob die Messungen erfolgreich waren und ob sie ggf. einer definierten Baseline entsprechen. <code>status_message</code> <code>string</code> (optional) Eine menschenlesbare Beschreibung des Attestierungsstatus oder zus\u00e4tzliche Informationen, insbesondere im Fehlerfall oder bei einem <code>BASELINE_MISMATCH</code>. <code>timestamp</code> <code>google.protobuf.Timestamp</code> (optional) Der Zeitstempel der Erstellung der Attestierungs-Quote durch den ZETA Attestation Service. Erfordert <code>import \"google/protobuf/timestamp.proto\";</code>. <code>event_log</code> <code>bytes</code> (optional) Das TPM-Event-Log im plattformspezifischen Format (z.B. TCG PC Client Platform Firmware Profile Specification). Dieses Log detailliert die Sequenz der Erweiterungen der PCRs und ist essentiell f\u00fcr eine vollst\u00e4ndige Validierung. <p>AttestationStatus Enum:</p> <p>Definiert die m\u00f6glichen Statuswerte f\u00fcr die Attestierung, die vom ZETA Attestation Service zur\u00fcckgegeben werden.</p> Wert Numerischer Wert Beschreibung <code>ATTESTATION_STATUS_UNSPECIFIED</code> 0 Der Status ist nicht spezifiziert oder konnte nicht ermittelt werden. Dies sollte als Fehler interpretiert werden. <code>ATTESTATION_STATUS_SUCCESS</code> 1 Die Attestierung war erfolgreich, die Quote wurde generiert und (falls eine Baseline-Pr\u00fcfung serverseitig erfolgt) die Messungen entsprechen der Baseline. <code>ATTESTATION_STATUS_BASELINE_MISMATCH</code> 2 Die Attestierung war technisch erfolgreich, aber die aktuellen PCR-Messwerte weichen von der erwarteten Baseline ab. <code>ATTESTATION_STATUS_TPM_ERROR</code> 3 Ein Fehler ist bei der Kommunikation mit dem TPM oder bei einer TPM-Operation aufgetreten (z.B. TPM nicht bereit, PCR nicht lesbar). <code>ATTESTATION_STATUS_INVALID_REQUEST</code> 4 Die Anfrageparameter waren ung\u00fcltig (z.B. <code>attestation_challenge</code> fehlt oder hat falsches Format, ung\u00fcltige oder nicht unterst\u00fctzte <code>pcr_indices</code>). <code>ATTESTATION_STATUS_INTERNAL_ERROR</code> 5 Ein interner, nicht n\u00e4her spezifizierter Fehler ist auf Serverseite aufgetreten."},{"location":"api/v1/#fehlerbehandlung","title":"Fehlerbehandlung","text":"<p>Der <code>ZetaAttestationService</code> verwendet standardm\u00e4\u00dfige gRPC-Statuscodes, um das Ergebnis der Operation auf Transportebene zu kommunizieren. Diese werden erg\u00e4nzt durch den <code>status</code>-Feld in der <code>GetAttestationResponse</code> f\u00fcr anwendungsspezifische Logik. Die <code>google.rpc.Status</code> kann f\u00fcr detailliertere Fehlerinformationen verwendet werden (siehe <code>import \"google/rpc/status.proto\";</code>).</p> <p>H\u00e4ufige gRPC-Statuscodes:</p> <ul> <li><code>OK</code> (0): Die Anfrage war erfolgreich und die <code>GetAttestationResponse</code> enth\u00e4lt die Ergebnisse. Der <code>status</code>-Feld in der Response gibt den anwendungsspezifischen Erfolg oder Misserfolg an.</li> <li><code>INVALID_ARGUMENT</code> (3):</li> <li>Einer oder mehrere Parameter der Anfrage waren ung\u00fcltig.</li> <li>Beispiele: <code>attestation_challenge</code> fehlt, hat eine falsche L\u00e4nge oder ein ung\u00fcltiges Format; <code>pcr_indices</code> ist leer, enth\u00e4lt ung\u00fcltige oder nicht unterst\u00fctzte Indizes.</li> <li>Der <code>status</code> in der Response k\u00f6nnte <code>ATTESTATION_STATUS_INVALID_REQUEST</code> sein.</li> <li><code>UNAUTHENTICATED</code> (16) / <code>PERMISSION_DENIED</code> (7):</li> <li>Der anfragende Client ist nicht authentifiziert oder nicht   autorisiert, diese Anfrage zu stellen.</li> <li>Relevant, wenn Mechanismen wie mTLS oder Token-basierte   Authentifizierung verwendet werden.</li> <li><code>UNAVAILABLE</code> (14):</li> <li>Der ZETA Attestation Service kann die Attestierung derzeit nicht   durchf\u00fchren.</li> <li>Beispiele: TPM ist nicht erreichbar oder nicht funktionsf\u00e4hig;   eine erforderliche Baseline-Konfiguration ist nicht vorhanden.</li> <li>Der <code>status</code> in der Response k\u00f6nnte   <code>ATTESTATION_STATUS_TPM_ERROR</code> oder   <code>ATTESTATION_STATUS_INTERNAL_ERROR</code> sein.</li> <li><code>INTERNAL</code> (13):</li> <li>Ein unerwarteter serverseitiger Fehler ist aufgetreten, der   nicht spezifischer kategorisiert werden kann.</li> <li>Der <code>status</code> in der Response ist typischerweise   <code>ATTESTATION_STATUS_INTERNAL_ERROR</code>.</li> </ul>"},{"location":"api/v1/#sicherheitsaspekte","title":"Sicherheitsaspekte","text":"<ul> <li>Transport-Sicherheit: Es wird dringend empfohlen, die Kommunikation zwischen Client und <code>ZetaAttestationService</code> mittels TLS, vorzugsweise mTLS (mutual TLS), abzusichern, um Authentizit\u00e4t, Integrit\u00e4t und Vertraulichkeit der \u00fcbertragenen Daten zu gew\u00e4hrleisten. Hinweis: Es wird empfohlen, dass der Installer des Clients und des ZetaAttestationService die Schl\u00fcssel f\u00fcr die mTLS Verbindung erzeugt und sicher speichert.</li> <li>Challenge-Response: Die <code>attestation_challenge</code> ist ein kritischer Bestandteil zur Verhinderung von Replay-Angriffen. Die <code>nonce</code> muss f\u00fcr jede Attestierungsanfrage eindeutig sein und sicher vom ZETA Guard Authorization Server generiert und an den Client \u00fcbermittelt werden.</li> <li>Event Log Validierung: Die alleinige \u00dcberpr\u00fcfung der PCR-Werte ist oft nicht ausreichend. Eine gr\u00fcndliche Validierung der Attestierung erfordert das Parsen und \u00dcberpr\u00fcfen des <code>event_log</code>, um die Kausalkette der Messungen nachzuvollziehen. Dies erfolgt im ZETA Guard Authorization Server.</li> </ul>"},{"location":"api/v1/#verwaltung-von-schlusseln-und-session-daten-im-zeta-client","title":"Verwaltung von Schl\u00fcsseln und Session-Daten im ZETA Client","text":""},{"location":"api/v1/#einleitung","title":"Einleitung","text":"<p>Ein ZETA Client muss verschiedene kryptografische Schl\u00fcssel und Session-Informationen verwalten, um mit einer oder mehreren ZETA Guard Instanzen sicher und persistent kommunizieren zu k\u00f6nnen. Die Speicherung und Verwaltung dieser Daten ist kritisch f\u00fcr die Sicherheit und Funktionalit\u00e4t des Clients.</p> <p>Es wird zwischen zwei Arten von Daten unterschieden:</p> <ol> <li>Globale Daten: Diese sind \u00fcbergreifend f\u00fcr die Client-Instanz und unabh\u00e4ngig von einer spezifischen ZETA Guard Instanz.</li> <li>Pro-ZETA-Guard-Instanz Daten: Diese Daten sind spezifisch f\u00fcr die Session mit einer einzelnen ZETA Guard Instanz.</li> </ol>"},{"location":"api/v1/#globale-daten-client-ubergreifend","title":"Globale Daten (Client-\u00fcbergreifend)","text":"<p>Diese Daten definieren die langlebige Identit\u00e4t der Client-Anwendung selbst. Sie m\u00fcssen persistent \u00fcber alle Sessions und Neustarts der Anwendung hinweg gespeichert werden.</p> <ul> <li><code>Client Instance Key</code> (Asymmetrisches Schl\u00fcsselpaar)</li> <li>Beschreibung: Dies ist das Hauptschl\u00fcsselpaar des Clients. Der private Schl\u00fcssel wird zur Signierung der Client-Registrierung bei neuen ZETA Guard Instanzen und zur Client Assertion Authentifizierung verwendet. Der \u00f6ffentliche Schl\u00fcssel dient als eindeutiger, kryptografischer Identifikator des Clients.</li> <li>Speicheranforderung: Dieses Schl\u00fcsselpaar muss einmalig bei der ersten Initialisierung des Clients generiert und anschlie\u00dfend sicher und persistent gespeichert werden. Ein Verlust des privaten Schl\u00fcssels bedeutet, dass der Client seine Identit\u00e4t verliert und sich bei allen bereits bekannten ZETA Guard Instanzen neu registrieren muss.</li> <li>Sicherheit: Der private Schl\u00fcssel ist das wertvollste Geheimnis des Clients und darf niemals im Klartext gespeichert werden. Siehe Kapitel 1.6.4 Sicherheitsempfehlungen f\u00fcr die Schl\u00fcsselspeicherung.</li> </ul>"},{"location":"api/v1/#daten-pro-zeta-guard-instanz","title":"Daten pro ZETA Guard Instanz","text":"<p>F\u00fcr jede ZETA Guard Instanz, mit der der Client eine Verbindung aufbaut, m\u00fcssen die folgenden Daten separat und zugeordnet zur jeweiligen ZETA Guard-Instanz (z.B. \u00fcber deren Basis-URL) gespeichert werden.</p> <ul> <li><code>DPoP Key</code> (Asymmetrisches Schl\u00fcsselpaar)</li> <li>Beschreibung: F\u00fcr jede aktive Session mit einer ZETA Guard Instanz wird ein eigenes, kurzlebiges Schl\u00fcsselpaar generiert. Der private Schl\u00fcssel wird verwendet, um einzelne API-Anfragen an den Guard zu signieren (<code>DPoP</code>).</li> <li>Speicheranforderung: Dieses Schl\u00fcsselpaar ist nur f\u00fcr die Dauer einer Session g\u00fcltig. Es sollte sicher gespeichert, aber nach Beendigung der Session (z.B. durch Logout oder Token-Ablauf ohne Refresh-M\u00f6glichkeit) verworfen werden.</li> <li> <p>Sicherheit: Auch dieser private Schl\u00fcssel muss f\u00fcr seine Lebensdauer sicher aufbewahrt werden.</p> </li> <li> <p><code>Access Token</code></p> </li> <li>Beschreibung: Das vom Authorization Server des ZETA Guards ausgestellte OAuth 2.0 Access Token. Es wird im <code>Authorization</code>-Header bei jeder authentifizierten API-Anfrage mitgesendet.</li> <li> <p>Speicheranforderung: Dieses Token ist kurzlebig und muss nach Ablauf erneuert werden. Es kann im Arbeitsspeicher gehalten oder persistent gespeichert werden, um nach einem Neustart der Anwendung die Session wiederaufnehmen zu k\u00f6nnen. Es besteht ein Diebstahlschutz durch die Bindung an den DPoP Schl\u00fcssel.</p> </li> <li> <p><code>Refresh Token</code></p> </li> <li>Beschreibung: Das vom Authorization Server des ZETA Guards ausgestellte OAuth 2.0 Refresh Token. Dieses Token kann verwendet werden, um ein neues Access Token zu erhalten, ohne dass der Benutzer sich erneut authentifizieren muss.</li> <li> <p>Speicheranforderung: Das Refresh Token ist langlebiger als das Access Token und stellt einen sensiblen Berechtigungsnachweis dar. Es sollte persistent und sicher gespeichert werden. Es besteht ein Diebstahlschutz durch die Bindung an den DPoP Schl\u00fcssel.</p> </li> <li> <p><code>Client ID</code></p> </li> <li>Beschreibung: Die eindeutige ID, die der ZETA Guard dem ZETA Client w\u00e4hrend des Registrierungsprozesses zugewiesen hat. Sie wird f\u00fcr die Token-Anforderung ben\u00f6tigt.</li> <li> <p>Speicheranforderung: Muss persistent gespeichert werden, solange die Registrierung beim ZETA Guard g\u00fcltig sein soll.</p> </li> <li> <p>Discovery-Dokument Daten (Well-Known)</p> </li> <li>Beschreibung: Die Endpunkt-URLs und Konfigurationsdaten aus den Discovery-Dokumenten des ZETA Guards.</li> <li>Speicheranforderung: Es wird dringend empfohlen, diese Daten zu cachen, um wiederholte Discovery-Anfragen zu vermeiden. Der Cache sollte eine angemessene Lebensdauer haben (z.B. 24 Stunden), um auf Konfigurations\u00e4nderungen am Guard reagieren zu k\u00f6nnen.</li> </ul>"},{"location":"api/v1/#konzeptionelles-speicherlayout","title":"Konzeptionelles Speicherlayout","text":"<p>Ein ZETA Client k\u00f6nnte die Daten konzeptionell wie folgt strukturieren:</p> <pre><code>{\n  \"client_instance_private_key\": \"gesch\u00fctzter_speicher_ref\",\n  \"guard_sessions\": {\n    \"https://guard1.example.com\": {\n      \"client_id\": \"client-id-beim-zeta-guard-1\",\n      \"session_private_key\": \"gesch\u00fctzter_speicher_ref\",\n      \"access_token\": \"ey...\",\n      \"refresh_token\": \"def...\",\n      \"discovery_cache\": {\n        \"expires_at\": \"2024-12-01T10:00:00Z\",\n        \"data\": {\n          \"token_endpoint\": \"...\",\n          \"jwks_uri\": \"...\"\n        }\n      }\n    },\n    \"https://guard2.another-provider.de\": {\n      \"client_id\": \"client-id-beim-zeta-guard-2\",\n      \"session_private_key\": \"...\",\n      \"access_token\": \"...\",\n      \"refresh_token\": null,\n      \"discovery_cache\": { ... }\n    }\n  }\n}\n</code></pre>"},{"location":"api/v1/#sicherheitsempfehlungen-fur-die-schlusselspeicherung","title":"Sicherheitsempfehlungen f\u00fcr die Schl\u00fcsselspeicherung","text":"<p>Private Schl\u00fcssel (<code>Client Instance Key</code>, <code>DPoP Key</code>) sind hochsensible Daten. Ihre Kompromittierung erm\u00f6glicht es einem Angreifer, die Identit\u00e4t des Clients zu missbrauchen. Sie m\u00fcssen daher mit den sichersten, vom jeweiligen Betriebssystem bereitgestellten Mitteln gesch\u00fctzt werden.</p> <p>Grundprinzip: Speichern Sie private Schl\u00fcssel niemals unverschl\u00fcsselt im Dateisystem oder in einer Klartext-Konfigurationsdatei.</p> <p>Nutzen Sie stattdessen plattformspezifische, sichere Speicherorte (sog. \"Keystores\" oder \"Secret Vaults\"), die die Schl\u00fcssel an das Benutzerkonto oder die Maschinenidentit\u00e4t binden.</p> <ul> <li>Microsoft Windows:</li> <li>Empfehlung: Verwenden Sie die Data Protection API (DPAPI), die \u00fcber die Funktionen <code>CryptProtectData</code> und <code>CryptUnprotectData</code> zug\u00e4nglich ist.</li> <li> <p>Funktionsweise: DPAPI verschl\u00fcsselt Daten mithilfe eines Schl\u00fcssels, der aus den Anmeldeinformationen des Benutzers abgeleitet wird. Die Daten k\u00f6nnen somit nur von demselben Benutzer auf demselben Computer wieder entschl\u00fcsselt werden. Dies ist ideal f\u00fcr Desktop-Anwendungen. F\u00fcr Dienste, die unter einem Systemkonto laufen, kann der Schutz an die Maschinenidentit\u00e4t gebunden werden.</p> </li> <li> <p>Apple macOS:</p> </li> <li>Empfehlung: Nutzen Sie den macOS Keychain (Schl\u00fcsselbund).</li> <li> <p>Funktionsweise: Der Schl\u00fcsselbund ist ein zentraler, verschl\u00fcsselter Speicher f\u00fcr Passw\u00f6rter, Zertifikate und Schl\u00fcssel. Der Zugriff wird vom Betriebssystem streng kontrolliert und erfordert in der Regel die Zustimmung des Benutzers. Verwenden Sie die <code>Security</code> Framework-APIs, um Schl\u00fcssel sicher zu speichern und abzurufen.</p> </li> <li> <p>Linux:</p> </li> <li>Empfehlung (Desktop-Umgebungen): Verwenden Sie den Secret Service DBus API, der von Diensten wie dem GNOME Keyring oder KWallet implementiert wird. Dies ist der Freedesktop.org-Standard und die bevorzugte Methode f\u00fcr Desktop-Anwendungen.</li> <li>Empfehlung (Server/Headless-Umgebungen):         1. Dateibasierte Verschl\u00fcsselung: Speichern Sie den Schl\u00fcssel in einer Datei, die mit einem Master-Passwort verschl\u00fcsselt ist (das z.B. beim Start der Anwendung abgefragt wird).         2. Strikte Dateiberechtigungen: Als absolutes Minimum muss die Schl\u00fcsseldatei durch strikte Dateisystemberechtigungen gesch\u00fctzt werden. Der private Schl\u00fcssel sollte nur f\u00fcr den Benutzer lesbar sein, unter dem die Anwendung l\u00e4uft.             <pre><code># Setzt die Berechtigung, sodass nur der Eigent\u00fcmer lesen und schreiben darf\nchmod 600 /pfad/zum/privaten_schluessel.key\n</code></pre>         Diese Methode bietet jedoch keinen Schutz, wenn ein Angreifer Lesezugriff auf das Dateisystem als der betreffende Benutzer erlangt. Sie sollte m\u00f6glichst mit zus\u00e4tzlicher Verschl\u00fcsselung kombiniert werden.</li> </ul> <p>Cross-Plattform-Bibliotheken: F\u00fcr in h\u00f6heren Programmiersprachen (z.B. Python, Go, Rust, C#) entwickelte Clients existieren oft Bibliotheken, die die plattformspezifischen Speicher abstrahieren und eine einheitliche API f\u00fcr den Zugriff auf den Windows DPAPI, den macOS Keychain und den Secret Service unter Linux bieten. Die Verwendung solcher Bibliotheken wird empfohlen.</p>"},{"location":"api/v1/#versionierung","title":"Versionierung","text":"<p>Um eine stabile und vorhersagbare Entwicklungsumgebung f\u00fcr Client-Anwendungen zu gew\u00e4hrleisten, folgt die ZETA API strikt den Prinzipien von Semantic Versioning 2.0.0 (SemVer). Jede \u00c4nderung an der API wird klassifiziert, um die Auswirkungen auf bestehende Clients transparent zu machen.</p>"},{"location":"api/v1/#versionierungsschema-majorminorpatch","title":"Versionierungsschema: MAJOR.MINOR.PATCH","text":"<p>Jede ZETA Guard Instanz deklariert ihre API-Version im Format <code>MAJOR.MINOR.PATCH</code> (z.B. <code>1.2.3</code>). Die Bedeutung der einzelnen Komponenten ist wie folgt definiert:</p> <ul> <li>MAJOR-Version (z.B. <code>1</code>.2.3): Wird erh\u00f6ht, wenn r\u00fcckw\u00e4rtsinkompatible (\"breaking\") \u00c4nderungen an der API vorgenommen werden. Dies erfordert eine Anpassung aufseiten des Clients, um weiterhin korrekt zu funktionieren.</li> <li> <p>Beispiele: Entfernen eines Endpunkts, Umbenennung eines JSON-Feldes, \u00c4nderung eines Felddatentyps, Hinzuf\u00fcgen eines verpflichtenden Request-Parameters.</p> </li> <li> <p>MINOR-Version (z.B. 1.<code>2</code>.3): Wird erh\u00f6ht, wenn neue Funktionalit\u00e4t in einer r\u00fcckw\u00e4rtskompatiblen Weise hinzugef\u00fcgt wird. Bestehende Clients d\u00fcrfen durch diese \u00c4nderungen nicht beeintr\u00e4chtigt werden.</p> </li> <li> <p>Beispiele: Hinzuf\u00fcgen eines neuen API-Endpunkts, Hinzuf\u00fcgen eines neuen, optionalen Feldes in einer JSON-Antwort, Hinzuf\u00fcgen eines neuen, optionalen Request-Parameters.</p> </li> <li> <p>PATCH-Version (z.B. 1.2.<code>3</code>): Wird erh\u00f6ht, wenn r\u00fcckw\u00e4rtskompatible Fehlerbehebungen (\"bug fixes\") vorgenommen werden, die das Verhalten der API korrigieren, aber keine neue Funktionalit\u00e4t einf\u00fchren.</p> </li> <li>Beispiele: Korrektur einer fehlerhaften Validierungslogik, Behebung eines internen Fehlers, der zu einem <code>500 Internal Server Error</code> f\u00fchrte.</li> </ul> <p>Zus\u00e4tzlich k\u00f6nnen Prerelease-Tags verwendet werden (z.B. <code>2.0.0-beta.1</code>), um instabile Vorabversionen zu kennzeichnen.</p>"},{"location":"api/v1/#implementierung-der-versionierung","title":"Implementierung der Versionierung","text":"<p>Die Versionierung wird durch eine Kombination aus URL-Pfad, HTTP-Headern und dem Discovery-Dokument umgesetzt.</p>"},{"location":"api/v1/#1-url-pfad-fur-die-major-version","title":"1. URL-Pfad f\u00fcr die MAJOR-Version","text":"<p>R\u00fcckw\u00e4rtsinkompatible \u00c4nderungen sind am einschneidendsten. Daher wird die MAJOR-Version direkt und explizit im URL-Pfad der API gef\u00fchrt.</p> <ul> <li>Schema: <code>https://&lt;guard-base-url&gt;/zeta/v{major-version}/&lt;endpoint&gt;</code></li> <li>Beispiel f\u00fcr Version <code>1.4.2</code>: <code>POST https://guard.example.com/zeta/v1/token</code></li> <li>Beispiel f\u00fcr Version <code>2.0.0</code>: <code>POST https://guard.example.com/zeta/v2/token</code></li> </ul>"},{"location":"api/v1/#2-discovery-dokument-als-source-of-truth","title":"2. Discovery-Dokument als \"Source of Truth\"","text":"<p>Die Discovery-Dokumente (<code>/.well-known/oauth-protected-resource</code> und <code>/.well-known/oauth-authorization-server</code>) sind die zentrale Anlaufstelle f\u00fcr einen Client, um die exakten, vom ZETA Guard unterst\u00fctzten Versionen zu ermitteln.</p> <ul> <li><code>api_versions_supported</code>: Dieses JSON-Objekt listet alle vom ZETA Guard angebotenen MAJOR-Versionen mit ihrer jeweiligen vollen SemVer-Version auf.</li> </ul> <pre><code>// Beispiel-Ausschnitt aus /.well-known/...\n{\n  \"issuer\": \"https://zeta-guard.example.com\",\n  // ... andere Endpunkte\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\", // Die volle, stabile SemVer-Version f\u00fcr v1\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://gematik.github.io/ZETA/v1/\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\", // Eine instabile Vorabversion f\u00fcr v2\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://gematik.github.io/ZETA/v2/\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/v1/#3-http-header-zur-laufzeit-identifikation","title":"3. HTTP-Header zur Laufzeit-Identifikation","text":"<p>Jede Antwort des ZETA Guards enth\u00e4lt einen <code>ZETA-API-Version</code>-Header, der die exakte SemVer-Version der ausf\u00fchrenden Instanz angibt. Dies ist besonders f\u00fcr Debugging und Logging wertvoll.</p> <ul> <li>Beispiel-Response-Header: <code>HTTP/1.1 200 OK</code> <code>Content-Type: application/json</code> <code>ZETA-API-Version: 1.4.2</code></li> </ul>"},{"location":"api/v1/#client-verhalten-und-kompatibilitatsregeln","title":"Client-Verhalten und Kompatibilit\u00e4tsregeln","text":"<p>Um die Stabilit\u00e4t zu gew\u00e4hrleisten, m\u00fcssen Clients die folgenden Regeln befolgen:</p> <ol> <li> <p>Toleranz gegen\u00fcber MINOR- und PATCH-Versionen: Ein Client, der f\u00fcr eine bestimmte API-Version entwickelt wurde (z.B. <code>1.2.0</code>), muss nahtlos mit jeder neueren, r\u00fcckw\u00e4rtskompatiblen Version derselben MAJOR-Version (z.B. <code>1.3.0</code> oder <code>1.2.1</code>) funktionieren. Dies bedeutet konkret:</p> <ul> <li>Unbekannte Felder ignorieren: Der Client-Parser muss unbekannte Felder in JSON-Antworten ignorieren und darf keinen Fehler ausl\u00f6sen.</li> <li>Reihenfolgeunabh\u00e4ngigkeit: Der Client darf sich nicht auf die Reihenfolge von Feldern in JSON-Objekten verlassen.</li> </ul> </li> <li> <p>Explizite Wahl der MAJOR-Version: Der Client w\u00e4hlt die MAJOR-Version aktiv \u00fcber den verwendeten URL-Pfad (z.B. <code>/v1/</code>). Ein Wechsel zu einer neuen MAJOR-Version (z.B. auf <code>/v2/</code>) ist eine bewusste Entwicklungsentscheidung und erfordert eine Code-Anpassung.</p> </li> </ol>"},{"location":"api/v1/#deprecation-policy-auerbetriebnahme","title":"Deprecation Policy (Au\u00dferbetriebnahme)","text":"<p>Wenn eine neue MAJOR-Version (z.B. <code>v2</code>) den Status <code>stable</code> erreicht, wird die vorherige MAJOR-Version (<code>v1</code>) als <code>deprecated</code> (veraltet) markiert.</p> <ol> <li>Ank\u00fcndigungsphase: Die veraltete Version wird im Discovery-Dokument als <code>deprecated</code> gekennzeichnet. Anfragen an diese Version k\u00f6nnen einen <code>Warning</code>-HTTP-Header zur\u00fcckgeben, der auf die bevorstehende Abschaltung hinweist.</li> <li>Migrationszeitraum: Es wird einen klar kommunizierten Zeitraum geben, in dem beide MAJOR-Versionen parallel betrieben werden, um Clients eine reibungslose Migration zu erm\u00f6glichen. Zus\u00e4tzlich wird \u00fcberwacht, welche ZETA Client-Versionen aktiv sind, um die Migration zu unterst\u00fctzen.</li> <li>Abschaltung: Nach Ablauf des Migrationszeitraums und wenn die \u00dcberwachung der ZETA Clients ergeben hat, dass keine veralteten Clients mehr aktiv genutzt werden, wird die veraltete Version abgeschaltet. Anfragen an die Endpunkte dieser Version f\u00fchren dann zu einem <code>HTTP 410 Gone</code>-Fehler.</li> </ol>"},{"location":"api/v1/#performance-und-lastannahmen","title":"Performance- und Lastannahmen","text":"<p>Informationen zu den erwarteten Leistungs- und Lastannahmen f\u00fcr die ZETA API werden nachgereicht.</p> <ul> <li>SM(C)-B Signaturerstellung</li> <li>TPM Attestation</li> <li>ZETA Guard Clientregistrierung</li> <li>ZETA Guard Authentifizierung</li> <li>ZETA Guard Refresh Token Exchange</li> <li>ZETA Guard PEP</li> </ul>"},{"location":"api/v1/#rate-limits-und-einschrankungen","title":"Rate Limits und Einschr\u00e4nkungen","text":"<p>Der OAuth Protected Resource Well-Known Endpoint ist so konfiguriert, dass er eine Rate-Limiting-Strategie implementiert. Der ZETA Client muss die Rate Limits beachten, um eine \u00dcberlastung des Endpunkts zu vermeiden. Die genauen Limits k\u00f6nnen je nach Implementierung variieren, aber typischerweise gelten folgende Richtlinien:</p> <ul> <li>X-RateLimit-Limit</li> <li>X-RateLimit-Remaining</li> <li>X-RateLimit-Reset</li> </ul> <p>oder:</p> <ul> <li>RateLimit-Policy</li> <li>RateLimit</li> </ul> <p>Beispiele: Draft RFC f\u00fcr Rate Limits</p>"},{"location":"api/v1/#support-und-kontaktinformationen","title":"Support und Kontaktinformationen","text":"<p>Hilfe: Informationen dar\u00fcber, wo und wie Benutzer Unterst\u00fctzung erhalten k\u00f6nnen (z.B. Forum, E-Mail-Support). Fehlerberichterstattung: Wie k\u00f6nnen Nutzer Bugs melden oder Feature-Anfragen stellen?</p>"},{"location":"zeta-guard/v1/","title":"ZETA Guard v1","text":"<p>ZETA Guard ist die zentrale Komponente von ZETA, die als Policy Enforcement Point (PEP) und Policy Decision Point (PDP) fungiert. ZETA Guard ist verantwortlich f\u00fcr die Durchsetzung von Sicherheitsrichtlinien und die Entscheidung \u00fcber Zugriffsanfragen auf gesch\u00fctzte Resource Server. ZETA Guard bietet eine RESTful API, die es ZETA Clients erm\u00f6glicht, sich zu registrieren, zu authentifizieren und Autorisierungsanfragen zu stellen. Die API ist so gestaltet, dass sie eine einfache Integration in bestehende Systeme erm\u00f6glicht und gleichzeitig die Sicherheitsanforderungen des Zero Trust Modells erf\u00fcllt.</p>"},{"location":"spec-vsdm2/","title":"Index","text":""},{"location":"spec-vsdm2/#spezifikation-vsdm-20-fhir-profile-und-api","title":"Spezifikation VSDM 2.0 FHIR-Profile und API","text":""},{"location":"spec-vsdm2/#disclaimer","title":"Disclaimer","text":"<p>Dieses Dokument beschreibt die f\u00fcr die Implementierung des Versicherungsstammdatenmanagements (VSDM) 2.0 erforderlichen Vorgaben. Weitere Vorgaben zur Implementierung der Anteile von PoPP und Zero Trust sind zum Stand der Ver\u00f6ffentlichung von VSDM 2.0 nicht Bestandteil dieses Dokuments. Die Aufnahme der Implementierungsvorgaben aus PoPP und Zero Trust in den ILF f\u00fcr VSDM 2.0 erfolgt iterativ sobald die notwendigen Informationen aus diesen Implementierungsleitf\u00e4den vorliegen.</p> <p>Die in der Spezifikation VSDM 2.0 [gemSpec_VSDM_2] enthaltenen und in den Steckbrief [gemSST_CS_VSDM_2] ausgeleiteten Anforderungen an Clientsysteme haben informativen Charakter und treffen Festlegungen \u00fcber diesen Implementierungsleitfaden hinaus. Die Anforderungen dienen zur Unterst\u00fctzung der Implementierung durch Prim\u00e4rsystemhersteller.</p>"},{"location":"spec-vsdm2/#einleitung","title":"Einleitung","text":"<p>Die gematik geht neue Wege und m\u00f6chte auf diesem Weg die Nutzung der Schnittstellen rund um das VSDM 2.0 vorstellen. Die Beschreibung dieser API erg\u00e4nzt die normativen Dokumente der gematik sowie die Festlegungen \u00fcber die VSDM-Profile (inkl. Beispielen) des genutzten FHIR-Standards.</p> <p>Auf den folgenden Seiten stellt die gematik die Nutzung der Schnittstellen durch die Prim\u00e4rsysteme der Leistungserbringer vor.</p>"},{"location":"spec-vsdm2/#was-ist-vsdm-20","title":"Was ist VSDM 2.0","text":"<p>VSDM steht f\u00fcr \u201eVersichertenstammdatenmanagement\u201c. Es ist ein Teil der Telematikinfrastruktur (TI) im deutschen Gesundheitswesen und dient der Verwaltung und dem Abgleich der Stammdaten von gesetzlich versicherten Personen. VSDM 2.0 ist die Weiterentwicklung des bestehenden VSDM 1.0. Die Versichertenstammdaten (VSD) werden mit VSDM 2.0 nicht mehr auf der eGK des Versicherten gespeichert und aktualisiert sondern direkt vom Prim\u00e4rsystem (PS) des Leistungserbringers (LE) vom Fachdienst der Krankenkasse abgerufen und ggf. im PS aktualisiert. W\u00e4hrend bei VSDM 1.0 in den Anwendungsf\u00e4llen die Komponenten Konnektor, eHealth Kartenterminals, eGK, SMC-B, Intermedi\u00e4r und schlie\u00dflich die VSDM-Backend-Dienste des Versicherers zum Einsatz kommen, reduziert VSDM 2.0 die Abh\u00e4ngigkeiten von diesen Komponenten.  Mit der Initiative TI 2.0 wird die gesamte Infrastruktur modernisiert und auf den neuesten Stand der Sicherheits- und Architekturprinzipien gebracht.</p> <p>In der TI 2.0 wird der Nachweis des Versorgungskontextes mittels PoPP (\u201eProof-of-Patient-Presence\u201c) von fachlichen Anwendungsf\u00e4llen entkoppelt. Bei VSDM 2.0  ist dies die Bereitstellung demografischer Daten. Die Versicherer stellen also eine einfache FHIR-REST-API bereit, mit der die Client-Software der Arztpraxis \u201enur\u201c zus\u00e4tzliche Daten anfordert, indem sie ein legitimes PoPP-Token bereitstellt.</p> <p>Im nachfolgend verlinkten Kapitel finden Sie eine \u00dcbersicht, in welchem Kontext VSDM, PoPP und Zero Trust zueinander stehen:</p> <p>Kontext VSDM/PoPP/ZeroTrust</p> <p>Funktionen des VSDM: - Stammdatenabgleich: \u00dcber das VSDM 2.0 werden die Versichertenstammdaten, wie Name, Geburtsdatum, Anschrift, und Versicherungsschutz, bei jedem Arztbesuch online abgerufen und ggf.  aktualisiert. - Sicherstellung der Aktualit\u00e4t: Es soll sichergestellt werden, dass die im Prim\u00e4rsystem gespeicherten Daten stets aktuell sind. - Datensicherheit: Die Daten werden verschl\u00fcsselt und sicher \u00fcber die Telematikinfrastruktur \u00fcbertragen.</p>"},{"location":"spec-vsdm2/#anwendungsszenarien","title":"Anwendungsszenarien","text":"<p>In diesem Kapitel finden Sie eine Beschreibung der Anwendungsszenarien VSDM 2.0 f\u00fcr die relevanten Sektoren des Gesundheitswesens.</p> <p>Anwendungsszenarien</p>"},{"location":"spec-vsdm2/#anwendungsfalle-in-vsdm-20","title":"Anwendungsf\u00e4lle in VSDM 2.0","text":"<p>Im nachfolgend verlinkten Kapitel finden Sie die \u00dcbersicht der Anwendungsf\u00e4lle im Kontext VSDM 2.0.</p> <p>Anwendungsf\u00e4lle</p>"},{"location":"spec-vsdm2/#ablaufe-im-primarsystem","title":"Abl\u00e4ufe im Prim\u00e4rsystem","text":"<p>Im Rahmen der Anwendungsf\u00e4lle finden im Prim\u00e4rsystem weitere Abl\u00e4ufe im Zusammenhang mit der Versorgung des Versicherten statt. Hier finden Sie Informationen zu den Abl\u00e4ufen im Prim\u00e4rsystem und Interaktionen des Prim\u00e4rsystems mit dem Nutzer.</p> <p>Abl\u00e4ufe</p> <p>Prim\u00e4rsystem-Interaktionen</p>"},{"location":"spec-vsdm2/#informationsmodell-vsd","title":"Informationsmodell VSD","text":"<p>Hier geht es zur Informationsseite zum neuen Informationsmodell f\u00fcr VSDM 2.0.</p> <p>Anmerkung: Die Festlegung der finalen Inhalte des Informationsmodells erfolgt im Rahmen der Fortschreibung dieser Spezifikation. Die in diesem Dokument dargestellten Informationen stellen somit lediglich den bis zum Zeitpunkt der Ver\u00f6ffentlichung abgestimmten Stand dar.</p> <p>Informationsmodell</p>"},{"location":"spec-vsdm2/#prufziffer","title":"Pr\u00fcfziffer","text":"<p>Bei jedem erfolgreich durchgef\u00fchrten Abruf der VSD wird von Fachdienst VSDM 2.0 auch immer die Pr\u00fcfziffer \u00fcbermittelt. Diese wird im Prim\u00e4rsystem gespeichert und kann den Abrechnungsunterlagen beigef\u00fcgt werden.</p> <p>Hier finden Sie weitere Informationen zur Pr\u00fcfziffer f\u00fcr VSDM 2.0.</p> <p>Pr\u00fcfziffer </p>"},{"location":"spec-vsdm2/#fehlerbehandlung","title":"Fehlerbehandlung","text":"<p>Hier geht es zur Informationsseite zum Umgang mit Fehlermeldungen</p> <p>Fehlermeldungen</p> <p>Hier geht es zur Informationsseite zu Statuscodes </p> <p>Statuscodes</p>"},{"location":"spec-vsdm2/#fhir-profile-vsdm-20","title":"FHIR Profile VSDM 2.0","text":"<p>In VSDM 1.0 wurde ein propriet\u00e4res XML-Datenformat in einer SOAP-Servicekette verwendet. Mit VSDM 2.0 wird der VSD Datensatz in den FHIR-Standard migriert, der im deutschen Gesundheitswesen immer mehr zum Einsatz kommt. Die FHIR-Profile und Beispielressourcen werden im offiziellen VSDM 2 simplifier project ver\u00f6ffentlicht.</p>"},{"location":"spec-vsdm2/#mitgeltende-dokumente-und-informationen","title":"Mitgeltende Dokumente und Informationen","text":"<p>Hier finden Sie eine \u00dcbersicht zu den weiterf\u00fchrenden Dokumenten zur Implementierung.</p> <ul> <li>Spezifikation VSDM 2.0</li> <li>FHIR-Profile VSDM 2.0</li> <li>Steckbrief Clientsystem-Schnittstelle zum VSDM 2.0</li> </ul>"},{"location":"spec-vsdm2/#branch-modell","title":"Branch Modell","text":"<p>In diesem Repository werden Branches verwendet um den Status der Weiterentwicklung und das Review von \u00c4nderungen abzubilden. Folgende Branches werden verwendet</p> <ul> <li> <p>main (enth\u00e4lt den letzten freigegebenen Stand der Entwicklung; besteht permanent)</p> </li> <li> <p>develop (enth\u00e4lt den Stand der fertig entwickelten Features und wird zum Review durch Industriepartner und Gesellschafter verwendet; basiert auf main; nach Freigabe erfolgt ein merge in main und ein Release wird erzeugt; besteht permanent)</p> </li> <li> <p>feature/ilf (in feature branches werden neue Features entwickelt (ggf. basierend auf develop); nach Fertigstellung erfolgt ein merge in develop; der feature branch wird nach dem merge gel\u00f6scht)</p> </li> </ul>"},{"location":"spec-vsdm2/#lizenzbedingungen","title":"Lizenzbedingungen","text":"<p>Copyright (c) 2022 gematik GmbH</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"spec-vsdm2/#api-dokumentation-vsdm-20","title":"API Dokumentation VSDM 2.0","text":"<p>Wie oben erw\u00e4hnt, wird das VSDM 2.0 auf die Verwendung einer RESTful FHIR-API reduziert, die hier dokumentiert ist:</p> <p>vsdm2.yaml.</p>"},{"location":"spec-vsdm2/#kontakt","title":"Kontakt","text":"<p>Gehen Sie zu https://www.gematik.de oder OSPO@gematik.de</p>"},{"location":"spec-vsdm2/CODE_OF_CONDUCT/","title":"CODE OF CONDUCT","text":""},{"location":"spec-vsdm2/CODE_OF_CONDUCT/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"spec-vsdm2/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"spec-vsdm2/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"spec-vsdm2/CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"spec-vsdm2/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"spec-vsdm2/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"spec-vsdm2/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at http://contributor-covenant.org/version/1/4</p>"},{"location":"spec-vsdm2/CONTRIBUTING/","title":"Welcome to the gematik contributing guide","text":"<p>Thank you for investing your time in contributing to our projects!</p> <p>Read our Code of Conduct to keep our community approachable and respectable.</p> <p>In this guide you will get an overview how you can contribute to our projects by opening an issue, creating, reviewing and merging a pull request.</p> <p>Use the table of contents icon on the top left corner of this document to get to a specific section of this guide quickly.</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#reporting-a-security-vulnerability","title":"Reporting a security vulnerability","text":"<p>Due to their public nature, GitHub and mailing lists are not appropriate places for reporting vulnerabilities. Please refer to gematik's security disclosure process when reporting issues that may be security related.</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#new-contributor-guide","title":"New contributor guide","text":"<p>To get an overview of the project, read the README.</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#getting-started","title":"Getting started","text":""},{"location":"spec-vsdm2/CONTRIBUTING/#issues","title":"Issues","text":""},{"location":"spec-vsdm2/CONTRIBUTING/#create-a-new-issue","title":"Create a new issue","text":"<p>If you spot a problem with the docs, search if an issue already exists. If a related issue doesn't exist, you can open a new issue.</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#solve-an-issue","title":"Solve an issue","text":"<p>Scan through our existing issues to find one that interests you. If you find an issue to work on, you are welcome to open a PR with a fix.</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#coding-style","title":"Coding Style","text":"<p>gematik projects follow the google style guide conventions. Please follow them when working on your contributions.</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#code-coverage-sonars-owasp-code-format-etc","title":"Code Coverage, Sonars, OWASP, Code format, etc.","text":""},{"location":"spec-vsdm2/CONTRIBUTING/#-","title":"-","text":"<p>-</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#commit-your-update","title":"Commit your update","text":"<p>Commit the changes once you are happy with them.</p>"},{"location":"spec-vsdm2/CONTRIBUTING/#pull-request-process","title":"Pull Request Process","text":"<ul> <li>When you're finished with the changes, create a pull request, also known as a PR.</li> <li>Fill the pull request template so that we can review your PR. This template helps reviewers to understand your changes as well as the purpose of your pull request.</li> <li>Don't forget to link the PR to the issue if you are solving one.</li> <li>Update the README.md, the documentation and the ReleaseRotes.md with all details to document the changes made by this PR.</li> <li>Increase the version numbers in any necessary files and the readme to the new version that this   Pull Request would represent. The versioning scheme we use is SemVer.</li> <li>Once you submit your PR, a project team member will review your proposal. We may ask questions or request additional information.</li> <li>We may ask for changes to be made before a PR can be merged, either using suggested changes   or pull request comments. You can apply suggested changes directly through the UI. You can make any other changes in your fork, then commit them to your branch.</li> <li>As you update your PR and apply changes, mark each conversation as resolved.</li> <li>You may merge the Pull Request in once you have the sign-off of two other developers, or if you   do not have permission to do that, you may request the second reviewer to merge it for you.</li> </ul>"},{"location":"spec-vsdm2/CONTRIBUTING/#your-pr-is-merged","title":"Your PR is merged!","text":"<p>Congratulations :tada::tada: The gematik team thanks you :sparkles:.</p> <p>Once your PR is merged, your contributions will be publicly visible on the gematik github page.</p>"},{"location":"spec-vsdm2/SECURITY/","title":"Security Policy","text":"<p>Since this software is not a productive version, please submit an issue or pull request for any bugs or vulnerabilities you find.</p> <p>In case of a responsible disclosure, please follow instructions on https://www.gematik.de/datensicherheit#c1227.</p>"},{"location":"zeta/docs/","title":"ZETA Dokumentation","text":"<p>Diese Dokumentation beschreibt die Zero Trust Access (ZETA) L\u00f6sung der gematik GmbH. Sie richtet sich an Entwickler, Integratoren und Administratoren, die ZETA in ihre Systeme integrieren oder verwalten m\u00f6chten.</p> <p>ZETA ist eine Zero Trust Access L\u00f6sung, die eine sichere und flexible Zugriffskontrolle f\u00fcr Cloud-native Anwendungen bietet. Sie basiert auf den Prinzipien des Zero Trust Modells und erm\u00f6glicht es, Identit\u00e4ten, Ressourcen und Richtlinien dynamisch zu verwalten. ZETA besteht aus mehreren Komponenten, die zusammenarbeiten, um eine umfassende Sicherheitsarchitektur zu schaffen.</p>"},{"location":"zeta/docs/#zeta-api","title":"ZETA API","text":"<p>Die ZETA API beschreibt aus ZETA Client Sicht, wie man auf ZETA Guard gesch\u00fctzte Resource Server zugreifen kann.</p> <p>ZETA API Dokumentation</p>"},{"location":"zeta/docs/#zeta-guard","title":"ZETA Guard","text":"<p>Der ZETA Guard ist die zentrale Komponente von ZETA, die die Zugriffskontrolle auf Anwendungsebene durchsetzt. Er fungiert als Policy Enforcement Point (PEP) und Policy Decision Point (PDP) und ist verantwortlich f\u00fcr die Durchsetzung von Sicherheitsrichtlinien und die Entscheidung \u00fcber Zugriffsanfragen.</p>"},{"location":"zeta/docs/branch-modell/","title":"Branch Modell","text":"<p>Im ZETA GitHub Repository werden Branches verwendet um den Status der Weiterentwicklung und das Review von \u00c4nderungen abzubilden.</p> <p>Folgende Branches werden verwendet:</p> <ul> <li>main (enth\u00e4lt den letzten freigegebenen Stand der Entwicklung; besteht permanent)</li> <li>develop (enth\u00e4lt den Stand der fertig entwickelten Features und wird zum Review durch Industriepartner und Gesellschafter verwendet; basiert auf main; nach Freigabe erfolgt ein merge in main und ein Release wird erzeugt; besteht permanent)</li> <li>feature/name (in feature branches werden neue Features entwickelt; basiert auf develop; nach Fertigstellung erfolgt ein merge in develop; wird nach dem merge gel\u00f6scht)</li> <li>hotfix/name (in hotfix branches werden Hotfixes entwickelt; basiert auf main; nach Fertigstellung erfolgt ein merge in develop und in main; wird nach dem merge gel\u00f6scht)</li> <li>concept/name (in concept branches werden neue Konzepte entwickelt; basiert auf develop; dient der Abstimmung mit Dritten; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> <li>misc/name (nur f\u00fcr internen Gebrauch der gematik; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> </ul>"},{"location":"zeta/docs/api/zeta-api-versionen/","title":"ZETA API Versionen","text":"<ul> <li>ZETA API v1</li> </ul>"},{"location":"zeta/docs/api/v1/","title":"ZETA API v1","text":"<p>Die ZETA API erm\u00f6glicht es ZETA Clients, auf gesch\u00fctzte Ressourcen zuzugreifen und dabei Sicherheits- und Authentifizierungsmechanismen zu nutzen. Der ZETA Client nutzt Endpunkte des ZETA Guard f\u00fcr die Client-Registrierung, Authentifizierung und Autorisierung.</p> <p>Station\u00e4re Clients verwenden bei der Authentifizierung Endpunkte des Konnektors/TI-Gateways und des ZETA Attestation Service.</p> <p>Mobile Clients verwenden Endpunkte der betriebssystem-spezifischen Attestierung. Die Authentifizierung erfolgt mit OpenID Connect (OIDC) und der ZETA Guard API.</p> <p>Die ZETA API ist so konzipiert, dass sie eine sichere und flexible Interaktion zwischen ZETA Clients und gesch\u00fctzten Ressourcen erm\u00f6glicht. ZETA basiert auf den Standards des OAuth 2.0 Frameworks und erweitert es um spezifische Anforderungen der gematik.</p>"},{"location":"zeta/docs/api/v1/#voraussetzungen-fur-die-zeta-client-nutzung","title":"Voraussetzungen f\u00fcr die ZETA Client Nutzung","text":"<p>Folgende Voraussetzungen m\u00fcssen f\u00fcr die Nutzung des ZETA Clients erf\u00fcllt sein:</p> <ul> <li>Der FQDN des Resource Servers wird vom ZETA Client ben\u00f6tigt, um die ZETA Guard API zu erreichen.</li> <li>Die roots.json Datei wird vom ZETA Client ben\u00f6tigt, um die Trust Chain zu validieren. Diese Datei muss w\u00f6chentlich aktualisiert werden.</li> </ul> <p>Zus\u00e4tzlich gibt es anwendungsspezifische Voraussetzungen, die f\u00fcr die Nutzung der ZETA Guard API erforderlich sind.</p> <ul> <li>VSDM2: F\u00fcr VSDM2 Requests wird ein PoPP (Proof of Patient Presence) Token ben\u00f6tigt. Das PoPP Token muss im Header PoPP an den ZETA Client \u00fcbergeben werden.</li> </ul>"},{"location":"zeta/docs/api/v1/#ablauf","title":"Ablauf","text":"<p>Abh\u00e4ngig vom Zustand des ZETA Clients m\u00fcssen verschiedene Teilabl\u00e4ufe ausgef\u00fchrt werden, oder k\u00f6nnen \u00fcbersprungen werden. Die ZETA API besteht aus mehreren Endpunkten, die verschiedene Funktionen bereitstellen. Diese Endpunkte sind in verschiedene Unter-Abl\u00e4ufe aufgeteilt:</p> <ul> <li>Konfiguration und Discovery: Der ZETA Client muss die Konfiguration des ZETA Guards ermitteln, um die richtigen Endpunkte zu erreichen.</li> <li>Client-Registrierung: Jeder ZETA Client muss sich einmalig beim ZETA Guard registrieren, um eine <code>client_id</code> zu erhalten und seinen \u00f6ffentlichen Schl\u00fcssel zu hinterlegen.</li> <li>Authentifizierung und Autorisierung: Der Client muss sich authentifizieren und die Integrit\u00e4t seiner Plattform nachweisen. Zus\u00e4tzlich muss sich der Nutzer oder beim Prim\u00e4rsystem die Organisation authentifizieren, um ein Access Token f\u00fcr den Zugriff auf gesch\u00fctzte Ressourcen zu erhalten.</li> </ul> <p>Der Gesamtprozess beginnt damit, dass ein Nutzer auf einen Endpunkt eines Resource Servers zugreifen m\u00f6chte. Dieser Zugriff wird \u00fcber das Prim\u00e4rsystem vom ZETA Client im Auftrag des Nutzers ausgef\u00fchrt; siehe folgende Abbildung.</p> <p> Abbildung 1: Ablauf TPM Attestation und Token Exchange \u00dcberblick </p>"},{"location":"zeta/docs/api/v1/#konfiguration-und-discovery","title":"Konfiguration und Discovery","text":"<p>In dieser Phase ermittelt der ZETA Client die notwendigen Endpunkte und Konfigurationen von den ZETA Guard Komponenten (PEP http Proxy und PDP Authorization Server). Der Client fragt bekannte Endpunkte (<code>/.well-known/oauth-protected-resource</code> und <code>/.well-known/oauth-authorization-server</code>) ab, um die Konfiguration des Resource Servers und des Authorization Servers zu erhalten. Das folgende Bild zeigt den Ablauf.</p> <p> Abbildung 2: Ablauf Discovery and Configuration </p>"},{"location":"zeta/docs/api/v1/#client-registrierung","title":"Client-Registrierung","text":""},{"location":"zeta/docs/api/v1/#stationare-clients","title":"Station\u00e4re Clients","text":"<p>Jeder ZETA Client muss sich am ZETA Guard registrieren, \u00fcber den er auf gesch\u00fctzte Ressourcen zugreifen m\u00f6chte. Dieser Prozess findet einmalig pro ZETA Guard-Instanz statt. Der gesamte Prozess ist zweistufig, um die administrative Einrichtung von der technischen Inbetriebnahme zu trennen:</p> <ul> <li>Initiale Registrierung: Der Client erzeugt ein langlebiges kryptographisches Schl\u00fcsselpaar (Client Instance Key), sendet den \u00f6ffentlichen Teil an den Authorization Server und erh\u00e4lt im Gegenzug eine <code>client_id</code>. Der Client ist danach im System bekannt, aber sein Status ist <code>pending_attestation</code>, d.h. er ist noch nicht f\u00fcr den Zugriff auf Ressourcen freigeschaltet.</li> <li>Aktivierung (Erster Token Exchange): Der Client wird aktiviert, indem er zum ersten Mal einen Token Exchange mit einer erfolgreichen Attestierung durchf\u00fchrt. Damit beweist er nicht nur den Besitz des privaten Schl\u00fcssels, sondern (bei der TPM-Attestierung) auch die Integrit\u00e4t der Plattform, auf der er l\u00e4uft. Nach erfolgreicher Pr\u00fcfung wird sein Status im ZETA Guard auf <code>active</code> gesetzt.</li> </ul> <p>Die Client Registrierung ist in der folgenden Abbildung dargestellt.</p> <p> Abbildung 3: Ablauf Client Registrierung </p> <p>F\u00fcr die initiale Registrierung sendet der ZETA Client eine Anfrage an den Dynamic Client Registration (DCR) Endpoint. Diese Anfrage enth\u00e4lt alle notwendigen Metadaten, um den Client f\u00fcr die <code>private_key_jwt</code> Authentifizierungsmethode vorzubereiten:</p> <ul> <li><code>client_name</code>: Ein f\u00fcr Menschen lesbarer Name f\u00fcr den Client.</li> <li><code>token_endpoint_auth_method</code>: Die geplante Authentifizierungsmethode, hier <code>private_key_jwt</code>.</li> <li><code>grant_types</code>: Die erlaubten Grant Types (z.B. <code>urn:ietf:params:oauth:grant-type:token-exchange</code>, <code>refresh_token</code>).</li> <li><code>jwks</code>: Ein JSON Web Key Set, das den \u00f6ffentlichen Client Instance Key enth\u00e4lt. Dieser Schl\u00fcssel wird vom Authorization Server verwendet, um die Signatur der Client Assertions zu \u00fcberpr\u00fcfen.</li> </ul>"},{"location":"zeta/docs/api/v1/#mobile-clients","title":"Mobile Clients","text":"<p>Hinweis: Der Prozess f\u00fcr Mobile Clients wird in zuk\u00fcnftigen Versionen der API detaillierter beschrieben, sobald die Entwicklung von ZETA Stufe 2 abgeschlossen ist.</p>"},{"location":"zeta/docs/api/v1/#authentifizierung-und-autorisierung","title":"Authentifizierung und Autorisierung","text":"<p>Nach erfolgreicher Registrierung besitzt der ZETA Client eine <code>client_id</code> und ein zugeh\u00f6riges Schl\u00fcsselpaar. Um auf einen Fachdienst zugreifen zu k\u00f6nnen, ben\u00f6tigt der Client ein Access Token vom Authorization Server (AS). Station\u00e4re ZETA Clients verwenden daf\u00fcr den Token Exchange Flow, w\u00e4hrend mobile ZETA Clients den Authorization Code Flow mit OpenID Connect nutzen.</p>"},{"location":"zeta/docs/api/v1/#stationare-clients_1","title":"Station\u00e4re Clients","text":"<p>Die Authentifizierung und Autorisierung f\u00fcr station\u00e4re Clients unterscheidet zwei Hauptf\u00e4lle:</p> <ol> <li>Token-Austausch mit Attestierung: Hier wird die Identit\u00e4t der Institution (mittels <code>subject_token</code> von der SM(C)-B) nachgewiesen und die Integrit\u00e4t des Clients durch eine Attestierung \u00fcberpr\u00fcft. Dieser aufw\u00e4ndigere Prozess wird zu Beginn einer neuen Session (oder zur Re-Attestierung) durchgef\u00fchrt, um sicherzustellen, dass der ZETA Client und das Prim\u00e4rsystem vertrauensw\u00fcrdig sind.</li> <li>Token-Erneuerung (Refresh Token): Hier wird ein vorhandenes Refresh Token genutzt, um ein neues Access Token zu erhalten. Dieser Prozess ist performanter und verzichtet auf eine erneute Attestierung.</li> </ol> <p>Diese Trennung schafft eine Balance zwischen h\u00f6chster Sicherheit beim initialen Zugriff und Effizienz bei der Erneuerung bestehender Sitzungen.</p> <p>Die folgende Abbildung zeigt den Ablauf des Token-Austauschs mit Client Assertion JWT Authentifizierung und DPoP.</p> <p> Abbildung 4: Ablauf Authentifizierung und TPM-Attestation </p>"},{"location":"zeta/docs/api/v1/#pfad-a-token-austausch-mit-attestierung","title":"Pfad A: Token-Austausch mit Attestierung","text":"<p>Dieser Pfad wird beschritten, wenn der Client keine bestehende Session (d.h. kein g\u00fcltiges Refresh Token) hat.</p> <ol> <li> <p>Vorbereitung:</p> <ul> <li>Der Client fordert eine frische, einmalig g\u00fcltige <code>nonce</code> vom Authorization Server an (<code>GET /nonce</code>).</li> <li>Der Client erzeugt ein tempor\u00e4res, nur f\u00fcr diese Session g\u00fcltiges DPoP-Schl\u00fcsselpaar.</li> </ul> </li> <li> <p>Integrit\u00e4tspr\u00fcfung und kryptografische Bindung:</p> <ul> <li>Um zu beweisen, dass die Attestierung f\u00fcr genau diesen Client und diese Transaktion erstellt wurde, erzeugt der Client eine <code>attestation_challenge</code>. Diese bindet den Zustand des TPMs an den \u00f6ffentlichen Client Instance Key und die <code>nonce</code> des AS: <code>attestation_challenge = HASH( HASH(Client_Instance_Public_Key_JWK) + nonce )</code>.</li> <li>Der Client fordert beim ZETA Attestation Service eine TPM Quote an, die diese <code>attestation_challenge</code> als <code>qualifyingData</code> enth\u00e4lt. Das TPM signiert somit eine Aussage, die mit der Identit\u00e4t des Clients verbunden ist.</li> </ul> </li> <li> <p>Erstellen des Client Statement: Die Attestierungsartefakte (TPM Quote, Event Log, Zertifikatskette) werden in eine <code>client_statement</code>-Struktur gepackt. Im Falle des Fallbacks (Software-Attestierung) enth\u00e4lt diese Struktur andere, softwarebasierte Evidenz.</p> </li> <li> <p>Erstellen der Client Assertion (mit Attestierung): F\u00fcr die Authentifizierung am Token-Endpoint erstellt der Client eine Client Assertion. Dieses JWT, mit dem privaten Client Instance Key signiert, dient als \"Umschlag\":</p> <ul> <li>Es authentifiziert den Client gegen\u00fcber dem AS (<code>iss</code> und <code>sub</code> sind die <code>client_id</code>).</li> <li>Es enth\u00e4lt die <code>client_statement</code>-Struktur als Beweis f\u00fcr die Ger\u00e4teintegrit\u00e4t, verpackt in einem spezifischen Claim (<code>urn:gematik:params:oauth:client-attestation:tpm2</code> oder <code>...:software</code>).</li> </ul> <pre><code>// Client Assertion f\u00fcr initialen Token-Austausch (Beispiel TPM)\n{\n  \"iss\": \"&lt;client_id&gt;\", \"sub\": \"&lt;client_id&gt;\",\n  \"aud\": \"&lt;AS_Token_Endpoint_URL&gt;\",\n  \"exp\": ..., \"jti\": \"...\",\n  // Kapselung des Attestierungsnachweises\n  \"urn:gematik:params:oauth:client-attestation:tpm2\": {\n     \"attestation_data\": \"&lt;Base64(client_statement)&gt;\",\n     \"client_statement_format\": \"client-statement\"\n   }\n}\n</code></pre> </li> <li> <p>Authentisierung der Institution (SM(C)-B Token): Parallel dazu erstellt der Client das <code>subject_token</code>. Dies ist ein vom ZETA Client erzeugtes JWT, dessen Hash vom Konnektor mittels der SM(C)-B signiert wird und die Identit\u00e4t der Institution (z.B. Praxis) belegt. Die Audience (<code>aud</code>) dieses Tokens ist der Ziel-Fachdienst (Resource Server).</p> </li> <li> <p>Token Request: Der Client sendet eine <code>POST</code>-Anfrage an den <code>/token</code>-Endpoint, die alle Teile kombiniert: <code>grant_type=token-exchange</code>, das <code>subject_token</code>, die <code>client_assertion</code> (mit der eingebetteten Attestierung) und den DPoP-Proof.</p> </li> <li> <p>Validierung durch den AS: Der AS f\u00fchrt eine umfassende Pr\u00fcfung durch: Validierung der Client Assertion (Signatur gegen den bei der DCR hinterlegten Public Key), des DPoP-Proofs, des Subject Tokens und insbesondere der eingebetteten Attestierung (Pr\u00fcfung der Quote, der <code>attestation_challenge</code> und der PCR-Werte gegen die Sicherheits-Policy).</p> </li> </ol>"},{"location":"zeta/docs/api/v1/#pfad-b-token-erneuerung-via-refresh-token","title":"Pfad B: Token-Erneuerung via Refresh Token","text":"<p>Dieser effiziente Pfad wird genutzt, wenn ein g\u00fcltiges Refresh Token vorhanden ist.</p> <ol> <li> <p>Erstellen der Client Assertion (ohne Attestierung): Der Client erstellt eine einfache <code>client_assertion</code>. Sie beweist durch ihre Signatur mit dem Client Instance Key die Identit\u00e4t des Clients. Diese Assertion enth\u00e4lt keine Attestierungsdaten.</p> <pre><code>// Client Assertion f\u00fcr Refresh-Token-Nutzung\n{\n  \"iss\": \"&lt;client_id&gt;\",\n  \"sub\": \"&lt;client_id&gt;\",\n  \"aud\": \"&lt;AS_Token_Endpoint_URL&gt;\",\n  \"exp\": ..., \"jti\": \"...\"\n}\n</code></pre> </li> <li> <p>Token Request: Der Client sendet eine <code>POST</code>-Anfrage an den <code>/token</code>-Endpoint mit <code>grant_type=refresh_token</code>, dem Refresh Token und der einfachen <code>client_assertion</code>.</p> </li> <li> <p>Validierung durch den AS: Der AS validiert das Refresh Token, die Signatur der Client Assertion und den DPoP-Proof. Die Pr\u00fcfung einer TPM-Attestierung entf\u00e4llt. Bei Erfolg wird das alte Refresh Token invalidiert (Rotation).</p> </li> </ol>"},{"location":"zeta/docs/api/v1/#gemeinsame-nachfolgende-schritte","title":"Gemeinsame nachfolgende Schritte","text":"<p>Nach erfolgreicher Validierung in einem der beiden Pfade fragt der AS bei der Policy Engine (PE) an, ob der Zugriff gew\u00e4hrt werden soll. Ist die Entscheidung positiv, stellt der AS ein neues Access Token (gebunden an den DPoP-Schl\u00fcssel) und ein neues Refresh Token aus.</p>"},{"location":"zeta/docs/api/v1/#mobile-clients_1","title":"Mobile Clients","text":"<p>Die Authentifizierung f\u00fcr mobile Clients erfolgt mit OpenID Connect und OAuth2 Authorization Code Flow. Die Beschreibung wird erg\u00e4nzt, wenn die Entwicklung von ZETA Stufe 2 abgeschlossen ist.</p>"},{"location":"zeta/docs/api/v1/#endpunkte","title":"Endpunkte","text":"<p>Die ZETA API besteht aus mehreren Endpunkten, die verschiedene Funktionen bereitstellen. Diese Endpunkte sind in verschiedene Kategorien unterteilt:</p> <ul> <li>ZETA Guard API Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem ZETA Guard, einschlie\u00dflich der Registrierung von Clients, der Authentifizierung und der Autorisierung.</li> <li>Konnektor/TI-Gateway Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem Konnektor/TI-Gateway, um Karteninformationen zu lesen und Authentifizierungsanfragen zu stellen.</li> <li>ZETA Attestation Service Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem ZETA Attestation Service, um TPM-Attestierungen durchzuf\u00fchren.</li> </ul>"},{"location":"zeta/docs/api/v1/#zeta-guard-api-endpunkte","title":"ZETA Guard API Endpunkte","text":"<p>Die ZETA Guard API Endpunkte sind f\u00fcr die Interaktion mit dem ZETA Guard zust\u00e4ndig. Sie erm\u00f6glichen die Registrierung von Clients, die Authentifizierung und Autorisierung sowie den Zugriff auf gesch\u00fctzte Ressourcen. Die ZETA Guard API Endpunkte sind \u00fcber HTTPS erreichbar und erfordern eine g\u00fcltige TLS-Verbindung. Der ZETA Client muss die folgenden Sicherheitsanforderungen erf\u00fcllen:</p> <ul> <li>ZETA Clients m\u00fcssen TLS 1.3 oder h\u00f6her unterst\u00fctzen.</li> <li>Es m\u00fcssen die TLS Anforderungen aus gemSpec_Krypt Kapitel 3.3.2 erf\u00fcllt werden.</li> </ul>"},{"location":"zeta/docs/api/v1/#oauth-protected-resource-well-known-endpoint","title":"OAuth Protected Resource Well-Known Endpoint","text":"<p>Dieser Endpunkt bietet eine standardisierte Methode f\u00fcr OAuth Protected Resources (OPR), um ihre F\u00e4higkeiten und Konfigurationsdetails zu ver\u00f6ffentlichen (RFC 9728). Er erm\u00f6glicht es Clients, die notwendigen Informationen \u00fcber die OPR abzurufen, wie z.B. unterst\u00fctzte Schemata, Verifizierungsmethoden, Token-Introspektion-Endpunkte und unterst\u00fctzte Scopes. Der Endpunkt ist unter dem Pfad <code>/.well-known/oauth-protected-resource</code> relativ zur Basis-URL der Protected Resource erreichbar.</p>"},{"location":"zeta/docs/api/v1/#anfragen","title":"Anfragen","text":"<p>Der Endpunkt wird \u00fcber eine einfache HTTP GET-Anfrage ohne Body aufgerufen.</p> <pre><code>GET /.well-known/oauth-protected-resource HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"zeta/docs/api/v1/#antworten","title":"Antworten","text":"<p>Wie im obigen Abschnitt dargestellt, ist die typische erfolgreiche API-Antwort ein JSON-Objekt, das der im <code>opr-well-known.yaml</code>-Schema definierten Struktur entspricht. Der <code>Content-Type</code>-Header der Antwort ist <code>application/json</code>.</p> <p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und die Konfigurationsdaten der Protected Resource wurden als JSON-Objekt im Antwort-Body zur\u00fcckgegeben.   Eine erfolgreiche Anfrage liefert ein JSON-Objekt, das die Konfiguration der Protected Resource beschreibt. Die genauen Felder h\u00e4ngen von der Implementierung und den unterst\u00fctzten F\u00e4higkeiten der gesch\u00fctzten Resource ab.</li> <li>Beispielantwort:</li> </ul> <p>Content-Type: application/json</p> <pre><code>{\n  \"resource\": \"https://api.example.com\",\n  \"authorization_servers\": [\n    \"https://auth1.example.com\",\n    \"https://auth2.example.com\"\n  ],\n  \"jwks_uri\": \"https://api.example.com/.well-known/jwks.json\",\n  \"scopes_supported\": [\n    \"read\",\n    \"write\",\n    \"delete\"\n  ],\n  \"bearer_methods_supported\": [\n    \"header\",\n    \"body\"\n  ],\n  \"resource_signing_alg_values_supported\": [\n    \"RS256\",\n    \"ES256\"\n  ],\n  \"resource_name\": \"Example Protected API\",\n  \"resource_documentation\": \"https://docs.example.com/api\",\n  \"resource_policy_uri\": \"https://www.example.com/privacy\",\n  \"resource_tos_uri\": \"https://www.example.com/terms\",\n  \"tls_client_certificate_bound_access_tokens\": true,\n  \"authorization_details_types_supported\": [\n    \"payment_initiation\",\n    \"account_access\"\n  ],\n  \"dpop_signing_alg_values_supported\": [\n    \"ES256\",\n    \"RS512\"\n  ],\n  \"dpop_bound_access_tokens_required\": true,\n  \"signed_metadata\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJyZXNvdXJjZSI6Imh0dHBzOi8vYXBpLmV4YW1wbGUuY29tIn0.XYZ123abc456def789\",\n  \"zeta_asl_use\": \"required\",\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ]\n}\n</code></pre> <ul> <li>404 Not Found:</li> <li>Bedeutung: Der angeforderte Well-Known Endpoint konnte auf dem Server nicht gefunden werden. Dies kann daran liegen, dass die Protected Resource diesen Endpunkt nicht hostet oder falsch konfiguriert ist.</li> <li>Beispielantwort:</li> </ul> <p>Content-Type: application/problem+json</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"OAuth Protected Resource Configuration Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested OAuth Protected Resource Well-Known configuration could not be found at this path.\",\n  \"instance\": \"/.well-known/oauth-protected-resource\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server der Protected Resource aufgetreten, der die Verarbeitung der Anfrage verhindert hat.</li> <li>Beispielantwort: Ein leerer Body, ein generischer Content-Type: application/problem+json</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/.well-known/oauth-protected-resource\"\n}\n</code></pre>"},{"location":"zeta/docs/api/v1/#authorization-server-well-known-endpoint","title":"Authorization Server Well-Known Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht Clients und anderen Parteien die einfache Entdeckung der Konfigurationsmetadaten eines ZETA Guard OAuth 2.0 Autorisierungsservers (AS) und seiner F\u00e4higkeiten. Er ist gem\u00e4\u00df RFC 8414 definiert und bietet eine standardisierte Methode, um Informationen wie Endpunkt-URIs, unterst\u00fctzte Grant Types und Scopes abzurufen.</p>"},{"location":"zeta/docs/api/v1/#anfragen_1","title":"Anfragen","text":"<p>Dieser Endpunkt wird \u00fcber eine HTTP GET-Anfrage ohne Parameter aufgerufen.</p> <p>Methode: <code>GET</code></p> <p>Header: Ein <code>Accept</code>-Header mit <code>application/json</code> wird empfohlen, um die bevorzugte Antwortformat anzugeben.</p> <p>Beispiel Anfrage:</p> <pre><code>GET /.well-known/oauth-authorization-server HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"zeta/docs/api/v1/#antworten_1","title":"Antworten","text":"<p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt die Konfigurationsmetadaten des Autorisierungsservers als JSON-Objekt zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"issuer\": \"https://api.example.com\",\n  \"authorization_endpoint\": \"https://api.example.com/auth\",\n  \"token_endpoint\": \"https://api.example.com/token\",\n  \"jwks_uri\": \"https://api.example.com/certs\",\n  \"response_types_supported\": [\n    \"code\",\n    \"token\"\n  ],\n  \"response_modes_supported\": [\n    \"query\",\n    \"fragment\",\n    \"form_post\"\n  ],\n  \"grant_types_supported\": [\n    \"authorization_code\",\n    \"token-exchange\",\n    \"refresh_token\"\n  ],\n  \"token_endpoint_auth_methods_supported\": [\n    \"private_key_jwt\"\n  ],\n  \"token_endpoint_auth_signing_alg_values_supported\": [\n    \"ES256\"\n  ],\n  \"service_documentation\": \"https://api.example.com/docs\",\n  \"code_challenge_methods_supported\": [\n    \"S256\"\n  ],\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ],\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ]\n}\n</code></pre> <p>404 Not Found:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn der Endpunkt unter der angefragten URL nicht gefunden werden kann.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested resource was not found on this server.\",\n  \"instance\": \"/.well-known/oauth-authorization-server\"\n}\n</code></pre> <p>500 Internal Server Error:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn ein unerwarteter Fehler auf dem Server auftritt, der die Anfrage nicht verarbeiten konnte.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/.well-known/oauth-authorization-server\"\n}\n</code></pre>"},{"location":"zeta/docs/api/v1/#nonce-endpoint","title":"Nonce Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht Clients das Abrufen eines einmaligen kryptographischen Werts, einer \"Nonce\". Im Kontext der ZETA-Architektur dient diese Nonce prim\u00e4r dazu, eine spezifische TPM-Attestierung an eine aktuelle Transaktion zu binden, um Replay-Angriffe zu verhindern. Sie wird Teil der <code>attestation_challenge</code>, die vom TPM signiert wird.</p> <p>Beim Token Endpunkt wird ebenfalls eine Nonce ben\u00f6tigt, um die Integrit\u00e4t der Transaktion zu gew\u00e4hrleisten. Diese Nonce wird in der Client Assertion verwendet, um Replay-Angriffe zu verhindern und die Bindung zwischen der Client Authentifizierung und der Transaktion sicherzustellen.</p>"},{"location":"zeta/docs/api/v1/#anfragen_2","title":"Anfragen","text":"<p>Beispiel Anfrage:</p> <pre><code>GET /nonce HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"zeta/docs/api/v1/#antworten_2","title":"Antworten","text":"<p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt die Nonce als JSON-Objekt zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"nonce\": \"s.fRzE3M0J_QxL-x.6gA~x\",\n  \"expires_in\": 30\n}\n</code></pre> <p>Felder der erfolgreichen Antwort:</p> <ul> <li><code>nonce</code> (String): Der generierte, einmalige kryptographische Wert.</li> <li><code>expires_in</code> (Integer): Die G\u00fcltigkeitsdauer der Nonce in Sekunden, ab dem Zeitpunkt der Ausstellung. Nach Ablauf dieser Zeit sollte die Nonce vom Server nicht mehr akzeptiert werden.</li> </ul> <p>404 Not Found:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn der Endpunkt unter der angefragten URL nicht gefunden werden kann.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested resource was not found on this server.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre> <p>429 Too Many Requests:</p> <p>Dieser Fehler tritt auf, wenn der Client die vom Server festgelegten Ratenbegrenzungen \u00fcberschreitet.</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Retry-After: 60</p> <pre><code>{\n  \"type\": \"tag:authorization.example.com,2023:oauth:nonce:rate_limit_exceeded\",\n  \"title\": \"Rate Limit Exceeded\",\n  \"status\": 429,\n  \"detail\": \"You have exceeded the allowed number of nonce requests. Please try again after 60 seconds.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre> <ul> <li><code>Retry-After</code> Header (optional): Gibt an, wie viele Sekunden der Client warten sollte, bevor er eine weitere Anfrage stellt.</li> </ul> <p>500 Internal Server Error:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn ein unerwarteter Fehler auf dem Server auftritt, der die Anfrage nicht verarbeiten konnte.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre>"},{"location":"zeta/docs/api/v1/#dynamic-client-registration-endpoint","title":"Dynamic Client Registration Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht die dynamische Registrierung neuer OAuth 2.0 Clients beim Authorization Server gem\u00e4\u00df RFC 7591. Der Prozess dient dazu, eine <code>client_id</code> zu erhalten und den \u00f6ffentlichen Client Instance Key zu registrieren, der f\u00fcr die <code>private_key_jwt</code> Client-Authentifizierung verwendet wird.</p> <p>Die Registrierung selbst erfordert keine Attestierung. Der Client erh\u00e4lt den Status <code>pending_attestation</code> und muss seine Integrit\u00e4t beim ersten Token Exchange beweisen, um aktiviert zu werden. Die Registrierung muss \u00fcber eine TLS-gesch\u00fctzte Verbindung erfolgen.</p> <p>Hinweis: Es fehlen noch die Operationen zur Verwaltung von bestehenden Client Registrierungen (z.B. Aktualisierung, L\u00f6schung). Diese werden in zuk\u00fcnftigen Versionen der API erg\u00e4nzt.</p>"},{"location":"zeta/docs/api/v1/#anfragen-fur-stationare-clients","title":"Anfragen f\u00fcr station\u00e4re Clients","text":"<p>Der Client sendet eine <code>POST</code>-Anfrage an den <code>/register</code>-Endpunkt. Der Anfrage-Body ist ein JSON-Objekt, das die Metadaten des zu registrierenden Clients enth\u00e4lt.</p> <p>Beispiel Anfrage:</p> <pre><code>POST /register HTTP/1.1\nHost: api.example.com\nAccept: application/json\nContent-type: application/json\n</code></pre> <pre><code>{\n  \"client_name\": \"Praxis-PC-123\",\n  \"token_endpoint_auth_method\": \"private_key_jwt\",\n  \"grant_types\": [\n    \"urn:ietf:params:oauth:grant-type:token-exchange\",\n    \"refresh_token\"\n  ],\n  \"jwks\": {\n    \"keys\": [\n      {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"...\",\n        \"y\": \"...\",\n        \"use\": \"sig\",\n        \"kid\": \"...\"\n      }\n    ]\n  },\n  \"redirect_uris\": [\n    \"https://client.example.org/cb\"\n  ]\n}\n</code></pre> <p>Erforderliche Parameter im Anfrage-Body:</p> Parameter Typ Beschreibung <code>grant_types</code> <code>array</code> Eine Liste der Grant Types, die der Client verwenden darf. <code>jwks</code> <code>object</code> Das JSON Web Key Set [RFC7517] des Clients, das den \u00f6ffentlichen Client Instance Key enth\u00e4lt. <code>token_endpoint_auth_method</code> <code>string</code> Muss <code>private_key_jwt</code> sein, um die Client-Authentifizierung mittels signierter JWTs zu erzwingen. <code>redirect_uris</code> <code>array</code> Optional f\u00fcr reine Backend-Clients, aber empfohlen. Mindestens eine URI, die f\u00fcr interaktive Flows (z.B. zuk\u00fcnftige mobile Clients) verwendet wird. <code>client_name</code> <code>string</code> Optional. Ein f\u00fcr Menschen lesbarer Name f\u00fcr den Client."},{"location":"zeta/docs/api/v1/#antworten_3","title":"Antworten","text":"<p>Der Authorization Server antwortet mit verschiedenen HTTP-Statuscodes und entsprechenden JSON-Objekten, die entweder die erfolgreiche Registrierung oder Fehlermeldungen gem\u00e4\u00df RFC 9457 (\"Problem Details for HTTP APIs\") beschreiben.</p> <p>Statuscodes:</p> <ul> <li>201 Created:</li> <li>Bedeutung: Die Registrierung war erfolgreich. Der Server gibt die <code>client_id</code> und die registrierten Metadaten zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li> <p>Beispiel Antwort:</p> <pre><code>{\n  \"client_id\": \"1234567890abcdef\",\n  \"client_id_issued_at\": 1678886400,\n  \"grant_types\": [\n    \"urn:ietf:params:oauth:grant-type:token-exchange\",\n    \"refresh_token\"\n  ],\n  \"token_endpoint_auth_method\": \"private_key_jwt\",\n  \"client_name\": \"Praxis-PC-123\",\n  \"jwks\": {\n    \"keys\": [\n      {\n        \"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"...\", \"y\": \"...\", \"use\": \"sig\", \"kid\": \"...\"\n      }\n    ]\n  },\n   \"redirect_uris\": [\n    \"https://client.example.org/cb\"\n  ]\n}\n</code></pre> </li> <li> <p>400 Bad Request:</p> </li> <li>Bedeutung: Die Anfrage war fehlerhaft, z.B. fehlende oder ung\u00fcltige Parameter.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/400\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"Invalid request parameters.\",\n  \"instance\": \"/register\"\n}\n</code></pre> <ul> <li>409 Conflict  :</li> <li>Bedeutung: Ein Client mit dem angegebenen <code>Client_Instance_Public_Key</code> existiert bereits.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/409\",\n  \"title\": \"Conflict\",\n  \"status\": 409,\n  \"detail\": \"A client with the provided Client_Instance_Public_Key already exists.\",\n  \"instance\": \"/register\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server aufgetreten, der die Anfrage nicht verarbeiten konnte.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/register\"\n}\n</code></pre>"},{"location":"zeta/docs/api/v1/#anfragen-fur-mobile-clients","title":"Anfragen f\u00fcr mobile Clients","text":"<p>Die Registrierung f\u00fcr mobile Clients erfolgt \u00e4hnlich wie bei station\u00e4ren Clients, jedoch mit anderen Anforderungen an die Client-Attestation, die auf den jeweiligen Plattformen basieren. Mobile Clients verwenden eine spezifische Attestierungsmethode, die auf den Betriebssystemen basiert (z.B. Android SafetyNet, iOS DeviceCheck).</p> <p>Die Beschreibung wird in Stufe 2 der ZETA API erg\u00e4nzt.</p>"},{"location":"zeta/docs/api/v1/#token-endpoint","title":"Token Endpoint","text":"<p>Der Token Endpoint des Autorisierungsservers (AS) erm\u00f6glicht den Austausch eines Tokens gegen ein vom Authorizationserver ausgestelltes Access Token, gem\u00e4\u00df dem OAuth 2.0 Token Exchange (RFC 8693) oder die Erneuerung von Token (<code>refresh_token</code>). Der Client muss sich mit einer JWT Client Assertion gegen\u00fcber den Authorization Server authentifizieren.</p> <p>Der Endpunkt ist ein POST-Endpunkt, der Formular-kodierte Daten (<code>application/x-www-form-urlencoded</code>) im Body erwartet und JSON-Objekte im Erfolgsfall oder \"Problem Details\" im Fehlerfall zur\u00fcckgibt.</p> <p>Der Endpunkt unterst\u00fctzt verschiedene Grant Types, einschlie\u00dflich <code>authorization_code</code> (ab ZETA Stufe 2), <code>urn:ietf:params:oauth:grant-type:token-exchange</code>, <code>refresh_token</code> und <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p>"},{"location":"zeta/docs/api/v1/#anfragen_3","title":"Anfragen","text":"<p>Der Token Endpoint empf\u00e4ngt POST-Anfragen mit dem Content-Type <code>application/x-www-form-urlencoded</code>. Die Anfrage muss die notwendigen Parameter f\u00fcr den Token Exchange Grant Type enthalten, sowie die Client-Authentifizierung mittels JWT Bearer Client Assertion.</p> <p>HTTP Methode: <code>POST</code></p> <p>Pfad: <code>/token</code></p> <p>Content-Type: <code>application/x-www-form-urlencoded</code></p> <p>Anfrageparameter:</p> Parameter Typ Erforderlich Beschreibung <code>grant_type</code> <code>string</code> Ja Der Grant Type. F\u00fcr Token Exchange ist dies immer <code>urn:ietf:params:oauth:grant-type:token-exchange</code>. <code>client_assertion_type</code> <code>string</code> Ja Gibt den Typ der Client Assertion an. F\u00fcr JWT Bearer Client Assertion ist dies immer <code>urn:ietf:params:oauth:client-assertion-type:jwt-bearer</code>. <code>client_assertion</code> <code>string</code> Ja Die JWT, die zur Authentifizierung des Clients dient. Diese JWT muss vom Client signiert sein und folgende Claims enthalten: - <code>iss</code> (Issuer): Die Client ID.- <code>sub</code> (Subject): Die Client ID.- <code>aud</code> (Audience): Die URL des Token Endpoints.- <code>exp</code> (Expiration Time): Die Zeit, nach der die JWT ung\u00fcltig wird.- <code>jti</code> (JWT ID): Ein eindeutiger Bezeichner f\u00fcr diese JWT, um Replay-Angriffe zu verhindern.- <code>iat</code> (Issued At): Zeitpunkt der Ausstellung der JWT. <code>resource</code> <code>string</code> Ja Eine URI, die den Zieldienst oder die Zielressource angibt, f\u00fcr die der Client das angeforderte Sicherheitstoken verwenden m\u00f6chte. Dadurch kann der Autorisierungsserver die f\u00fcr das Ziel geeigneten Richtlinien anwenden, z. B. den Typ und Inhalt des auszugebenden Tokens bestimmen oder festlegen, ob und wie das Token verschl\u00fcsselt werden soll. <code>subject_token_type</code> <code>string</code> Ja Der Typ des Tokens, das ausgetauscht werden soll. Beispiele k\u00f6nnten sein: <code>urn:ietf:params:oauth:token-type:access_token</code>, <code>urn:ietf:params:oauth:token-type:jwt</code> oder andere spezifische URIs. <code>subject_token</code> <code>string</code> Ja Das eigentliche Token, das ausgetauscht werden soll. Dies kann ein JWT, ein Referenz-Token oder ein anderes Format sein, abh\u00e4ngig vom <code>subject_token_type</code>. <code>scope</code> <code>string</code> Optional Eine durch Leerzeichen getrennte Liste von Scopes, f\u00fcr die der Access Token ausgestellt werden soll. Wenn nicht angegeben, werden die mit dem <code>subject_token</code> und/oder Client verbundenen Standard-Scopes verwendet. <p>Beispiel Anfrage:</p> <pre><code>curl -X POST \\\n  https://as.example.com/token \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -H 'DPoP: &lt;signed_dpop_jwt&gt;' \\\n  -d 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange&amp;' \\\n  -d 'client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&amp;' \\\n  -d 'client_assertion=eyJhbGciOiJFUzI1NiIsImtpZCI6InNvbWVfa2V5X2lkIn0.eyJpc3MiOiJjbGllbnRfaWQwMDEiLCJzdWIiOiJjbGllbnRfaWQwMDEiLCJhdWQiOiJodHRwczovL2F1dGhvcml6YXRpb24uc2VydmVyLmRlL3Rva2VuIiwiZXhwIjoxNjk1NTA0NjAwLCJpYXQiOjE2OTU1MDI4MDAsImp0aSI6ImFiYzEyMzQ1NiJ9.SOME_SIGNATURE_PART_ONE.SOME_SIGNATURE_PART_TWO&amp;' \\\n  -d 'resource=https%3A%2F%2Fapi.example.com%2F/resource&amp;' \\\n  -d 'subject_token_type=urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Ajwt&amp;' \\\n  -d 'subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6InNvbWVfc3ViamVjdF9rZXlfaWQifQ.eyJpc3MiOiJzb21lX3N1YmplY3RfYXV0aG9yaXR5Iiwic3ViIjoiMTIzNDU2Nzg5MCIsImF1ZCI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi5zZXJ2ZXIuZGUvdG9rZW4iLCJleHAiOjE2OTU1MDI4NjAsImlhdCI6MTY5NTUwMjgwMH0.SM(C)-B_SIGNATURE&amp;' \\\n  -d 'scope=resource.read%20resource.write'\n</code></pre>"},{"location":"zeta/docs/api/v1/#antworten_4","title":"Antworten","text":"<p>Antworten werden als JSON-Objekte mit dem <code>Content-Type: application/json</code> im Erfolgsfall und <code>application/problem+json</code> im Fehlerfall zur\u00fcckgegeben. Fehlerantworten folgen dem \"Problem Details for HTTP APIs\"-Standard (RFC 9457).</p> <p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt das Access Token und andere Metadaten zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"access_token\": \"eyJhbGciOiJFUzI1NiIsImtpZCI6InRva2VuX2tleV9pZCJ9.eyJpc3MiOiJhdXRoLnNlcnZlci5kZSIsImV4cCI6MTY5NTUwMjgwMCwiYXVkIjpbInJlc291cmNlLnNlcnZlci5kZSJdLCJzdWIiOiIxMjM0NTY3ODkwIiwiY2xpZW50X2lkIjoiZXhhbXBsZV9jbGllbnRfaWQiLCJpYXQiOjE2OTU1MDI4MDAsImp0aSI6ImV4YW1wbGVfamRpX3ZhbHVlIiwic2NvcGUiOiJyZXNvdXJjZS5yZWFkIHJlc291cmNlLndyaXRlIiwiY25mIjp7ImprdCI6ImV4YW1wbGVfamt0X2hhc2gifX0.NEW_SIGNATURE_PLACEHOLDER\",\n  \"token_type\": \"DPoP\",\n  \"expires_in\": 3600,\n  \"scope\": \"resource.read resource.write\",\n  \"refresh_token\": \"some_refresh_token_string\",\n  \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\"\n}\n</code></pre> <p>Inhalt des Access Tokens:</p> <pre><code>{\n  \"iss\": \"auth.server.de\",\n  \"exp\": 1695502800,\n  \"aud\": [\"resource.server.de\"],\n  \"sub\": \"1234567890\",\n  \"client_id\": \"my_oauth_client_id\",\n  \"iat\": 1695502800,\n  \"jti\": \"a_unique_jwt_identifier_12345\",\n  \"scope\": \"resource.read resource.write\",\n  \"cnf\": {\n    \"jkt\": \"S7uGv0kQ0g2J_2z8Y_yXm-X_yL0_yXk_Xk_yY1W_Xk\"\n  }\n}\n</code></pre> <ul> <li>400 Bad Request:</li> <li>Bedeutung: Die Anfrage war fehlerhaft, z.B. fehlende oder ung\u00fcltige Parameter.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/400\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"Invalid request parameters.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>401 Unauthorized:</li> <li>Bedeutung: Die Client-Authentifizierung ist fehlgeschlagen, z.B. ung\u00fcltige Client Assertion.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/401\",\n  \"title\": \"Unauthorized\",\n  \"status\": 401,\n  \"detail\": \"Client authentication failed.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>403 Forbidden:</li> <li>Bedeutung: Der Client ist nicht berechtigt, den Token Exchange durchzuf\u00fchren, z.B. wenn der <code>subject_token</code> nicht g\u00fcltig ist oder der Client nicht die erforderlichen Berechtigungen hat.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/403\",\n  \"title\": \"Forbidden\",\n  \"status\": 403,\n  \"detail\": \"The client is not authorized to perform this token exchange.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>429 Too Many Requests:</li> <li>Bedeutung: Der Client hat die Rate-Limits \u00fcberschritten.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/429\",\n  \"title\": \"Too Many Requests\",\n  \"status\": 429,\n  \"detail\": \"Rate limit exceeded. Please try again later.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server aufgetreten, der die Anfrage nicht verarbeiten konnte.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/token\"\n}\n</code></pre>"},{"location":"zeta/docs/api/v1/#resource-endpoint","title":"Resource Endpoint","text":"<p>Der Resource Endpoint ist der Endpunkt, der von der gesch\u00fctzten Ressource (Protected Resource) bereitgestellt wird, um auf gesch\u00fctzte Daten zuzugreifen. Er ist durch den ZETA Guard PEP vor unberechtigtem Zugriff gesch\u00fctzt. F\u00fcr den Zugriff auf die gesch\u00fctzte Ressource wird ein g\u00fcltiges Access Token und ein g\u00fcltiges DPoP Proof ben\u00f6tigt. Zus\u00e4tzlich kann eine Anwendung ein g\u00fcltiges PoPP Proof erfordern.</p> <p>Der Resource Endpoint unterst\u00fctzt neben TLS eine zus\u00e4tzliche Verschl\u00fcsselungsschicht ZETA/ASL (ZETA/Additional Security Layer). Im Well-Known JSON Dokument der gesch\u00fctzten Ressource wird angegeben, ob der Endpunkt ZETA/ASL unterst\u00fctzt. Der ZETA/ASL Kanal wird nach dem TLS Verbindungsaufbau aufgebaut und verwendet, um die Kommunikation zwischen Client und Resource Endpoint zu sichern.</p>"},{"location":"zeta/docs/api/v1/#anfragen_4","title":"Anfragen","text":"<p>Der ZETA Guard PEP empf\u00e4ngt die Anfragen und pr\u00fcft das Access Token im Authentication Header sowie das DPoP Proof im DPoP Header.</p> <p>HTTP Methode: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>).</p> <p>Pfad: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>/api/resource</code>).</p> <p>Content-Type: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>application/json</code>).</p>"},{"location":"zeta/docs/api/v1/#antworten_5","title":"Antworten","text":"<p>Die Antwort des Resource Endpoints h\u00e4ngt von der gesch\u00fctzten Ressource ab und kann verschiedene Statuscodes und Datenformate zur\u00fcckgeben.</p>"},{"location":"zeta/docs/api/v1/#konnektorti-gateway-endpunkte","title":"Konnektor/TI-Gateway Endpunkte","text":"<p>Die Endpunkte im Konnektor oder im Highspeed Konnektoren des TI-Gateways werden f\u00fcr die Erstellung von Signaturen mit Der SM(C)-B sowie f\u00fcr die Abfrage des SM(C)-B Zertifikats w\u00e4hrend der Authentifizierung am ZETA Guard verwendet.</p> <p>Hinweis: Perspektivisch ist vorgesehen, dass der Zugriff auf das TI-Gateway \u00fcber den ZETA Guard erfolgt, um die Sicherheit und Integrit\u00e4t der Kommunikation zu gew\u00e4hrleisten. W\u00e4hrend der Authentifizierung wird anstatt der SM(C)-B Identit\u00e4t eine TI-Gateway Identit\u00e4t verwendet.</p>"},{"location":"zeta/docs/api/v1/#readcardcertificate","title":"ReadCardCertificate","text":"<p>Die Operation ReadCardCertificate ist in der Konnektor Spezifikation definiert.</p>"},{"location":"zeta/docs/api/v1/#externalauthenticate","title":"ExternalAuthenticate","text":"<p>Die Operation ExternalAuthenticate ist in der Konnektor Spezifikation definiert.</p>"},{"location":"zeta/docs/api/v1/#zeta-attestation-service-endpunkte","title":"ZETA Attestation Service Endpunkte","text":"<p>Der <code>ZetaAttestationService</code> stellt einen gRPC-Dienst zur Verf\u00fcgung, der es station\u00e4ren Clients (Prim\u00e4rsystem) erm\u00f6glicht, TPM-signierte Attestierungsinformationen f\u00fcr den Client abzurufen. Diese Informationen basieren auf Integrit\u00e4tsmessungen, die in ausgew\u00e4hlten Platform Configuration Registers (PCRs) des Trusted Platform Module (TPM) gespeichert sind. Der ZETA Guard Authorization Server verwendet diese Attestierungsdaten, um die Integrit\u00e4t und Authentizit\u00e4t der Softwareumgebung des Clients zu verifizieren, bevor Zugriff auf gesch\u00fctzte Ressourcen gew\u00e4hrt wird.</p> <p>Der ZETA Attestation Service wird vom Hersteller des station\u00e4ren Clients bereitgestellt und es muss eine Vertrauensbeziehung zwischen station\u00e4ren Client und ZETA Attestation Service bestehen, um zu gew\u00e4hrleisten, dass die Attestation \u00fcber die vorgesehenen Software-Komponenten erfolgt.</p> <p>Hinweis: W\u00e4hrend der Installation oder bei Updates des station\u00e4ren Clients muss auch ein Update des ZETA Attestation Service erfolgen um eine neue Baseline f\u00fcr die Integrit\u00e4t des station\u00e4ren Clients zu setzen. Die Baseline besteht aus einem Hash \u00fcber alle unver\u00e4nderlichen Komponenten des station\u00e4ren Clients, inkl. ZETA Attestation Service.</p> <p>Hinweis: Der ZETA Attestation Service muss bei jedem Start des Clients die Messung \u00fcber die Integrit\u00e4t des Clients durchf\u00fchren und in das PCR schreiben.</p> <p>Hinweis: Der ZETA Attestation Service ist nicht f\u00fcr mobile Clients vorgesehen. Mobile Clients verwenden eine andere Attestierungsmethode, die auf den jeweiligen Plattformen basiert (z.B. Android SafetyNet, iOS DeviceCheck).</p> <p>Hinweis: TODO Umgang mit Messung des Clients weicht von Baseline ab; empfohlenes Verhalten f\u00fcr Client und ZetaAttestationService (z. B. automatisch Support informieren)</p>"},{"location":"zeta/docs/api/v1/#dienstdefinition","title":"Dienstdefinition","text":"<ul> <li>Service Name: <code>zeta.attestation.service.v1.ZetaAttestationService</code></li> <li>Proto Buffer Spezifikation: zeta-attestation-service.proto</li> </ul>"},{"location":"zeta/docs/api/v1/#rpc-methoden","title":"RPC Methoden","text":""},{"location":"zeta/docs/api/v1/#getattestation","title":"GetAttestation","text":"<p>Diese RPC-Methode erm\u00f6glicht es Clients, eine signierte Attestierungs-Quote vom TPM des Systems anzufordern, die spezifische PCR-Werte und eine vom Client bereitgestellte Challenge enth\u00e4lt.</p>"},{"location":"zeta/docs/api/v1/#request-nachricht-getattestationrequest","title":"Request-Nachricht: <code>GetAttestationRequest</code>","text":"<p>Die <code>GetAttestationRequest</code>-Nachricht enth\u00e4lt die Parameter, die f\u00fcr die Anforderung einer Attestierung ben\u00f6tigt werden.</p> Feld Typ Erforderlich Beschreibung <code>attestation_challenge</code> <code>bytes</code> Ja Ein SHA-256 Hashwert, berechnet aus der Verkettung des SHA-256 Fingerabdrucks des Public Client Instance Keys und einer Nonce vom ZETA Guard Authorization Server. Dient zur Verhinderung von Replay-Angriffen und zur Korrelation. <code>pcr_indices</code> <code>repeated uint32</code> Ja Eine Liste von TPM PCR-Indizes, deren aktuelle Werte in die Attestierungs-Quote aufgenommen und zur\u00fcckgegeben werden sollen. <p>Berechnung der <code>attestation_challenge</code>: Der Client ist f\u00fcr die korrekte Berechnung dieses Wertes verantwortlich.</p> <pre><code>data_to_hash = sha256_thumbprint_of_public_client_instance_key_bytes || nonce_from_zeta_guard_bytes\nattestation_challenge = SHA-256(data_to_hash)\n</code></pre> <p>Beispiel (Python) f\u00fcr die Berechnung der <code>attestation_challenge</code>:</p> <pre><code>import hashlib\n\n# Beispielwerte\nthumbprint_hex = \"9f3d4f2a6c5e4e21d84c8a713d3c37cfb1a2f3a4b14ad9d8d8d9c0e7c8e7e6f5\" # SHA-256 Fingerabdruck\nnonce_hex = \"a1b2c3d4e5f60718293a4b5c6d7e8f90\"\n\nthumbprint_bytes = bytes.fromhex(thumbprint_hex)\nnonce_bytes = bytes.fromhex(nonce_hex)\n\ndata_to_hash = thumbprint_bytes + nonce_bytes\nattestation_challenge_bytes = hashlib.sha256(data_to_hash).digest() # als Bytes\nattestation_challenge_hex = hashlib.sha256(data_to_hash).hexdigest() # als Hex-String\n\nprint(f\"attestation_challenge (hex): {attestation_challenge_hex}\")\n# In der gRPC Anfrage wird `attestation_challenge_bytes` verwendet.\n</code></pre> <p>Empfohlene PCR-Indizes:</p> <ul> <li>PCR 4: Boot Loader Code, Digest</li> <li>PCR 5: Boot Loader Configuration, Digest</li> <li>PCR 7: Secure Boot State / Policy, Digest</li> <li>PCR 10:OS Kernel / IMA, Digest</li> <li>PCR 11: OS Components / VSM, Digest,</li> <li>PCR 22 or 23 (if available) Client Data</li> </ul>"},{"location":"zeta/docs/api/v1/#response-nachricht-getattestationresponse","title":"Response-Nachricht: <code>GetAttestationResponse</code>","text":"<p>Die <code>GetAttestationResponse</code>-Nachricht enth\u00e4lt die vom Dienst generierten Attestierungsdaten.</p> Feld Typ Beschreibung <code>attestation_quote</code> <code>bytes</code> Die rohe, signierte Attestierungs-Quote des TPMs (eine TPM2_ATTEST Struktur). Diese Quote enth\u00e4lt die angefragten PCR-Werte sowie den <code>attestation_challenge</code> Wert. Muss clientseitig geparst werden. <code>current_pcr_values</code> <code>map&lt;uint32, bytes&gt;</code> Eine Abbildung der angefragten PCR-Indizes auf ihre aktuellen, gemessenen Werte. Die L\u00e4nge der <code>bytes</code> h\u00e4ngt vom aktiven Hashing-Algorithmus der jeweiligen PCR-Bank ab (z.B. 20 Bytes f\u00fcr SHA-1, 32 Bytes f\u00fcr SHA-256). <code>status</code> <code>AttestationStatus</code> (enum) Der vom ZETA Attestation Service intern ermittelte Status der Attestierung. Gibt an, ob die Messungen erfolgreich waren und ob sie ggf. einer definierten Baseline entsprechen. <code>status_message</code> <code>string</code> (optional) Eine menschenlesbare Beschreibung des Attestierungsstatus oder zus\u00e4tzliche Informationen, insbesondere im Fehlerfall oder bei einem <code>BASELINE_MISMATCH</code>. <code>timestamp</code> <code>google.protobuf.Timestamp</code> (optional) Der Zeitstempel der Erstellung der Attestierungs-Quote durch den ZETA Attestation Service. Erfordert <code>import \"google/protobuf/timestamp.proto\";</code>. <code>event_log</code> <code>bytes</code> (optional) Das TPM-Event-Log im plattformspezifischen Format (z.B. TCG PC Client Platform Firmware Profile Specification). Dieses Log detailliert die Sequenz der Erweiterungen der PCRs und ist essentiell f\u00fcr eine vollst\u00e4ndige Validierung. <p>AttestationStatus Enum:</p> <p>Definiert die m\u00f6glichen Statuswerte f\u00fcr die Attestierung, die vom ZETA Attestation Service zur\u00fcckgegeben werden.</p> Wert Numerischer Wert Beschreibung <code>ATTESTATION_STATUS_UNSPECIFIED</code> 0 Der Status ist nicht spezifiziert oder konnte nicht ermittelt werden. Dies sollte als Fehler interpretiert werden. <code>ATTESTATION_STATUS_SUCCESS</code> 1 Die Attestierung war erfolgreich, die Quote wurde generiert und (falls eine Baseline-Pr\u00fcfung serverseitig erfolgt) die Messungen entsprechen der Baseline. <code>ATTESTATION_STATUS_BASELINE_MISMATCH</code> 2 Die Attestierung war technisch erfolgreich, aber die aktuellen PCR-Messwerte weichen von der erwarteten Baseline ab. <code>ATTESTATION_STATUS_TPM_ERROR</code> 3 Ein Fehler ist bei der Kommunikation mit dem TPM oder bei einer TPM-Operation aufgetreten (z.B. TPM nicht bereit, PCR nicht lesbar). <code>ATTESTATION_STATUS_INVALID_REQUEST</code> 4 Die Anfrageparameter waren ung\u00fcltig (z.B. <code>attestation_challenge</code> fehlt oder hat falsches Format, ung\u00fcltige oder nicht unterst\u00fctzte <code>pcr_indices</code>). <code>ATTESTATION_STATUS_INTERNAL_ERROR</code> 5 Ein interner, nicht n\u00e4her spezifizierter Fehler ist auf Serverseite aufgetreten."},{"location":"zeta/docs/api/v1/#fehlerbehandlung","title":"Fehlerbehandlung","text":"<p>Der <code>ZetaAttestationService</code> verwendet standardm\u00e4\u00dfige gRPC-Statuscodes, um das Ergebnis der Operation auf Transportebene zu kommunizieren. Diese werden erg\u00e4nzt durch den <code>status</code>-Feld in der <code>GetAttestationResponse</code> f\u00fcr anwendungsspezifische Logik. Die <code>google.rpc.Status</code> kann f\u00fcr detailliertere Fehlerinformationen verwendet werden (siehe <code>import \"google/rpc/status.proto\";</code>).</p> <p>H\u00e4ufige gRPC-Statuscodes:</p> <ul> <li><code>OK</code> (0): Die Anfrage war erfolgreich und die <code>GetAttestationResponse</code> enth\u00e4lt die Ergebnisse. Der <code>status</code>-Feld in der Response gibt den anwendungsspezifischen Erfolg oder Misserfolg an.</li> <li><code>INVALID_ARGUMENT</code> (3):</li> <li>Einer oder mehrere Parameter der Anfrage waren ung\u00fcltig.</li> <li>Beispiele: <code>attestation_challenge</code> fehlt, hat eine falsche L\u00e4nge oder ein ung\u00fcltiges Format; <code>pcr_indices</code> ist leer, enth\u00e4lt ung\u00fcltige oder nicht unterst\u00fctzte Indizes.</li> <li>Der <code>status</code> in der Response k\u00f6nnte <code>ATTESTATION_STATUS_INVALID_REQUEST</code> sein.</li> <li><code>UNAUTHENTICATED</code> (16) / <code>PERMISSION_DENIED</code> (7):</li> <li>Der anfragende Client ist nicht authentifiziert oder nicht   autorisiert, diese Anfrage zu stellen.</li> <li>Relevant, wenn Mechanismen wie mTLS oder Token-basierte   Authentifizierung verwendet werden.</li> <li><code>UNAVAILABLE</code> (14):</li> <li>Der ZETA Attestation Service kann die Attestierung derzeit nicht   durchf\u00fchren.</li> <li>Beispiele: TPM ist nicht erreichbar oder nicht funktionsf\u00e4hig;   eine erforderliche Baseline-Konfiguration ist nicht vorhanden.</li> <li>Der <code>status</code> in der Response k\u00f6nnte   <code>ATTESTATION_STATUS_TPM_ERROR</code> oder   <code>ATTESTATION_STATUS_INTERNAL_ERROR</code> sein.</li> <li><code>INTERNAL</code> (13):</li> <li>Ein unerwarteter serverseitiger Fehler ist aufgetreten, der   nicht spezifischer kategorisiert werden kann.</li> <li>Der <code>status</code> in der Response ist typischerweise   <code>ATTESTATION_STATUS_INTERNAL_ERROR</code>.</li> </ul>"},{"location":"zeta/docs/api/v1/#sicherheitsaspekte","title":"Sicherheitsaspekte","text":"<ul> <li>Transport-Sicherheit: Es wird dringend empfohlen, die Kommunikation zwischen Client und <code>ZetaAttestationService</code> mittels TLS, vorzugsweise mTLS (mutual TLS), abzusichern, um Authentizit\u00e4t, Integrit\u00e4t und Vertraulichkeit der \u00fcbertragenen Daten zu gew\u00e4hrleisten. Hinweis: Es wird empfohlen, dass der Installer des Clients und des ZetaAttestationService die Schl\u00fcssel f\u00fcr die mTLS Verbindung erzeugt und sicher speichert.</li> <li>Challenge-Response: Die <code>attestation_challenge</code> ist ein kritischer Bestandteil zur Verhinderung von Replay-Angriffen. Die <code>nonce</code> muss f\u00fcr jede Attestierungsanfrage eindeutig sein und sicher vom ZETA Guard Authorization Server generiert und an den Client \u00fcbermittelt werden.</li> <li>Event Log Validierung: Die alleinige \u00dcberpr\u00fcfung der PCR-Werte ist oft nicht ausreichend. Eine gr\u00fcndliche Validierung der Attestierung erfordert das Parsen und \u00dcberpr\u00fcfen des <code>event_log</code>, um die Kausalkette der Messungen nachzuvollziehen. Dies erfolgt im ZETA Guard Authorization Server.</li> </ul>"},{"location":"zeta/docs/api/v1/#verwaltung-von-schlusseln-und-session-daten-im-zeta-client","title":"Verwaltung von Schl\u00fcsseln und Session-Daten im ZETA Client","text":""},{"location":"zeta/docs/api/v1/#einleitung","title":"Einleitung","text":"<p>Ein ZETA Client muss verschiedene kryptografische Schl\u00fcssel und Session-Informationen verwalten, um mit einer oder mehreren ZETA Guard Instanzen sicher und persistent kommunizieren zu k\u00f6nnen. Die Speicherung und Verwaltung dieser Daten ist kritisch f\u00fcr die Sicherheit und Funktionalit\u00e4t des Clients.</p> <p>Es wird zwischen zwei Arten von Daten unterschieden:</p> <ol> <li>Globale Daten: Diese sind \u00fcbergreifend f\u00fcr die Client-Instanz und unabh\u00e4ngig von einer spezifischen ZETA Guard Instanz.</li> <li>Pro-ZETA-Guard-Instanz Daten: Diese Daten sind spezifisch f\u00fcr die Session mit einer einzelnen ZETA Guard Instanz.</li> </ol>"},{"location":"zeta/docs/api/v1/#globale-daten-client-ubergreifend","title":"Globale Daten (Client-\u00fcbergreifend)","text":"<p>Diese Daten definieren die langlebige Identit\u00e4t der Client-Anwendung selbst. Sie m\u00fcssen persistent \u00fcber alle Sessions und Neustarts der Anwendung hinweg gespeichert werden.</p> <ul> <li><code>Client Instance Key</code> (Asymmetrisches Schl\u00fcsselpaar)</li> <li>Beschreibung: Dies ist das Hauptschl\u00fcsselpaar des Clients. Der private Schl\u00fcssel wird zur Signierung der Client-Registrierung bei neuen ZETA Guard Instanzen und zur Client Assertion Authentifizierung verwendet. Der \u00f6ffentliche Schl\u00fcssel dient als eindeutiger, kryptografischer Identifikator des Clients.</li> <li>Speicheranforderung: Dieses Schl\u00fcsselpaar muss einmalig bei der ersten Initialisierung des Clients generiert und anschlie\u00dfend sicher und persistent gespeichert werden. Ein Verlust des privaten Schl\u00fcssels bedeutet, dass der Client seine Identit\u00e4t verliert und sich bei allen bereits bekannten ZETA Guard Instanzen neu registrieren muss.</li> <li>Sicherheit: Der private Schl\u00fcssel ist das wertvollste Geheimnis des Clients und darf niemals im Klartext gespeichert werden. Siehe Kapitel 1.6.4 Sicherheitsempfehlungen f\u00fcr die Schl\u00fcsselspeicherung.</li> </ul>"},{"location":"zeta/docs/api/v1/#daten-pro-zeta-guard-instanz","title":"Daten pro ZETA Guard Instanz","text":"<p>F\u00fcr jede ZETA Guard Instanz, mit der der Client eine Verbindung aufbaut, m\u00fcssen die folgenden Daten separat und zugeordnet zur jeweiligen ZETA Guard-Instanz (z.B. \u00fcber deren Basis-URL) gespeichert werden.</p> <ul> <li><code>DPoP Key</code> (Asymmetrisches Schl\u00fcsselpaar)</li> <li>Beschreibung: F\u00fcr jede aktive Session mit einer ZETA Guard Instanz wird ein eigenes, kurzlebiges Schl\u00fcsselpaar generiert. Der private Schl\u00fcssel wird verwendet, um einzelne API-Anfragen an den Guard zu signieren (<code>DPoP</code>).</li> <li>Speicheranforderung: Dieses Schl\u00fcsselpaar ist nur f\u00fcr die Dauer einer Session g\u00fcltig. Es sollte sicher gespeichert, aber nach Beendigung der Session (z.B. durch Logout oder Token-Ablauf ohne Refresh-M\u00f6glichkeit) verworfen werden.</li> <li> <p>Sicherheit: Auch dieser private Schl\u00fcssel muss f\u00fcr seine Lebensdauer sicher aufbewahrt werden.</p> </li> <li> <p><code>Access Token</code></p> </li> <li>Beschreibung: Das vom Authorization Server des ZETA Guards ausgestellte OAuth 2.0 Access Token. Es wird im <code>Authorization</code>-Header bei jeder authentifizierten API-Anfrage mitgesendet.</li> <li> <p>Speicheranforderung: Dieses Token ist kurzlebig und muss nach Ablauf erneuert werden. Es kann im Arbeitsspeicher gehalten oder persistent gespeichert werden, um nach einem Neustart der Anwendung die Session wiederaufnehmen zu k\u00f6nnen. Es besteht ein Diebstahlschutz durch die Bindung an den DPoP Schl\u00fcssel.</p> </li> <li> <p><code>Refresh Token</code></p> </li> <li>Beschreibung: Das vom Authorization Server des ZETA Guards ausgestellte OAuth 2.0 Refresh Token. Dieses Token kann verwendet werden, um ein neues Access Token zu erhalten, ohne dass der Benutzer sich erneut authentifizieren muss.</li> <li> <p>Speicheranforderung: Das Refresh Token ist langlebiger als das Access Token und stellt einen sensiblen Berechtigungsnachweis dar. Es sollte persistent und sicher gespeichert werden. Es besteht ein Diebstahlschutz durch die Bindung an den DPoP Schl\u00fcssel.</p> </li> <li> <p><code>Client ID</code></p> </li> <li>Beschreibung: Die eindeutige ID, die der ZETA Guard dem ZETA Client w\u00e4hrend des Registrierungsprozesses zugewiesen hat. Sie wird f\u00fcr die Token-Anforderung ben\u00f6tigt.</li> <li> <p>Speicheranforderung: Muss persistent gespeichert werden, solange die Registrierung beim ZETA Guard g\u00fcltig sein soll.</p> </li> <li> <p>Discovery-Dokument Daten (Well-Known)</p> </li> <li>Beschreibung: Die Endpunkt-URLs und Konfigurationsdaten aus den Discovery-Dokumenten des ZETA Guards.</li> <li>Speicheranforderung: Es wird dringend empfohlen, diese Daten zu cachen, um wiederholte Discovery-Anfragen zu vermeiden. Der Cache sollte eine angemessene Lebensdauer haben (z.B. 24 Stunden), um auf Konfigurations\u00e4nderungen am Guard reagieren zu k\u00f6nnen.</li> </ul>"},{"location":"zeta/docs/api/v1/#konzeptionelles-speicherlayout","title":"Konzeptionelles Speicherlayout","text":"<p>Ein ZETA Client k\u00f6nnte die Daten konzeptionell wie folgt strukturieren:</p> <pre><code>{\n  \"client_instance_private_key\": \"gesch\u00fctzter_speicher_ref\",\n  \"guard_sessions\": {\n    \"https://guard1.example.com\": {\n      \"client_id\": \"client-id-beim-zeta-guard-1\",\n      \"session_private_key\": \"gesch\u00fctzter_speicher_ref\",\n      \"access_token\": \"ey...\",\n      \"refresh_token\": \"def...\",\n      \"discovery_cache\": {\n        \"expires_at\": \"2024-12-01T10:00:00Z\",\n        \"data\": {\n          \"token_endpoint\": \"...\",\n          \"jwks_uri\": \"...\"\n        }\n      }\n    },\n    \"https://guard2.another-provider.de\": {\n      \"client_id\": \"client-id-beim-zeta-guard-2\",\n      \"session_private_key\": \"...\",\n      \"access_token\": \"...\",\n      \"refresh_token\": null,\n      \"discovery_cache\": { ... }\n    }\n  }\n}\n</code></pre>"},{"location":"zeta/docs/api/v1/#sicherheitsempfehlungen-fur-die-schlusselspeicherung","title":"Sicherheitsempfehlungen f\u00fcr die Schl\u00fcsselspeicherung","text":"<p>Private Schl\u00fcssel (<code>Client Instance Key</code>, <code>DPoP Key</code>) sind hochsensible Daten. Ihre Kompromittierung erm\u00f6glicht es einem Angreifer, die Identit\u00e4t des Clients zu missbrauchen. Sie m\u00fcssen daher mit den sichersten, vom jeweiligen Betriebssystem bereitgestellten Mitteln gesch\u00fctzt werden.</p> <p>Grundprinzip: Speichern Sie private Schl\u00fcssel niemals unverschl\u00fcsselt im Dateisystem oder in einer Klartext-Konfigurationsdatei.</p> <p>Nutzen Sie stattdessen plattformspezifische, sichere Speicherorte (sog. \"Keystores\" oder \"Secret Vaults\"), die die Schl\u00fcssel an das Benutzerkonto oder die Maschinenidentit\u00e4t binden.</p> <ul> <li>Microsoft Windows:</li> <li>Empfehlung: Verwenden Sie die Data Protection API (DPAPI), die \u00fcber die Funktionen <code>CryptProtectData</code> und <code>CryptUnprotectData</code> zug\u00e4nglich ist.</li> <li> <p>Funktionsweise: DPAPI verschl\u00fcsselt Daten mithilfe eines Schl\u00fcssels, der aus den Anmeldeinformationen des Benutzers abgeleitet wird. Die Daten k\u00f6nnen somit nur von demselben Benutzer auf demselben Computer wieder entschl\u00fcsselt werden. Dies ist ideal f\u00fcr Desktop-Anwendungen. F\u00fcr Dienste, die unter einem Systemkonto laufen, kann der Schutz an die Maschinenidentit\u00e4t gebunden werden.</p> </li> <li> <p>Apple macOS:</p> </li> <li>Empfehlung: Nutzen Sie den macOS Keychain (Schl\u00fcsselbund).</li> <li> <p>Funktionsweise: Der Schl\u00fcsselbund ist ein zentraler, verschl\u00fcsselter Speicher f\u00fcr Passw\u00f6rter, Zertifikate und Schl\u00fcssel. Der Zugriff wird vom Betriebssystem streng kontrolliert und erfordert in der Regel die Zustimmung des Benutzers. Verwenden Sie die <code>Security</code> Framework-APIs, um Schl\u00fcssel sicher zu speichern und abzurufen.</p> </li> <li> <p>Linux:</p> </li> <li>Empfehlung (Desktop-Umgebungen): Verwenden Sie den Secret Service DBus API, der von Diensten wie dem GNOME Keyring oder KWallet implementiert wird. Dies ist der Freedesktop.org-Standard und die bevorzugte Methode f\u00fcr Desktop-Anwendungen.</li> <li>Empfehlung (Server/Headless-Umgebungen):         1. Dateibasierte Verschl\u00fcsselung: Speichern Sie den Schl\u00fcssel in einer Datei, die mit einem Master-Passwort verschl\u00fcsselt ist (das z.B. beim Start der Anwendung abgefragt wird).         2. Strikte Dateiberechtigungen: Als absolutes Minimum muss die Schl\u00fcsseldatei durch strikte Dateisystemberechtigungen gesch\u00fctzt werden. Der private Schl\u00fcssel sollte nur f\u00fcr den Benutzer lesbar sein, unter dem die Anwendung l\u00e4uft.             <pre><code># Setzt die Berechtigung, sodass nur der Eigent\u00fcmer lesen und schreiben darf\nchmod 600 /pfad/zum/privaten_schluessel.key\n</code></pre>         Diese Methode bietet jedoch keinen Schutz, wenn ein Angreifer Lesezugriff auf das Dateisystem als der betreffende Benutzer erlangt. Sie sollte m\u00f6glichst mit zus\u00e4tzlicher Verschl\u00fcsselung kombiniert werden.</li> </ul> <p>Cross-Plattform-Bibliotheken: F\u00fcr in h\u00f6heren Programmiersprachen (z.B. Python, Go, Rust, C#) entwickelte Clients existieren oft Bibliotheken, die die plattformspezifischen Speicher abstrahieren und eine einheitliche API f\u00fcr den Zugriff auf den Windows DPAPI, den macOS Keychain und den Secret Service unter Linux bieten. Die Verwendung solcher Bibliotheken wird empfohlen.</p>"},{"location":"zeta/docs/api/v1/#versionierung","title":"Versionierung","text":"<p>Um eine stabile und vorhersagbare Entwicklungsumgebung f\u00fcr Client-Anwendungen zu gew\u00e4hrleisten, folgt die ZETA API strikt den Prinzipien von Semantic Versioning 2.0.0 (SemVer). Jede \u00c4nderung an der API wird klassifiziert, um die Auswirkungen auf bestehende Clients transparent zu machen.</p>"},{"location":"zeta/docs/api/v1/#versionierungsschema-majorminorpatch","title":"Versionierungsschema: MAJOR.MINOR.PATCH","text":"<p>Jede ZETA Guard Instanz deklariert ihre API-Version im Format <code>MAJOR.MINOR.PATCH</code> (z.B. <code>1.2.3</code>). Die Bedeutung der einzelnen Komponenten ist wie folgt definiert:</p> <ul> <li>MAJOR-Version (z.B. <code>1</code>.2.3): Wird erh\u00f6ht, wenn r\u00fcckw\u00e4rtsinkompatible (\"breaking\") \u00c4nderungen an der API vorgenommen werden. Dies erfordert eine Anpassung aufseiten des Clients, um weiterhin korrekt zu funktionieren.</li> <li> <p>Beispiele: Entfernen eines Endpunkts, Umbenennung eines JSON-Feldes, \u00c4nderung eines Felddatentyps, Hinzuf\u00fcgen eines verpflichtenden Request-Parameters.</p> </li> <li> <p>MINOR-Version (z.B. 1.<code>2</code>.3): Wird erh\u00f6ht, wenn neue Funktionalit\u00e4t in einer r\u00fcckw\u00e4rtskompatiblen Weise hinzugef\u00fcgt wird. Bestehende Clients d\u00fcrfen durch diese \u00c4nderungen nicht beeintr\u00e4chtigt werden.</p> </li> <li> <p>Beispiele: Hinzuf\u00fcgen eines neuen API-Endpunkts, Hinzuf\u00fcgen eines neuen, optionalen Feldes in einer JSON-Antwort, Hinzuf\u00fcgen eines neuen, optionalen Request-Parameters.</p> </li> <li> <p>PATCH-Version (z.B. 1.2.<code>3</code>): Wird erh\u00f6ht, wenn r\u00fcckw\u00e4rtskompatible Fehlerbehebungen (\"bug fixes\") vorgenommen werden, die das Verhalten der API korrigieren, aber keine neue Funktionalit\u00e4t einf\u00fchren.</p> </li> <li>Beispiele: Korrektur einer fehlerhaften Validierungslogik, Behebung eines internen Fehlers, der zu einem <code>500 Internal Server Error</code> f\u00fchrte.</li> </ul> <p>Zus\u00e4tzlich k\u00f6nnen Prerelease-Tags verwendet werden (z.B. <code>2.0.0-beta.1</code>), um instabile Vorabversionen zu kennzeichnen.</p>"},{"location":"zeta/docs/api/v1/#implementierung-der-versionierung","title":"Implementierung der Versionierung","text":"<p>Die Versionierung wird durch eine Kombination aus URL-Pfad, HTTP-Headern und dem Discovery-Dokument umgesetzt.</p>"},{"location":"zeta/docs/api/v1/#1-url-pfad-fur-die-major-version","title":"1. URL-Pfad f\u00fcr die MAJOR-Version","text":"<p>R\u00fcckw\u00e4rtsinkompatible \u00c4nderungen sind am einschneidendsten. Daher wird die MAJOR-Version direkt und explizit im URL-Pfad der API gef\u00fchrt.</p> <ul> <li>Schema: <code>https://&lt;guard-base-url&gt;/zeta/v{major-version}/&lt;endpoint&gt;</code></li> <li>Beispiel f\u00fcr Version <code>1.4.2</code>: <code>POST https://guard.example.com/zeta/v1/token</code></li> <li>Beispiel f\u00fcr Version <code>2.0.0</code>: <code>POST https://guard.example.com/zeta/v2/token</code></li> </ul>"},{"location":"zeta/docs/api/v1/#2-discovery-dokument-als-source-of-truth","title":"2. Discovery-Dokument als \"Source of Truth\"","text":"<p>Die Discovery-Dokumente (<code>/.well-known/oauth-protected-resource</code> und <code>/.well-known/oauth-authorization-server</code>) sind die zentrale Anlaufstelle f\u00fcr einen Client, um die exakten, vom ZETA Guard unterst\u00fctzten Versionen zu ermitteln.</p> <ul> <li><code>api_versions_supported</code>: Dieses JSON-Objekt listet alle vom ZETA Guard angebotenen MAJOR-Versionen mit ihrer jeweiligen vollen SemVer-Version auf.</li> </ul> <pre><code>// Beispiel-Ausschnitt aus /.well-known/...\n{\n  \"issuer\": \"https://zeta-guard.example.com\",\n  // ... andere Endpunkte\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\", // Die volle, stabile SemVer-Version f\u00fcr v1\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://gematik.github.io/ZETA/v1/\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\", // Eine instabile Vorabversion f\u00fcr v2\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://gematik.github.io/ZETA/v2/\"\n    }\n  ]\n}\n</code></pre>"},{"location":"zeta/docs/api/v1/#3-http-header-zur-laufzeit-identifikation","title":"3. HTTP-Header zur Laufzeit-Identifikation","text":"<p>Jede Antwort des ZETA Guards enth\u00e4lt einen <code>ZETA-API-Version</code>-Header, der die exakte SemVer-Version der ausf\u00fchrenden Instanz angibt. Dies ist besonders f\u00fcr Debugging und Logging wertvoll.</p> <ul> <li>Beispiel-Response-Header: <code>HTTP/1.1 200 OK</code> <code>Content-Type: application/json</code> <code>ZETA-API-Version: 1.4.2</code></li> </ul>"},{"location":"zeta/docs/api/v1/#client-verhalten-und-kompatibilitatsregeln","title":"Client-Verhalten und Kompatibilit\u00e4tsregeln","text":"<p>Um die Stabilit\u00e4t zu gew\u00e4hrleisten, m\u00fcssen Clients die folgenden Regeln befolgen:</p> <ol> <li> <p>Toleranz gegen\u00fcber MINOR- und PATCH-Versionen: Ein Client, der f\u00fcr eine bestimmte API-Version entwickelt wurde (z.B. <code>1.2.0</code>), muss nahtlos mit jeder neueren, r\u00fcckw\u00e4rtskompatiblen Version derselben MAJOR-Version (z.B. <code>1.3.0</code> oder <code>1.2.1</code>) funktionieren. Dies bedeutet konkret:</p> <ul> <li>Unbekannte Felder ignorieren: Der Client-Parser muss unbekannte Felder in JSON-Antworten ignorieren und darf keinen Fehler ausl\u00f6sen.</li> <li>Reihenfolgeunabh\u00e4ngigkeit: Der Client darf sich nicht auf die Reihenfolge von Feldern in JSON-Objekten verlassen.</li> </ul> </li> <li> <p>Explizite Wahl der MAJOR-Version: Der Client w\u00e4hlt die MAJOR-Version aktiv \u00fcber den verwendeten URL-Pfad (z.B. <code>/v1/</code>). Ein Wechsel zu einer neuen MAJOR-Version (z.B. auf <code>/v2/</code>) ist eine bewusste Entwicklungsentscheidung und erfordert eine Code-Anpassung.</p> </li> </ol>"},{"location":"zeta/docs/api/v1/#deprecation-policy-auerbetriebnahme","title":"Deprecation Policy (Au\u00dferbetriebnahme)","text":"<p>Wenn eine neue MAJOR-Version (z.B. <code>v2</code>) den Status <code>stable</code> erreicht, wird die vorherige MAJOR-Version (<code>v1</code>) als <code>deprecated</code> (veraltet) markiert.</p> <ol> <li>Ank\u00fcndigungsphase: Die veraltete Version wird im Discovery-Dokument als <code>deprecated</code> gekennzeichnet. Anfragen an diese Version k\u00f6nnen einen <code>Warning</code>-HTTP-Header zur\u00fcckgeben, der auf die bevorstehende Abschaltung hinweist.</li> <li>Migrationszeitraum: Es wird einen klar kommunizierten Zeitraum geben, in dem beide MAJOR-Versionen parallel betrieben werden, um Clients eine reibungslose Migration zu erm\u00f6glichen. Zus\u00e4tzlich wird \u00fcberwacht, welche ZETA Client-Versionen aktiv sind, um die Migration zu unterst\u00fctzen.</li> <li>Abschaltung: Nach Ablauf des Migrationszeitraums und wenn die \u00dcberwachung der ZETA Clients ergeben hat, dass keine veralteten Clients mehr aktiv genutzt werden, wird die veraltete Version abgeschaltet. Anfragen an die Endpunkte dieser Version f\u00fchren dann zu einem <code>HTTP 410 Gone</code>-Fehler.</li> </ol>"},{"location":"zeta/docs/api/v1/#performance-und-lastannahmen","title":"Performance- und Lastannahmen","text":"<p>Informationen zu den erwarteten Leistungs- und Lastannahmen f\u00fcr die ZETA API werden nachgereicht.</p> <ul> <li>SM(C)-B Signaturerstellung</li> <li>TPM Attestation</li> <li>ZETA Guard Clientregistrierung</li> <li>ZETA Guard Authentifizierung</li> <li>ZETA Guard Refresh Token Exchange</li> <li>ZETA Guard PEP</li> </ul>"},{"location":"zeta/docs/api/v1/#rate-limits-und-einschrankungen","title":"Rate Limits und Einschr\u00e4nkungen","text":"<p>Der OAuth Protected Resource Well-Known Endpoint ist so konfiguriert, dass er eine Rate-Limiting-Strategie implementiert. Der ZETA Client muss die Rate Limits beachten, um eine \u00dcberlastung des Endpunkts zu vermeiden. Die genauen Limits k\u00f6nnen je nach Implementierung variieren, aber typischerweise gelten folgende Richtlinien:</p> <ul> <li>X-RateLimit-Limit</li> <li>X-RateLimit-Remaining</li> <li>X-RateLimit-Reset</li> </ul> <p>oder:</p> <ul> <li>RateLimit-Policy</li> <li>RateLimit</li> </ul> <p>Beispiele: Draft RFC f\u00fcr Rate Limits</p>"},{"location":"zeta/docs/api/v1/#support-und-kontaktinformationen","title":"Support und Kontaktinformationen","text":"<p>Hilfe: Informationen dar\u00fcber, wo und wie Benutzer Unterst\u00fctzung erhalten k\u00f6nnen (z.B. Forum, E-Mail-Support). Fehlerberichterstattung: Wie k\u00f6nnen Nutzer Bugs melden oder Feature-Anfragen stellen?</p>"},{"location":"zeta/docs/zeta-guard/","title":"ZETA Guard v1","text":"<p>ZETA Guard ist die zentrale Komponente von ZETA, die als Policy Enforcement Point (PEP) und Policy Decision Point (PDP) fungiert. ZETA Guard ist verantwortlich f\u00fcr die Durchsetzung von Sicherheitsrichtlinien und die Entscheidung \u00fcber Zugriffsanfragen auf gesch\u00fctzte Resource Server. ZETA Guard bietet eine RESTful API, die es ZETA Clients erm\u00f6glicht, sich zu registrieren, zu authentifizieren und Autorisierungsanfragen zu stellen. Die API ist so gestaltet, dass sie eine einfache Integration in bestehende Systeme erm\u00f6glicht und gleichzeitig die Sicherheitsanforderungen des Zero Trust Modells erf\u00fcllt.</p>"}]}