{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TI 2.0 Prim\u00e4rsystem Implementierungsleitfaden","text":"<p>Diese Dokumentation beschreibt den Implementierungsleitfaden f\u00fcr Prim\u00e4rsysteme in der TI 2.0. Sie richtet sich an Entwickler, Integratoren und Administratoren, die TI 2.0 Anwendungen in ihre Systeme integrieren oder verwalten m\u00f6chten.</p>"},{"location":"branch-modell/","title":"Branch Modell","text":"<p>Im ZETA GitHub Repository werden Branches verwendet um den Status der Weiterentwicklung und das Review von \u00c4nderungen abzubilden.</p> <p>Folgende Branches werden verwendet:</p> <ul> <li>main (enth\u00e4lt den letzten freigegebenen Stand der Entwicklung; besteht permanent)</li> <li>develop (enth\u00e4lt den Stand der fertig entwickelten Features und wird zum Review durch Industriepartner und Gesellschafter verwendet; basiert auf main; nach Freigabe erfolgt ein merge in main und ein Release wird erzeugt; besteht permanent)</li> <li>feature/name (in feature branches werden neue Features entwickelt; basiert auf develop; nach Fertigstellung erfolgt ein merge in develop; wird nach dem merge gel\u00f6scht)</li> <li>hotfix/name (in hotfix branches werden Hotfixes entwickelt; basiert auf main; nach Fertigstellung erfolgt ein merge in develop und in main; wird nach dem merge gel\u00f6scht)</li> <li>concept/name (in concept branches werden neue Konzepte entwickelt; basiert auf develop; dient der Abstimmung mit Dritten; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> <li>misc/name (nur f\u00fcr internen Gebrauch der gematik; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> </ul>"},{"location":"license/","title":"License","text":"<p>Copyright (c) 2022 gematik GmbH</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"api/zeta-api-versionen/","title":"ZETA API Versionen","text":"<ul> <li>ZETA API v1</li> </ul>"},{"location":"api/v1/","title":"ZETA API v1","text":"<p>Die ZETA API erm\u00f6glicht es ZETA Clients, auf gesch\u00fctzte Ressourcen zuzugreifen und dabei Sicherheits- und Authentifizierungsmechanismen zu nutzen. Der ZETA Client nutzt Endpunkte des ZETA Guard f\u00fcr die Client-Registrierung, Authentifizierung und Autorisierung.</p> <p>Station\u00e4re Clients verwenden bei der Authentifizierung Endpunkte des Konnektors/TI-Gateways und des ZETA Attestation Service.</p> <p>Mobile Clients verwenden Endpunkte der betriebssystem-spezifischen Attestierung. Die Authentifizierung erfolgt mit OpenID Connect (OIDC) und der ZETA Guard API.</p> <p>Die ZETA API ist so konzipiert, dass sie eine sichere und flexible Interaktion zwischen ZETA Clients und gesch\u00fctzten Ressourcen erm\u00f6glicht. ZETA basiert auf den Standards des OAuth 2.0 Frameworks und erweitert es um spezifische Anforderungen der gematik.</p>"},{"location":"api/v1/#voraussetzungen-fur-die-zeta-client-nutzung","title":"Voraussetzungen f\u00fcr die ZETA Client Nutzung","text":"<p>Folgende Voraussetzungen m\u00fcssen f\u00fcr die Nutzung des ZETA Clients erf\u00fcllt sein:</p> <ul> <li>Der FQDN des Resource Servers wird vom ZETA Client ben\u00f6tigt, um die ZETA Guard API zu erreichen.</li> <li>Die roots.json Datei wird vom ZETA Client ben\u00f6tigt, um die Trust Chain zu validieren. Diese Datei muss w\u00f6chentlich aktualisiert werden.</li> </ul> <p>Zus\u00e4tzlich gibt es anwendungsspezifische Voraussetzungen, die f\u00fcr die Nutzung der ZETA Guard API erforderlich sind.</p> <ul> <li>VSDM2: F\u00fcr VSDM2 Requests wird ein PoPP (Proof of Patient Presence) Token ben\u00f6tigt. Das PoPP Token muss im Header PoPP an den ZETA Client \u00fcbergeben werden.</li> </ul>"},{"location":"api/v1/#ablauf","title":"Ablauf","text":"<p>Abh\u00e4ngig vom Zustand des ZETA Clients m\u00fcssen verschiedene Teilabl\u00e4ufe ausgef\u00fchrt werden, oder k\u00f6nnen \u00fcbersprungen werden. Die ZETA API besteht aus mehreren Endpunkten, die verschiedene Funktionen bereitstellen. Diese Endpunkte sind in verschiedene Unter-Abl\u00e4ufe aufgeteilt:</p> <ul> <li>Konfiguration und Discovery: Der ZETA Client muss die Konfiguration des ZETA Guards ermitteln, um die richtigen Endpunkte zu erreichen.</li> <li>Client-Registrierung: Jeder ZETA Client muss sich einmalig beim ZETA Guard registrieren, um eine <code>client_id</code> zu erhalten und seinen \u00f6ffentlichen Schl\u00fcssel zu hinterlegen.</li> <li>Authentifizierung und Autorisierung: Der Client muss sich authentifizieren und die Integrit\u00e4t seiner Plattform nachweisen. Zus\u00e4tzlich muss sich der Nutzer oder beim Prim\u00e4rsystem die Organisation authentifizieren, um ein Access Token f\u00fcr den Zugriff auf gesch\u00fctzte Ressourcen zu erhalten.</li> </ul> <p>Der Gesamtprozess beginnt damit, dass ein Nutzer auf einen Endpunkt eines Resource Servers zugreifen m\u00f6chte. Dieser Zugriff wird \u00fcber das Prim\u00e4rsystem vom ZETA Client im Auftrag des Nutzers ausgef\u00fchrt; siehe folgende Abbildung.</p> <p></p> <p>Abbildung 1: Ablauf TPM Attestation und Token Exchange \u00dcberblick</p>"},{"location":"api/v1/#konfiguration-und-discovery","title":"Konfiguration und Discovery","text":"<p>In dieser Phase ermittelt der ZETA Client die notwendigen Endpunkte und Konfigurationen von den ZETA Guard Komponenten (PEP http Proxy und PDP Authorization Server). Der Client fragt bekannte Endpunkte (<code>/.well-known/oauth-protected-resource</code> und <code>/.well-known/oauth-authorization-server</code>) ab, um die Konfiguration des Resource Servers und des Authorization Servers zu erhalten. Das folgende Bild zeigt den Ablauf.</p> <p></p> <p>Abbildung 2: Ablauf Discovery and Configuration</p>"},{"location":"api/v1/#client-registrierung","title":"Client-Registrierung","text":""},{"location":"api/v1/#stationare-clients","title":"Station\u00e4re Clients","text":"<p>Jeder ZETA Client muss sich am ZETA Guard registrieren, \u00fcber den er auf gesch\u00fctzte Ressourcen zugreifen m\u00f6chte. Dieser Prozess findet einmalig pro ZETA Guard-Instanz statt. Der gesamte Prozess ist zweistufig, um die administrative Einrichtung von der technischen Inbetriebnahme zu trennen:</p> <ul> <li>Initiale Registrierung: Der Client erzeugt ein langlebiges kryptographisches Schl\u00fcsselpaar (Client Instance Key), sendet den \u00f6ffentlichen Teil an den Authorization Server und erh\u00e4lt im Gegenzug eine <code>client_id</code>. Der Client ist danach im System bekannt, aber sein Status ist <code>pending_attestation</code>, d.h. er ist noch nicht f\u00fcr den Zugriff auf Ressourcen freigeschaltet.</li> <li>Aktivierung (Erster Token Exchange): Der Client wird aktiviert, indem er zum ersten Mal einen Token Exchange mit einer erfolgreichen Attestierung durchf\u00fchrt. Damit beweist er nicht nur den Besitz des privaten Schl\u00fcssels, sondern (bei der TPM-Attestierung) auch die Integrit\u00e4t der Plattform, auf der er l\u00e4uft. Nach erfolgreicher Pr\u00fcfung wird sein Status im ZETA Guard auf <code>active</code> gesetzt.</li> </ul> <p>Die Client Registrierung ist in der folgenden Abbildung dargestellt.</p> <p></p> <p>Abbildung 3: Ablauf Client Registrierung</p> <p>F\u00fcr die initiale Registrierung sendet der ZETA Client eine Anfrage an den Dynamic Client Registration (DCR) Endpoint. Diese Anfrage enth\u00e4lt alle notwendigen Metadaten, um den Client f\u00fcr die <code>private_key_jwt</code> Authentifizierungsmethode vorzubereiten:</p> <ul> <li><code>client_name</code>: Ein f\u00fcr Menschen lesbarer Name f\u00fcr den Client.</li> <li><code>token_endpoint_auth_method</code>: Die geplante Authentifizierungsmethode, hier <code>private_key_jwt</code>.</li> <li><code>grant_types</code>: Die erlaubten Grant Types (z.B. <code>urn:ietf:params:oauth:grant-type:token-exchange</code>, <code>refresh_token</code>).</li> <li><code>jwks</code>: Ein JSON Web Key Set, das den \u00f6ffentlichen Client Instance Key enth\u00e4lt. Dieser Schl\u00fcssel wird vom Authorization Server verwendet, um die Signatur der Client Assertions zu \u00fcberpr\u00fcfen.</li> </ul>"},{"location":"api/v1/#mobile-clients","title":"Mobile Clients","text":"<p>Hinweis: Der Prozess f\u00fcr Mobile Clients wird in zuk\u00fcnftigen Versionen der API detaillierter beschrieben, sobald die Entwicklung von ZETA Stufe 2 abgeschlossen ist.</p>"},{"location":"api/v1/#authentifizierung-und-autorisierung","title":"Authentifizierung und Autorisierung","text":"<p>Nach erfolgreicher Registrierung besitzt der ZETA Client eine <code>client_id</code> und ein zugeh\u00f6riges Schl\u00fcsselpaar. Um auf einen Fachdienst zugreifen zu k\u00f6nnen, ben\u00f6tigt der Client ein Access Token vom Authorization Server (AS). Station\u00e4re ZETA Clients verwenden daf\u00fcr den Token Exchange Flow, w\u00e4hrend mobile ZETA Clients den Authorization Code Flow mit OpenID Connect nutzen.</p>"},{"location":"api/v1/#stationare-clients_1","title":"Station\u00e4re Clients","text":"<p>Die Authentifizierung und Autorisierung f\u00fcr station\u00e4re Clients unterscheidet zwei Hauptf\u00e4lle:</p> <ol> <li>Token-Austausch mit Attestierung: Hier wird die Identit\u00e4t der Institution (mittels <code>subject_token</code> von der SM(C)-B) nachgewiesen und die Integrit\u00e4t des Clients durch eine Attestierung \u00fcberpr\u00fcft. Dieser aufw\u00e4ndigere Prozess wird zu Beginn einer neuen Session (oder zur Re-Attestierung) durchgef\u00fchrt, um sicherzustellen, dass der ZETA Client und das Prim\u00e4rsystem vertrauensw\u00fcrdig sind.</li> <li>Token-Erneuerung (Refresh Token): Hier wird ein vorhandenes Refresh Token genutzt, um ein neues Access Token zu erhalten. Dieser Prozess ist performanter und verzichtet auf eine erneute Attestierung.</li> </ol> <p>Diese Trennung schafft eine Balance zwischen h\u00f6chster Sicherheit beim initialen Zugriff und Effizienz bei der Erneuerung bestehender Sitzungen.</p> <p>Die folgende Abbildung zeigt den Ablauf des Token-Austauschs mit Client Assertion JWT Authentifizierung und DPoP.</p> <p></p> <p>Abbildung 4: Ablauf Authentifizierung und TPM-Attestation</p>"},{"location":"api/v1/#pfad-a-token-austausch-mit-attestierung","title":"Pfad A: Token-Austausch mit Attestierung","text":"<p>Dieser Pfad wird beschritten, wenn der Client keine bestehende Session (d.h. kein g\u00fcltiges Refresh Token) hat.</p> <ol> <li> <p>Vorbereitung:</p> <ul> <li>Der Client fordert eine frische, einmalig g\u00fcltige <code>nonce</code> vom Authorization Server an (<code>GET /nonce</code>).</li> <li>Der Client erzeugt ein tempor\u00e4res, nur f\u00fcr diese Session g\u00fcltiges DPoP-Schl\u00fcsselpaar.</li> </ul> </li> <li> <p>Integrit\u00e4tspr\u00fcfung und kryptografische Bindung:</p> <ul> <li>Um zu beweisen, dass die Attestierung f\u00fcr genau diesen Client und diese Transaktion erstellt wurde, erzeugt der Client eine <code>attestation_challenge</code>. Diese bindet den Zustand des TPMs an den \u00f6ffentlichen Client Instance Key und die <code>nonce</code> des AS: <code>attestation_challenge = HASH( HASH(Client_Instance_Public_Key_JWK) + nonce )</code>.</li> <li>Der Client fordert beim ZETA Attestation Service eine TPM Quote an, die diese <code>attestation_challenge</code> als <code>qualifyingData</code> enth\u00e4lt. Das TPM signiert somit eine Aussage, die mit der Identit\u00e4t des Clients verbunden ist.</li> </ul> </li> <li> <p>Erstellen des Client Statement: Die Attestierungsartefakte (TPM Quote, Event Log, Zertifikatskette) werden in eine <code>client_statement</code>-Struktur gepackt. Im Falle des Fallbacks (Software-Attestierung) enth\u00e4lt diese Struktur andere, softwarebasierte Evidenz.</p> </li> <li> <p>Erstellen der Client Assertion (mit Attestierung): F\u00fcr die Authentifizierung am Token-Endpoint erstellt der Client eine Client Assertion. Dieses JWT, mit dem privaten Client Instance Key signiert, dient als \"Umschlag\":</p> <ul> <li>Es authentifiziert den Client gegen\u00fcber dem AS (<code>iss</code> und <code>sub</code> sind die <code>client_id</code>).</li> <li>Es enth\u00e4lt die <code>client_statement</code>-Struktur als Beweis f\u00fcr die Ger\u00e4teintegrit\u00e4t, verpackt in einem spezifischen Claim (<code>urn:gematik:params:oauth:client-attestation:tpm2</code> oder <code>...:software</code>).</li> </ul> <pre><code>// Client Assertion f\u00fcr initialen Token-Austausch (Beispiel TPM)\n{\n  \"iss\": \"&lt;client_id&gt;\", \"sub\": \"&lt;client_id&gt;\",\n  \"aud\": \"&lt;AS_Token_Endpoint_URL&gt;\",\n  \"exp\": ..., \"jti\": \"...\",\n  // Kapselung des Attestierungsnachweises\n  \"urn:gematik:params:oauth:client-attestation:tpm2\": {\n     \"attestation_data\": \"&lt;Base64(client_statement)&gt;\",\n     \"client_statement_format\": \"client-statement\"\n   }\n}\n</code></pre> </li> <li> <p>Authentisierung der Institution (SM(C)-B Token): Parallel dazu erstellt der Client das <code>subject_token</code>. Dies ist ein vom ZETA Client erzeugtes JWT, dessen Hash vom Konnektor mittels der SM(C)-B signiert wird und die Identit\u00e4t der Institution (z.B. Praxis) belegt. Die Audience (<code>aud</code>) dieses Tokens ist der Ziel-Fachdienst (Resource Server).</p> </li> <li> <p>Token Request: Der Client sendet eine <code>POST</code>-Anfrage an den <code>/token</code>-Endpoint, die alle Teile kombiniert: <code>grant_type=token-exchange</code>, das <code>subject_token</code>, die <code>client_assertion</code> (mit der eingebetteten Attestierung) und den DPoP-Proof.</p> </li> <li> <p>Validierung durch den AS: Der AS f\u00fchrt eine umfassende Pr\u00fcfung durch: Validierung der Client Assertion (Signatur gegen den bei der DCR hinterlegten Public Key), des DPoP-Proofs, des Subject Tokens und insbesondere der eingebetteten Attestierung (Pr\u00fcfung der Quote, der <code>attestation_challenge</code> und der PCR-Werte gegen die Sicherheits-Policy).</p> </li> </ol>"},{"location":"api/v1/#pfad-b-token-erneuerung-via-refresh-token","title":"Pfad B: Token-Erneuerung via Refresh Token","text":"<p>Dieser effiziente Pfad wird genutzt, wenn ein g\u00fcltiges Refresh Token vorhanden ist.</p> <ol> <li> <p>Erstellen der Client Assertion (ohne Attestierung): Der Client erstellt eine einfache <code>client_assertion</code>. Sie beweist durch ihre Signatur mit dem Client Instance Key die Identit\u00e4t des Clients. Diese Assertion enth\u00e4lt keine Attestierungsdaten.</p> <pre><code>// Client Assertion f\u00fcr Refresh-Token-Nutzung\n{\n  \"iss\": \"&lt;client_id&gt;\",\n  \"sub\": \"&lt;client_id&gt;\",\n  \"aud\": \"&lt;AS_Token_Endpoint_URL&gt;\",\n  \"exp\": ..., \"jti\": \"...\"\n}\n</code></pre> </li> <li> <p>Token Request: Der Client sendet eine <code>POST</code>-Anfrage an den <code>/token</code>-Endpoint mit <code>grant_type=refresh_token</code>, dem Refresh Token und der einfachen <code>client_assertion</code>.</p> </li> <li> <p>Validierung durch den AS: Der AS validiert das Refresh Token, die Signatur der Client Assertion und den DPoP-Proof. Die Pr\u00fcfung einer TPM-Attestierung entf\u00e4llt. Bei Erfolg wird das alte Refresh Token invalidiert (Rotation).</p> </li> </ol>"},{"location":"api/v1/#gemeinsame-nachfolgende-schritte","title":"Gemeinsame nachfolgende Schritte","text":"<p>Nach erfolgreicher Validierung in einem der beiden Pfade fragt der AS bei der Policy Engine (PE) an, ob der Zugriff gew\u00e4hrt werden soll. Ist die Entscheidung positiv, stellt der AS ein neues Access Token (gebunden an den DPoP-Schl\u00fcssel) und ein neues Refresh Token aus.</p>"},{"location":"api/v1/#mobile-clients_1","title":"Mobile Clients","text":"<p>Die Authentifizierung f\u00fcr mobile Clients erfolgt mit OpenID Connect und OAuth2 Authorization Code Flow. Die Beschreibung wird erg\u00e4nzt, wenn die Entwicklung von ZETA Stufe 2 abgeschlossen ist.</p>"},{"location":"api/v1/#endpunkte","title":"Endpunkte","text":"<p>Die ZETA API besteht aus mehreren Endpunkten, die verschiedene Funktionen bereitstellen. Diese Endpunkte sind in verschiedene Kategorien unterteilt:</p> <ul> <li>ZETA Guard API Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem ZETA Guard, einschlie\u00dflich der Registrierung von Clients, der Authentifizierung und der Autorisierung.</li> <li>Konnektor/TI-Gateway Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem Konnektor/TI-Gateway, um Karteninformationen zu lesen und Authentifizierungsanfragen zu stellen.</li> <li>ZETA Attestation Service Endpunkte: Diese Endpunkte erm\u00f6glichen die Interaktion mit dem ZETA Attestation Service, um TPM-Attestierungen durchzuf\u00fchren.</li> </ul>"},{"location":"api/v1/#zeta-guard-api-endpunkte","title":"ZETA Guard API Endpunkte","text":"<p>Die ZETA Guard API Endpunkte sind f\u00fcr die Interaktion mit dem ZETA Guard zust\u00e4ndig. Sie erm\u00f6glichen die Registrierung von Clients, die Authentifizierung und Autorisierung sowie den Zugriff auf gesch\u00fctzte Ressourcen. Die ZETA Guard API Endpunkte sind \u00fcber HTTPS erreichbar und erfordern eine g\u00fcltige TLS-Verbindung. Der ZETA Client muss die folgenden Sicherheitsanforderungen erf\u00fcllen:</p> <ul> <li>ZETA Clients m\u00fcssen TLS 1.3 oder h\u00f6her unterst\u00fctzen.</li> <li>Es m\u00fcssen die TLS Anforderungen aus gemSpec_Krypt Kapitel 3.3.2 erf\u00fcllt werden.</li> </ul>"},{"location":"api/v1/#oauth-protected-resource-well-known-endpoint","title":"OAuth Protected Resource Well-Known Endpoint","text":"<p>Dieser Endpunkt bietet eine standardisierte Methode f\u00fcr OAuth Protected Resources (OPR), um ihre F\u00e4higkeiten und Konfigurationsdetails zu ver\u00f6ffentlichen (RFC 9728). Er erm\u00f6glicht es Clients, die notwendigen Informationen \u00fcber die OPR abzurufen, wie z.B. unterst\u00fctzte Schemata, Verifizierungsmethoden, Token-Introspektion-Endpunkte und unterst\u00fctzte Scopes. Der Endpunkt ist unter dem Pfad <code>/.well-known/oauth-protected-resource</code> relativ zur Basis-URL der Protected Resource erreichbar.</p>"},{"location":"api/v1/#anfragen","title":"Anfragen","text":"<p>Der Endpunkt wird \u00fcber eine einfache HTTP GET-Anfrage ohne Body aufgerufen.</p> <pre><code>GET /.well-known/oauth-protected-resource HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"api/v1/#antworten","title":"Antworten","text":"<p>Wie im obigen Abschnitt dargestellt, ist die typische erfolgreiche API-Antwort ein JSON-Objekt, das der im <code>opr-well-known.yaml</code>-Schema definierten Struktur entspricht. Der <code>Content-Type</code>-Header der Antwort ist <code>application/json</code>.</p> <p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und die Konfigurationsdaten der Protected Resource wurden als JSON-Objekt im Antwort-Body zur\u00fcckgegeben.   Eine erfolgreiche Anfrage liefert ein JSON-Objekt, das die Konfiguration der Protected Resource beschreibt. Die genauen Felder h\u00e4ngen von der Implementierung und den unterst\u00fctzten F\u00e4higkeiten der gesch\u00fctzten Resource ab.</li> <li>Beispielantwort:</li> </ul> <p>Content-Type: application/json</p> <pre><code>{\n  \"resource\": \"https://api.example.com\",\n  \"authorization_servers\": [\n    \"https://auth1.example.com\",\n    \"https://auth2.example.com\"\n  ],\n  \"jwks_uri\": \"https://api.example.com/.well-known/jwks.json\",\n  \"scopes_supported\": [\n    \"read\",\n    \"write\",\n    \"delete\"\n  ],\n  \"bearer_methods_supported\": [\n    \"header\",\n    \"body\"\n  ],\n  \"resource_signing_alg_values_supported\": [\n    \"RS256\",\n    \"ES256\"\n  ],\n  \"resource_name\": \"Example Protected API\",\n  \"resource_documentation\": \"https://docs.example.com/api\",\n  \"resource_policy_uri\": \"https://www.example.com/privacy\",\n  \"resource_tos_uri\": \"https://www.example.com/terms\",\n  \"tls_client_certificate_bound_access_tokens\": true,\n  \"authorization_details_types_supported\": [\n    \"payment_initiation\",\n    \"account_access\"\n  ],\n  \"dpop_signing_alg_values_supported\": [\n    \"ES256\",\n    \"RS512\"\n  ],\n  \"dpop_bound_access_tokens_required\": true,\n  \"signed_metadata\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJyZXNvdXJjZSI6Imh0dHBzOi8vYXBpLmV4YW1wbGUuY29tIn0.XYZ123abc456def789\",\n  \"zeta_asl_use\": \"required\",\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ]\n}\n</code></pre> <ul> <li>404 Not Found:</li> <li>Bedeutung: Der angeforderte Well-Known Endpoint konnte auf dem Server nicht gefunden werden. Dies kann daran liegen, dass die Protected Resource diesen Endpunkt nicht hostet oder falsch konfiguriert ist.</li> <li>Beispielantwort:</li> </ul> <p>Content-Type: application/problem+json</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"OAuth Protected Resource Configuration Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested OAuth Protected Resource Well-Known configuration could not be found at this path.\",\n  \"instance\": \"/.well-known/oauth-protected-resource\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server der Protected Resource aufgetreten, der die Verarbeitung der Anfrage verhindert hat.</li> <li>Beispielantwort: Ein leerer Body, ein generischer Content-Type: application/problem+json</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/.well-known/oauth-protected-resource\"\n}\n</code></pre>"},{"location":"api/v1/#authorization-server-well-known-endpoint","title":"Authorization Server Well-Known Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht Clients und anderen Parteien die einfache Entdeckung der Konfigurationsmetadaten eines ZETA Guard OAuth 2.0 Autorisierungsservers (AS) und seiner F\u00e4higkeiten. Er ist gem\u00e4\u00df RFC 8414 definiert und bietet eine standardisierte Methode, um Informationen wie Endpunkt-URIs, unterst\u00fctzte Grant Types und Scopes abzurufen.</p>"},{"location":"api/v1/#anfragen_1","title":"Anfragen","text":"<p>Dieser Endpunkt wird \u00fcber eine HTTP GET-Anfrage ohne Parameter aufgerufen.</p> <p>Methode: <code>GET</code></p> <p>Header: Ein <code>Accept</code>-Header mit <code>application/json</code> wird empfohlen, um die bevorzugte Antwortformat anzugeben.</p> <p>Beispiel Anfrage:</p> <pre><code>GET /.well-known/oauth-authorization-server HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"api/v1/#antworten_1","title":"Antworten","text":"<p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt die Konfigurationsmetadaten des Autorisierungsservers als JSON-Objekt zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"issuer\": \"https://api.example.com\",\n  \"authorization_endpoint\": \"https://api.example.com/auth\",\n  \"token_endpoint\": \"https://api.example.com/token\",\n  \"jwks_uri\": \"https://api.example.com/certs\",\n  \"response_types_supported\": [\n    \"code\",\n    \"token\"\n  ],\n  \"response_modes_supported\": [\n    \"query\",\n    \"fragment\",\n    \"form_post\"\n  ],\n  \"grant_types_supported\": [\n    \"authorization_code\",\n    \"token-exchange\",\n    \"refresh_token\"\n  ],\n  \"token_endpoint_auth_methods_supported\": [\n    \"private_key_jwt\"\n  ],\n  \"token_endpoint_auth_signing_alg_values_supported\": [\n    \"ES256\"\n  ],\n  \"service_documentation\": \"https://api.example.com/docs\",\n  \"code_challenge_methods_supported\": [\n    \"S256\"\n  ],\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ],\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\",\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\",\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v2\"\n    },\n    {\n      \"major_version\": 1,\n      \"version\": \"1.3.0\",\n      \"status\": \"deprecated\",\n      \"documentation_uri\": \"https://github.com/gematik/zeta/api/v1\"\n    }\n  ]\n}\n</code></pre> <p>404 Not Found:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn der Endpunkt unter der angefragten URL nicht gefunden werden kann.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested resource was not found on this server.\",\n  \"instance\": \"/.well-known/oauth-authorization-server\"\n}\n</code></pre> <p>500 Internal Server Error:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn ein unerwarteter Fehler auf dem Server auftritt, der die Anfrage nicht verarbeiten konnte.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/.well-known/oauth-authorization-server\"\n}\n</code></pre>"},{"location":"api/v1/#nonce-endpoint","title":"Nonce Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht Clients das Abrufen eines einmaligen kryptographischen Werts, einer \"Nonce\". Im Kontext der ZETA-Architektur dient diese Nonce prim\u00e4r dazu, eine spezifische TPM-Attestierung an eine aktuelle Transaktion zu binden, um Replay-Angriffe zu verhindern. Sie wird Teil der <code>attestation_challenge</code>, die vom TPM signiert wird.</p> <p>Beim Token Endpunkt wird ebenfalls eine Nonce ben\u00f6tigt, um die Integrit\u00e4t der Transaktion zu gew\u00e4hrleisten. Diese Nonce wird in der Client Assertion verwendet, um Replay-Angriffe zu verhindern und die Bindung zwischen der Client Authentifizierung und der Transaktion sicherzustellen.</p>"},{"location":"api/v1/#anfragen_2","title":"Anfragen","text":"<p>Beispiel Anfrage:</p> <pre><code>GET /nonce HTTP/1.1\nHost: api.example.com\nAccept: application/json\n</code></pre>"},{"location":"api/v1/#antworten_2","title":"Antworten","text":"<p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt die Nonce als JSON-Objekt zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"nonce\": \"s.fRzE3M0J_QxL-x.6gA~x\",\n  \"expires_in\": 30\n}\n</code></pre> <p>Felder der erfolgreichen Antwort:</p> <ul> <li><code>nonce</code> (String): Der generierte, einmalige kryptographische Wert.</li> <li><code>expires_in</code> (Integer): Die G\u00fcltigkeitsdauer der Nonce in Sekunden, ab dem Zeitpunkt der Ausstellung. Nach Ablauf dieser Zeit sollte die Nonce vom Server nicht mehr akzeptiert werden.</li> </ul> <p>404 Not Found:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn der Endpunkt unter der angefragten URL nicht gefunden werden kann.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/404\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"The requested resource was not found on this server.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre> <p>429 Too Many Requests:</p> <p>Dieser Fehler tritt auf, wenn der Client die vom Server festgelegten Ratenbegrenzungen \u00fcberschreitet.</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Retry-After: 60</p> <pre><code>{\n  \"type\": \"tag:authorization.example.com,2023:oauth:nonce:rate_limit_exceeded\",\n  \"title\": \"Rate Limit Exceeded\",\n  \"status\": 429,\n  \"detail\": \"You have exceeded the allowed number of nonce requests. Please try again after 60 seconds.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre> <ul> <li><code>Retry-After</code> Header (optional): Gibt an, wie viele Sekunden der Client warten sollte, bevor er eine weitere Anfrage stellt.</li> </ul> <p>500 Internal Server Error:</p> <p>Content-Type: <code>application/problem+json</code></p> <p>Dies tritt auf, wenn ein unerwarteter Fehler auf dem Server auftritt, der die Anfrage nicht verarbeiten konnte.</p> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/nonce\"\n}\n</code></pre>"},{"location":"api/v1/#dynamic-client-registration-endpoint","title":"Dynamic Client Registration Endpoint","text":"<p>Dieser Endpunkt erm\u00f6glicht die dynamische Registrierung neuer OAuth 2.0 Clients beim Authorization Server gem\u00e4\u00df RFC 7591. Der Prozess dient dazu, eine <code>client_id</code> zu erhalten und den \u00f6ffentlichen Client Instance Key zu registrieren, der f\u00fcr die <code>private_key_jwt</code> Client-Authentifizierung verwendet wird.</p> <p>Die Registrierung selbst erfordert keine Attestierung. Der Client erh\u00e4lt den Status <code>pending_attestation</code> und muss seine Integrit\u00e4t beim ersten Token Exchange beweisen, um aktiviert zu werden. Die Registrierung muss \u00fcber eine TLS-gesch\u00fctzte Verbindung erfolgen.</p> <p>Hinweis: Es fehlen noch die Operationen zur Verwaltung von bestehenden Client Registrierungen (z.B. Aktualisierung, L\u00f6schung). Diese werden in zuk\u00fcnftigen Versionen der API erg\u00e4nzt.</p>"},{"location":"api/v1/#anfragen-fur-stationare-clients","title":"Anfragen f\u00fcr station\u00e4re Clients","text":"<p>Der Client sendet eine <code>POST</code>-Anfrage an den <code>/register</code>-Endpunkt. Der Anfrage-Body ist ein JSON-Objekt, das die Metadaten des zu registrierenden Clients enth\u00e4lt.</p> <p>Beispiel Anfrage:</p> <pre><code>POST /register HTTP/1.1\nHost: api.example.com\nAccept: application/json\nContent-type: application/json\n</code></pre> <pre><code>{\n  \"client_name\": \"Praxis-PC-123\",\n  \"token_endpoint_auth_method\": \"private_key_jwt\",\n  \"grant_types\": [\n    \"urn:ietf:params:oauth:grant-type:token-exchange\",\n    \"refresh_token\"\n  ],\n  \"jwks\": {\n    \"keys\": [\n      {\n        \"kty\": \"EC\",\n        \"crv\": \"P-256\",\n        \"x\": \"...\",\n        \"y\": \"...\",\n        \"use\": \"sig\",\n        \"kid\": \"...\"\n      }\n    ]\n  },\n  \"redirect_uris\": [\n    \"https://client.example.org/cb\"\n  ]\n}\n</code></pre> <p>Erforderliche Parameter im Anfrage-Body:</p> Parameter Typ Beschreibung <code>grant_types</code> <code>array</code> Eine Liste der Grant Types, die der Client verwenden darf. <code>jwks</code> <code>object</code> Das JSON Web Key Set [RFC7517] des Clients, das den \u00f6ffentlichen Client Instance Key enth\u00e4lt. <code>token_endpoint_auth_method</code> <code>string</code> Muss <code>private_key_jwt</code> sein, um die Client-Authentifizierung mittels signierter JWTs zu erzwingen. <code>redirect_uris</code> <code>array</code> Optional f\u00fcr reine Backend-Clients, aber empfohlen. Mindestens eine URI, die f\u00fcr interaktive Flows (z.B. zuk\u00fcnftige mobile Clients) verwendet wird. <code>client_name</code> <code>string</code> Optional. Ein f\u00fcr Menschen lesbarer Name f\u00fcr den Client."},{"location":"api/v1/#antworten_3","title":"Antworten","text":"<p>Der Authorization Server antwortet mit verschiedenen HTTP-Statuscodes und entsprechenden JSON-Objekten, die entweder die erfolgreiche Registrierung oder Fehlermeldungen gem\u00e4\u00df RFC 9457 (\"Problem Details for HTTP APIs\") beschreiben.</p> <p>Statuscodes:</p> <ul> <li>201 Created:</li> <li>Bedeutung: Die Registrierung war erfolgreich. Der Server gibt die <code>client_id</code> und die registrierten Metadaten zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li> <p>Beispiel Antwort:</p> <pre><code>{\n  \"client_id\": \"1234567890abcdef\",\n  \"client_id_issued_at\": 1678886400,\n  \"grant_types\": [\n    \"urn:ietf:params:oauth:grant-type:token-exchange\",\n    \"refresh_token\"\n  ],\n  \"token_endpoint_auth_method\": \"private_key_jwt\",\n  \"client_name\": \"Praxis-PC-123\",\n  \"jwks\": {\n    \"keys\": [\n      {\n        \"kty\": \"EC\", \"crv\": \"P-256\", \"x\": \"...\", \"y\": \"...\", \"use\": \"sig\", \"kid\": \"...\"\n      }\n    ]\n  },\n   \"redirect_uris\": [\n    \"https://client.example.org/cb\"\n  ]\n}\n</code></pre> </li> <li> <p>400 Bad Request:</p> </li> <li>Bedeutung: Die Anfrage war fehlerhaft, z.B. fehlende oder ung\u00fcltige Parameter.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/400\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"Invalid request parameters.\",\n  \"instance\": \"/register\"\n}\n</code></pre> <ul> <li>409 Conflict  :</li> <li>Bedeutung: Ein Client mit dem angegebenen <code>Client_Instance_Public_Key</code> existiert bereits.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/409\",\n  \"title\": \"Conflict\",\n  \"status\": 409,\n  \"detail\": \"A client with the provided Client_Instance_Public_Key already exists.\",\n  \"instance\": \"/register\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server aufgetreten, der die Anfrage nicht verarbeiten konnte.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/register\"\n}\n</code></pre>"},{"location":"api/v1/#anfragen-fur-mobile-clients","title":"Anfragen f\u00fcr mobile Clients","text":"<p>Die Registrierung f\u00fcr mobile Clients erfolgt \u00e4hnlich wie bei station\u00e4ren Clients, jedoch mit anderen Anforderungen an die Client-Attestation, die auf den jeweiligen Plattformen basieren. Mobile Clients verwenden eine spezifische Attestierungsmethode, die auf den Betriebssystemen basiert (z.B. Android SafetyNet, iOS DeviceCheck).</p> <p>Die Beschreibung wird in Stufe 2 der ZETA API erg\u00e4nzt.</p>"},{"location":"api/v1/#token-endpoint","title":"Token Endpoint","text":"<p>Der Token Endpoint des Autorisierungsservers (AS) erm\u00f6glicht den Austausch eines Tokens gegen ein vom Authorizationserver ausgestelltes Access Token, gem\u00e4\u00df dem OAuth 2.0 Token Exchange (RFC 8693) oder die Erneuerung von Token (<code>refresh_token</code>). Der Client muss sich mit einer JWT Client Assertion gegen\u00fcber den Authorization Server authentifizieren.</p> <p>Der Endpunkt ist ein POST-Endpunkt, der Formular-kodierte Daten (<code>application/x-www-form-urlencoded</code>) im Body erwartet und JSON-Objekte im Erfolgsfall oder \"Problem Details\" im Fehlerfall zur\u00fcckgibt.</p> <p>Der Endpunkt unterst\u00fctzt verschiedene Grant Types, einschlie\u00dflich <code>authorization_code</code> (ab ZETA Stufe 2), <code>urn:ietf:params:oauth:grant-type:token-exchange</code>, <code>refresh_token</code> und <code>urn:ietf:params:oauth:grant-type:token-exchange</code>.</p>"},{"location":"api/v1/#anfragen_3","title":"Anfragen","text":"<p>Der Token Endpoint empf\u00e4ngt POST-Anfragen mit dem Content-Type <code>application/x-www-form-urlencoded</code>. Die Anfrage muss die notwendigen Parameter f\u00fcr den Token Exchange Grant Type enthalten, sowie die Client-Authentifizierung mittels JWT Bearer Client Assertion.</p> <p>HTTP Methode: <code>POST</code></p> <p>Pfad: <code>/token</code></p> <p>Content-Type: <code>application/x-www-form-urlencoded</code></p> <p>Anfrageparameter:</p> Parameter Typ Erforderlich Beschreibung <code>grant_type</code> <code>string</code> Ja Der Grant Type. F\u00fcr Token Exchange ist dies immer <code>urn:ietf:params:oauth:grant-type:token-exchange</code>. <code>client_assertion_type</code> <code>string</code> Ja Gibt den Typ der Client Assertion an. F\u00fcr JWT Bearer Client Assertion ist dies immer <code>urn:ietf:params:oauth:client-assertion-type:jwt-bearer</code>. <code>client_assertion</code> <code>string</code> Ja Die JWT, die zur Authentifizierung des Clients dient. Diese JWT muss vom Client signiert sein und folgende Claims enthalten: - <code>iss</code> (Issuer): Die Client ID.- <code>sub</code> (Subject): Die Client ID.- <code>aud</code> (Audience): Die URL des Token Endpoints.- <code>exp</code> (Expiration Time): Die Zeit, nach der die JWT ung\u00fcltig wird.- <code>jti</code> (JWT ID): Ein eindeutiger Bezeichner f\u00fcr diese JWT, um Replay-Angriffe zu verhindern.- <code>iat</code> (Issued At): Zeitpunkt der Ausstellung der JWT. <code>resource</code> <code>string</code> Ja Eine URI, die den Zieldienst oder die Zielressource angibt, f\u00fcr die der Client das angeforderte Sicherheitstoken verwenden m\u00f6chte. Dadurch kann der Autorisierungsserver die f\u00fcr das Ziel geeigneten Richtlinien anwenden, z. B. den Typ und Inhalt des auszugebenden Tokens bestimmen oder festlegen, ob und wie das Token verschl\u00fcsselt werden soll. <code>subject_token_type</code> <code>string</code> Ja Der Typ des Tokens, das ausgetauscht werden soll. Beispiele k\u00f6nnten sein: <code>urn:ietf:params:oauth:token-type:access_token</code>, <code>urn:ietf:params:oauth:token-type:jwt</code> oder andere spezifische URIs. <code>subject_token</code> <code>string</code> Ja Das eigentliche Token, das ausgetauscht werden soll. Dies kann ein JWT, ein Referenz-Token oder ein anderes Format sein, abh\u00e4ngig vom <code>subject_token_type</code>. <code>scope</code> <code>string</code> Optional Eine durch Leerzeichen getrennte Liste von Scopes, f\u00fcr die der Access Token ausgestellt werden soll. Wenn nicht angegeben, werden die mit dem <code>subject_token</code> und/oder Client verbundenen Standard-Scopes verwendet. <p>Beispiel Anfrage:</p> <pre><code>curl -X POST \\\n  https://as.example.com/token \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -H 'DPoP: &lt;signed_dpop_jwt&gt;' \\\n  -d 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange&amp;' \\\n  -d 'client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&amp;' \\\n  -d 'client_assertion=eyJhbGciOiJFUzI1NiIsImtpZCI6InNvbWVfa2V5X2lkIn0.eyJpc3MiOiJjbGllbnRfaWQwMDEiLCJzdWIiOiJjbGllbnRfaWQwMDEiLCJhdWQiOiJodHRwczovL2F1dGhvcml6YXRpb24uc2VydmVyLmRlL3Rva2VuIiwiZXhwIjoxNjk1NTA0NjAwLCJpYXQiOjE2OTU1MDI4MDAsImp0aSI6ImFiYzEyMzQ1NiJ9.SOME_SIGNATURE_PART_ONE.SOME_SIGNATURE_PART_TWO&amp;' \\\n  -d 'resource=https%3A%2F%2Fapi.example.com%2F/resource&amp;' \\\n  -d 'subject_token_type=urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Ajwt&amp;' \\\n  -d 'subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6InNvbWVfc3ViamVjdF9rZXlfaWQifQ.eyJpc3MiOiJzb21lX3N1YmplY3RfYXV0aG9yaXR5Iiwic3ViIjoiMTIzNDU2Nzg5MCIsImF1ZCI6Imh0dHBzOi8vYXV0aG9yaXphdGlvbi5zZXJ2ZXIuZGUvdG9rZW4iLCJleHAiOjE2OTU1MDI4NjAsImlhdCI6MTY5NTUwMjgwMH0.SM(C)-B_SIGNATURE&amp;' \\\n  -d 'scope=resource.read%20resource.write'\n</code></pre>"},{"location":"api/v1/#antworten_4","title":"Antworten","text":"<p>Antworten werden als JSON-Objekte mit dem <code>Content-Type: application/json</code> im Erfolgsfall und <code>application/problem+json</code> im Fehlerfall zur\u00fcckgegeben. Fehlerantworten folgen dem \"Problem Details for HTTP APIs\"-Standard (RFC 9457).</p> <p>Statuscodes:</p> <ul> <li>200 OK:</li> <li>Bedeutung: Die Anfrage war erfolgreich, und der Server gibt das Access Token und andere Metadaten zur\u00fcck.</li> <li>Content-Type: <code>application/json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"access_token\": \"eyJhbGciOiJFUzI1NiIsImtpZCI6InRva2VuX2tleV9pZCJ9.eyJpc3MiOiJhdXRoLnNlcnZlci5kZSIsImV4cCI6MTY5NTUwMjgwMCwiYXVkIjpbInJlc291cmNlLnNlcnZlci5kZSJdLCJzdWIiOiIxMjM0NTY3ODkwIiwiY2xpZW50X2lkIjoiZXhhbXBsZV9jbGllbnRfaWQiLCJpYXQiOjE2OTU1MDI4MDAsImp0aSI6ImV4YW1wbGVfamRpX3ZhbHVlIiwic2NvcGUiOiJyZXNvdXJjZS5yZWFkIHJlc291cmNlLndyaXRlIiwiY25mIjp7ImprdCI6ImV4YW1wbGVfamt0X2hhc2gifX0.NEW_SIGNATURE_PLACEHOLDER\",\n  \"token_type\": \"DPoP\",\n  \"expires_in\": 3600,\n  \"scope\": \"resource.read resource.write\",\n  \"refresh_token\": \"some_refresh_token_string\",\n  \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\"\n}\n</code></pre> <p>Inhalt des Access Tokens:</p> <pre><code>{\n  \"iss\": \"auth.server.de\",\n  \"exp\": 1695502800,\n  \"aud\": [\"resource.server.de\"],\n  \"sub\": \"1234567890\",\n  \"client_id\": \"my_oauth_client_id\",\n  \"iat\": 1695502800,\n  \"jti\": \"a_unique_jwt_identifier_12345\",\n  \"scope\": \"resource.read resource.write\",\n  \"cnf\": {\n    \"jkt\": \"S7uGv0kQ0g2J_2z8Y_yXm-X_yL0_yXk_Xk_yY1W_Xk\"\n  }\n}\n</code></pre> <ul> <li>400 Bad Request:</li> <li>Bedeutung: Die Anfrage war fehlerhaft, z.B. fehlende oder ung\u00fcltige Parameter.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/400\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"Invalid request parameters.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>401 Unauthorized:</li> <li>Bedeutung: Die Client-Authentifizierung ist fehlgeschlagen, z.B. ung\u00fcltige Client Assertion.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/401\",\n  \"title\": \"Unauthorized\",\n  \"status\": 401,\n  \"detail\": \"Client authentication failed.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>403 Forbidden:</li> <li>Bedeutung: Der Client ist nicht berechtigt, den Token Exchange durchzuf\u00fchren, z.B. wenn der <code>subject_token</code> nicht g\u00fcltig ist oder der Client nicht die erforderlichen Berechtigungen hat.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/403\",\n  \"title\": \"Forbidden\",\n  \"status\": 403,\n  \"detail\": \"The client is not authorized to perform this token exchange.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>429 Too Many Requests:</li> <li>Bedeutung: Der Client hat die Rate-Limits \u00fcberschritten.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/429\",\n  \"title\": \"Too Many Requests\",\n  \"status\": 429,\n  \"detail\": \"Rate limit exceeded. Please try again later.\",\n  \"instance\": \"/token\"\n}\n</code></pre> <ul> <li>500 Internal Server Error:</li> <li>Bedeutung: Ein unerwarteter Fehler ist auf dem Server aufgetreten, der die Anfrage nicht verarbeiten konnte.</li> <li>Content-Type: <code>application/problem+json</code></li> <li>Beispiel Antwort:</li> </ul> <pre><code>{\n  \"type\": \"https://httpstatuses.com/500\",\n  \"title\": \"Internal Server Error\",\n  \"status\": 500,\n  \"detail\": \"An unexpected error occurred while processing your request.\",\n  \"instance\": \"/token\"\n}\n</code></pre>"},{"location":"api/v1/#resource-endpoint","title":"Resource Endpoint","text":"<p>Der Resource Endpoint ist der Endpunkt, der von der gesch\u00fctzten Ressource (Protected Resource) bereitgestellt wird, um auf gesch\u00fctzte Daten zuzugreifen. Er ist durch den ZETA Guard PEP vor unberechtigtem Zugriff gesch\u00fctzt. F\u00fcr den Zugriff auf die gesch\u00fctzte Ressource wird ein g\u00fcltiges Access Token und ein g\u00fcltiges DPoP Proof ben\u00f6tigt. Zus\u00e4tzlich kann eine Anwendung ein g\u00fcltiges PoPP Proof erfordern.</p> <p>Der Resource Endpoint unterst\u00fctzt neben TLS eine zus\u00e4tzliche Verschl\u00fcsselungsschicht ZETA/ASL (ZETA/Additional Security Layer). Im Well-Known JSON Dokument der gesch\u00fctzten Ressource wird angegeben, ob der Endpunkt ZETA/ASL unterst\u00fctzt. Der ZETA/ASL Kanal wird nach dem TLS Verbindungsaufbau aufgebaut und verwendet, um die Kommunikation zwischen Client und Resource Endpoint zu sichern.</p>"},{"location":"api/v1/#anfragen_4","title":"Anfragen","text":"<p>Der ZETA Guard PEP empf\u00e4ngt die Anfragen und pr\u00fcft das Access Token im Authentication Header sowie das DPoP Proof im DPoP Header.</p> <p>HTTP Methode: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>).</p> <p>Pfad: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>/api/resource</code>).</p> <p>Content-Type: wird durch die gesch\u00fctzte Ressource bestimmt (z.B. <code>application/json</code>).</p>"},{"location":"api/v1/#antworten_5","title":"Antworten","text":"<p>Die Antwort des Resource Endpoints h\u00e4ngt von der gesch\u00fctzten Ressource ab und kann verschiedene Statuscodes und Datenformate zur\u00fcckgeben.</p>"},{"location":"api/v1/#konnektorti-gateway-endpunkte","title":"Konnektor/TI-Gateway Endpunkte","text":"<p>Die Endpunkte im Konnektor oder im Highspeed Konnektoren des TI-Gateways werden f\u00fcr die Erstellung von Signaturen mit Der SM(C)-B sowie f\u00fcr die Abfrage des SM(C)-B Zertifikats w\u00e4hrend der Authentifizierung am ZETA Guard verwendet.</p> <p>Hinweis: Perspektivisch ist vorgesehen, dass der Zugriff auf das TI-Gateway \u00fcber den ZETA Guard erfolgt, um die Sicherheit und Integrit\u00e4t der Kommunikation zu gew\u00e4hrleisten. W\u00e4hrend der Authentifizierung wird anstatt der SM(C)-B Identit\u00e4t eine TI-Gateway Identit\u00e4t verwendet.</p>"},{"location":"api/v1/#readcardcertificate","title":"ReadCardCertificate","text":"<p>Die Operation ReadCardCertificate ist in der Konnektor Spezifikation definiert.</p>"},{"location":"api/v1/#externalauthenticate","title":"ExternalAuthenticate","text":"<p>Die Operation ExternalAuthenticate ist in der Konnektor Spezifikation definiert.</p>"},{"location":"api/v1/#zeta-attestation-service-endpunkte","title":"ZETA Attestation Service Endpunkte","text":"<p>Der <code>ZetaAttestationService</code> stellt einen gRPC-Dienst zur Verf\u00fcgung, der es station\u00e4ren Clients (Prim\u00e4rsystem) erm\u00f6glicht, TPM-signierte Attestierungsinformationen f\u00fcr den Client abzurufen. Diese Informationen basieren auf Integrit\u00e4tsmessungen, die in ausgew\u00e4hlten Platform Configuration Registers (PCRs) des Trusted Platform Module (TPM) gespeichert sind. Der ZETA Guard Authorization Server verwendet diese Attestierungsdaten, um die Integrit\u00e4t und Authentizit\u00e4t der Softwareumgebung des Clients zu verifizieren, bevor Zugriff auf gesch\u00fctzte Ressourcen gew\u00e4hrt wird.</p> <p>Der ZETA Attestation Service wird vom Hersteller des station\u00e4ren Clients bereitgestellt und es muss eine Vertrauensbeziehung zwischen station\u00e4ren Client und ZETA Attestation Service bestehen, um zu gew\u00e4hrleisten, dass die Attestation \u00fcber die vorgesehenen Software-Komponenten erfolgt.</p> <p>Hinweis: W\u00e4hrend der Installation oder bei Updates des station\u00e4ren Clients muss auch ein Update des ZETA Attestation Service erfolgen um eine neue Baseline f\u00fcr die Integrit\u00e4t des station\u00e4ren Clients zu setzen. Die Baseline besteht aus einem Hash \u00fcber alle unver\u00e4nderlichen Komponenten des station\u00e4ren Clients, inkl. ZETA Attestation Service.</p> <p>Hinweis: Der ZETA Attestation Service muss bei jedem Start des Clients die Messung \u00fcber die Integrit\u00e4t des Clients durchf\u00fchren und in das PCR schreiben.</p> <p>Hinweis: Der ZETA Attestation Service ist nicht f\u00fcr mobile Clients vorgesehen. Mobile Clients verwenden eine andere Attestierungsmethode, die auf den jeweiligen Plattformen basiert (z.B. Android SafetyNet, iOS DeviceCheck).</p> <p>Hinweis: TODO Umgang mit Messung des Clients weicht von Baseline ab; empfohlenes Verhalten f\u00fcr Client und ZetaAttestationService (z. B. automatisch Support informieren)</p>"},{"location":"api/v1/#dienstdefinition","title":"Dienstdefinition","text":"<ul> <li>Service Name: <code>zeta.attestation.service.v1.ZetaAttestationService</code></li> <li>Proto Buffer Spezifikation: zeta-attestation-service.proto</li> </ul>"},{"location":"api/v1/#rpc-methoden","title":"RPC Methoden","text":""},{"location":"api/v1/#getattestation","title":"GetAttestation","text":"<p>Diese RPC-Methode erm\u00f6glicht es Clients, eine signierte Attestierungs-Quote vom TPM des Systems anzufordern, die spezifische PCR-Werte und eine vom Client bereitgestellte Challenge enth\u00e4lt.</p>"},{"location":"api/v1/#request-nachricht-getattestationrequest","title":"Request-Nachricht: <code>GetAttestationRequest</code>","text":"<p>Die <code>GetAttestationRequest</code>-Nachricht enth\u00e4lt die Parameter, die f\u00fcr die Anforderung einer Attestierung ben\u00f6tigt werden.</p> Feld Typ Erforderlich Beschreibung <code>attestation_challenge</code> <code>bytes</code> Ja Ein SHA-256 Hashwert, berechnet aus der Verkettung des SHA-256 Fingerabdrucks des Public Client Instance Keys und einer Nonce vom ZETA Guard Authorization Server. Dient zur Verhinderung von Replay-Angriffen und zur Korrelation. <code>pcr_indices</code> <code>repeated uint32</code> Ja Eine Liste von TPM PCR-Indizes, deren aktuelle Werte in die Attestierungs-Quote aufgenommen und zur\u00fcckgegeben werden sollen. <p>Berechnung der <code>attestation_challenge</code>: Der Client ist f\u00fcr die korrekte Berechnung dieses Wertes verantwortlich.</p> <pre><code>data_to_hash = sha256_thumbprint_of_public_client_instance_key_bytes || nonce_from_zeta_guard_bytes\nattestation_challenge = SHA-256(data_to_hash)\n</code></pre> <p>Beispiel (Python) f\u00fcr die Berechnung der <code>attestation_challenge</code>:</p> <pre><code>import hashlib\n\n# Beispielwerte\nthumbprint_hex = \"9f3d4f2a6c5e4e21d84c8a713d3c37cfb1a2f3a4b14ad9d8d8d9c0e7c8e7e6f5\" # SHA-256 Fingerabdruck\nnonce_hex = \"a1b2c3d4e5f60718293a4b5c6d7e8f90\"\n\nthumbprint_bytes = bytes.fromhex(thumbprint_hex)\nnonce_bytes = bytes.fromhex(nonce_hex)\n\ndata_to_hash = thumbprint_bytes + nonce_bytes\nattestation_challenge_bytes = hashlib.sha256(data_to_hash).digest() # als Bytes\nattestation_challenge_hex = hashlib.sha256(data_to_hash).hexdigest() # als Hex-String\n\nprint(f\"attestation_challenge (hex): {attestation_challenge_hex}\")\n# In der gRPC Anfrage wird `attestation_challenge_bytes` verwendet.\n</code></pre> <p>Empfohlene PCR-Indizes:</p> <ul> <li>PCR 4: Boot Loader Code, Digest</li> <li>PCR 5: Boot Loader Configuration, Digest</li> <li>PCR 7: Secure Boot State / Policy, Digest</li> <li>PCR 10:OS Kernel / IMA, Digest</li> <li>PCR 11: OS Components / VSM, Digest,</li> <li>PCR 22 or 23 (if available) Client Data</li> </ul>"},{"location":"api/v1/#response-nachricht-getattestationresponse","title":"Response-Nachricht: <code>GetAttestationResponse</code>","text":"<p>Die <code>GetAttestationResponse</code>-Nachricht enth\u00e4lt die vom Dienst generierten Attestierungsdaten.</p> Feld Typ Beschreibung <code>attestation_quote</code> <code>bytes</code> Die rohe, signierte Attestierungs-Quote des TPMs (eine TPM2_ATTEST Struktur). Diese Quote enth\u00e4lt die angefragten PCR-Werte sowie den <code>attestation_challenge</code> Wert. Muss clientseitig geparst werden. <code>current_pcr_values</code> <code>map&lt;uint32, bytes&gt;</code> Eine Abbildung der angefragten PCR-Indizes auf ihre aktuellen, gemessenen Werte. Die L\u00e4nge der <code>bytes</code> h\u00e4ngt vom aktiven Hashing-Algorithmus der jeweiligen PCR-Bank ab (z.B. 20 Bytes f\u00fcr SHA-1, 32 Bytes f\u00fcr SHA-256). <code>status</code> <code>AttestationStatus</code> (enum) Der vom ZETA Attestation Service intern ermittelte Status der Attestierung. Gibt an, ob die Messungen erfolgreich waren und ob sie ggf. einer definierten Baseline entsprechen. <code>status_message</code> <code>string</code> (optional) Eine menschenlesbare Beschreibung des Attestierungsstatus oder zus\u00e4tzliche Informationen, insbesondere im Fehlerfall oder bei einem <code>BASELINE_MISMATCH</code>. <code>timestamp</code> <code>google.protobuf.Timestamp</code> (optional) Der Zeitstempel der Erstellung der Attestierungs-Quote durch den ZETA Attestation Service. Erfordert <code>import \"google/protobuf/timestamp.proto\";</code>. <code>event_log</code> <code>bytes</code> (optional) Das TPM-Event-Log im plattformspezifischen Format (z.B. TCG PC Client Platform Firmware Profile Specification). Dieses Log detailliert die Sequenz der Erweiterungen der PCRs und ist essentiell f\u00fcr eine vollst\u00e4ndige Validierung. <p>AttestationStatus Enum:</p> <p>Definiert die m\u00f6glichen Statuswerte f\u00fcr die Attestierung, die vom ZETA Attestation Service zur\u00fcckgegeben werden.</p> Wert Numerischer Wert Beschreibung <code>ATTESTATION_STATUS_UNSPECIFIED</code> 0 Der Status ist nicht spezifiziert oder konnte nicht ermittelt werden. Dies sollte als Fehler interpretiert werden. <code>ATTESTATION_STATUS_SUCCESS</code> 1 Die Attestierung war erfolgreich, die Quote wurde generiert und (falls eine Baseline-Pr\u00fcfung serverseitig erfolgt) die Messungen entsprechen der Baseline. <code>ATTESTATION_STATUS_BASELINE_MISMATCH</code> 2 Die Attestierung war technisch erfolgreich, aber die aktuellen PCR-Messwerte weichen von der erwarteten Baseline ab. <code>ATTESTATION_STATUS_TPM_ERROR</code> 3 Ein Fehler ist bei der Kommunikation mit dem TPM oder bei einer TPM-Operation aufgetreten (z.B. TPM nicht bereit, PCR nicht lesbar). <code>ATTESTATION_STATUS_INVALID_REQUEST</code> 4 Die Anfrageparameter waren ung\u00fcltig (z.B. <code>attestation_challenge</code> fehlt oder hat falsches Format, ung\u00fcltige oder nicht unterst\u00fctzte <code>pcr_indices</code>). <code>ATTESTATION_STATUS_INTERNAL_ERROR</code> 5 Ein interner, nicht n\u00e4her spezifizierter Fehler ist auf Serverseite aufgetreten."},{"location":"api/v1/#fehlerbehandlung","title":"Fehlerbehandlung","text":"<p>Der <code>ZetaAttestationService</code> verwendet standardm\u00e4\u00dfige gRPC-Statuscodes, um das Ergebnis der Operation auf Transportebene zu kommunizieren. Diese werden erg\u00e4nzt durch den <code>status</code>-Feld in der <code>GetAttestationResponse</code> f\u00fcr anwendungsspezifische Logik. Die <code>google.rpc.Status</code> kann f\u00fcr detailliertere Fehlerinformationen verwendet werden (siehe <code>import \"google/rpc/status.proto\";</code>).</p> <p>H\u00e4ufige gRPC-Statuscodes:</p> <ul> <li><code>OK</code> (0): Die Anfrage war erfolgreich und die <code>GetAttestationResponse</code> enth\u00e4lt die Ergebnisse. Der <code>status</code>-Feld in der Response gibt den anwendungsspezifischen Erfolg oder Misserfolg an.</li> <li><code>INVALID_ARGUMENT</code> (3):</li> <li>Einer oder mehrere Parameter der Anfrage waren ung\u00fcltig.</li> <li>Beispiele: <code>attestation_challenge</code> fehlt, hat eine falsche L\u00e4nge oder ein ung\u00fcltiges Format; <code>pcr_indices</code> ist leer, enth\u00e4lt ung\u00fcltige oder nicht unterst\u00fctzte Indizes.</li> <li>Der <code>status</code> in der Response k\u00f6nnte <code>ATTESTATION_STATUS_INVALID_REQUEST</code> sein.</li> <li><code>UNAUTHENTICATED</code> (16) / <code>PERMISSION_DENIED</code> (7):</li> <li>Der anfragende Client ist nicht authentifiziert oder nicht   autorisiert, diese Anfrage zu stellen.</li> <li>Relevant, wenn Mechanismen wie mTLS oder Token-basierte   Authentifizierung verwendet werden.</li> <li><code>UNAVAILABLE</code> (14):</li> <li>Der ZETA Attestation Service kann die Attestierung derzeit nicht   durchf\u00fchren.</li> <li>Beispiele: TPM ist nicht erreichbar oder nicht funktionsf\u00e4hig;   eine erforderliche Baseline-Konfiguration ist nicht vorhanden.</li> <li>Der <code>status</code> in der Response k\u00f6nnte   <code>ATTESTATION_STATUS_TPM_ERROR</code> oder   <code>ATTESTATION_STATUS_INTERNAL_ERROR</code> sein.</li> <li><code>INTERNAL</code> (13):</li> <li>Ein unerwarteter serverseitiger Fehler ist aufgetreten, der   nicht spezifischer kategorisiert werden kann.</li> <li>Der <code>status</code> in der Response ist typischerweise   <code>ATTESTATION_STATUS_INTERNAL_ERROR</code>.</li> </ul>"},{"location":"api/v1/#sicherheitsaspekte","title":"Sicherheitsaspekte","text":"<ul> <li>Transport-Sicherheit: Es wird dringend empfohlen, die Kommunikation zwischen Client und <code>ZetaAttestationService</code> mittels TLS, vorzugsweise mTLS (mutual TLS), abzusichern, um Authentizit\u00e4t, Integrit\u00e4t und Vertraulichkeit der \u00fcbertragenen Daten zu gew\u00e4hrleisten. Hinweis: Es wird empfohlen, dass der Installer des Clients und des ZetaAttestationService die Schl\u00fcssel f\u00fcr die mTLS Verbindung erzeugt und sicher speichert.</li> <li>Challenge-Response: Die <code>attestation_challenge</code> ist ein kritischer Bestandteil zur Verhinderung von Replay-Angriffen. Die <code>nonce</code> muss f\u00fcr jede Attestierungsanfrage eindeutig sein und sicher vom ZETA Guard Authorization Server generiert und an den Client \u00fcbermittelt werden.</li> <li>Event Log Validierung: Die alleinige \u00dcberpr\u00fcfung der PCR-Werte ist oft nicht ausreichend. Eine gr\u00fcndliche Validierung der Attestierung erfordert das Parsen und \u00dcberpr\u00fcfen des <code>event_log</code>, um die Kausalkette der Messungen nachzuvollziehen. Dies erfolgt im ZETA Guard Authorization Server.</li> </ul>"},{"location":"api/v1/#verwaltung-von-schlusseln-und-session-daten-im-zeta-client","title":"Verwaltung von Schl\u00fcsseln und Session-Daten im ZETA Client","text":""},{"location":"api/v1/#einleitung","title":"Einleitung","text":"<p>Ein ZETA Client muss verschiedene kryptografische Schl\u00fcssel und Session-Informationen verwalten, um mit einer oder mehreren ZETA Guard Instanzen sicher und persistent kommunizieren zu k\u00f6nnen. Die Speicherung und Verwaltung dieser Daten ist kritisch f\u00fcr die Sicherheit und Funktionalit\u00e4t des Clients.</p> <p>Es wird zwischen zwei Arten von Daten unterschieden:</p> <ol> <li>Globale Daten: Diese sind \u00fcbergreifend f\u00fcr die Client-Instanz und unabh\u00e4ngig von einer spezifischen ZETA Guard Instanz.</li> <li>Pro-ZETA-Guard-Instanz Daten: Diese Daten sind spezifisch f\u00fcr die Session mit einer einzelnen ZETA Guard Instanz.</li> </ol>"},{"location":"api/v1/#globale-daten-client-ubergreifend","title":"Globale Daten (Client-\u00fcbergreifend)","text":"<p>Diese Daten definieren die langlebige Identit\u00e4t der Client-Anwendung selbst. Sie m\u00fcssen persistent \u00fcber alle Sessions und Neustarts der Anwendung hinweg gespeichert werden.</p> <ul> <li><code>Client Instance Key</code> (Asymmetrisches Schl\u00fcsselpaar)</li> <li>Beschreibung: Dies ist das Hauptschl\u00fcsselpaar des Clients. Der private Schl\u00fcssel wird zur Signierung der Client-Registrierung bei neuen ZETA Guard Instanzen und zur Client Assertion Authentifizierung verwendet. Der \u00f6ffentliche Schl\u00fcssel dient als eindeutiger, kryptografischer Identifikator des Clients.</li> <li>Speicheranforderung: Dieses Schl\u00fcsselpaar muss einmalig bei der ersten Initialisierung des Clients generiert und anschlie\u00dfend sicher und persistent gespeichert werden. Ein Verlust des privaten Schl\u00fcssels bedeutet, dass der Client seine Identit\u00e4t verliert und sich bei allen bereits bekannten ZETA Guard Instanzen neu registrieren muss.</li> <li>Sicherheit: Der private Schl\u00fcssel ist das wertvollste Geheimnis des Clients und darf niemals im Klartext gespeichert werden. Siehe Kapitel 1.6.4 Sicherheitsempfehlungen f\u00fcr die Schl\u00fcsselspeicherung.</li> </ul>"},{"location":"api/v1/#daten-pro-zeta-guard-instanz","title":"Daten pro ZETA Guard Instanz","text":"<p>F\u00fcr jede ZETA Guard Instanz, mit der der Client eine Verbindung aufbaut, m\u00fcssen die folgenden Daten separat und zugeordnet zur jeweiligen ZETA Guard-Instanz (z.B. \u00fcber deren Basis-URL) gespeichert werden.</p> <ul> <li><code>DPoP Key</code> (Asymmetrisches Schl\u00fcsselpaar)</li> <li>Beschreibung: F\u00fcr jede aktive Session mit einer ZETA Guard Instanz wird ein eigenes, kurzlebiges Schl\u00fcsselpaar generiert. Der private Schl\u00fcssel wird verwendet, um einzelne API-Anfragen an den Guard zu signieren (<code>DPoP</code>).</li> <li>Speicheranforderung: Dieses Schl\u00fcsselpaar ist nur f\u00fcr die Dauer einer Session g\u00fcltig. Es sollte sicher gespeichert, aber nach Beendigung der Session (z.B. durch Logout oder Token-Ablauf ohne Refresh-M\u00f6glichkeit) verworfen werden.</li> <li> <p>Sicherheit: Auch dieser private Schl\u00fcssel muss f\u00fcr seine Lebensdauer sicher aufbewahrt werden.</p> </li> <li> <p><code>Access Token</code></p> </li> <li>Beschreibung: Das vom Authorization Server des ZETA Guards ausgestellte OAuth 2.0 Access Token. Es wird im <code>Authorization</code>-Header bei jeder authentifizierten API-Anfrage mitgesendet.</li> <li> <p>Speicheranforderung: Dieses Token ist kurzlebig und muss nach Ablauf erneuert werden. Es kann im Arbeitsspeicher gehalten oder persistent gespeichert werden, um nach einem Neustart der Anwendung die Session wiederaufnehmen zu k\u00f6nnen. Es besteht ein Diebstahlschutz durch die Bindung an den DPoP Schl\u00fcssel.</p> </li> <li> <p><code>Refresh Token</code></p> </li> <li>Beschreibung: Das vom Authorization Server des ZETA Guards ausgestellte OAuth 2.0 Refresh Token. Dieses Token kann verwendet werden, um ein neues Access Token zu erhalten, ohne dass der Benutzer sich erneut authentifizieren muss.</li> <li> <p>Speicheranforderung: Das Refresh Token ist langlebiger als das Access Token und stellt einen sensiblen Berechtigungsnachweis dar. Es sollte persistent und sicher gespeichert werden. Es besteht ein Diebstahlschutz durch die Bindung an den DPoP Schl\u00fcssel.</p> </li> <li> <p><code>Client ID</code></p> </li> <li>Beschreibung: Die eindeutige ID, die der ZETA Guard dem ZETA Client w\u00e4hrend des Registrierungsprozesses zugewiesen hat. Sie wird f\u00fcr die Token-Anforderung ben\u00f6tigt.</li> <li> <p>Speicheranforderung: Muss persistent gespeichert werden, solange die Registrierung beim ZETA Guard g\u00fcltig sein soll.</p> </li> <li> <p>Discovery-Dokument Daten (Well-Known)</p> </li> <li>Beschreibung: Die Endpunkt-URLs und Konfigurationsdaten aus den Discovery-Dokumenten des ZETA Guards.</li> <li>Speicheranforderung: Es wird dringend empfohlen, diese Daten zu cachen, um wiederholte Discovery-Anfragen zu vermeiden. Der Cache sollte eine angemessene Lebensdauer haben (z.B. 24 Stunden), um auf Konfigurations\u00e4nderungen am Guard reagieren zu k\u00f6nnen.</li> </ul>"},{"location":"api/v1/#konzeptionelles-speicherlayout","title":"Konzeptionelles Speicherlayout","text":"<p>Ein ZETA Client k\u00f6nnte die Daten konzeptionell wie folgt strukturieren:</p> <pre><code>{\n  \"client_instance_private_key\": \"gesch\u00fctzter_speicher_ref\",\n  \"guard_sessions\": {\n    \"https://guard1.example.com\": {\n      \"client_id\": \"client-id-beim-zeta-guard-1\",\n      \"session_private_key\": \"gesch\u00fctzter_speicher_ref\",\n      \"access_token\": \"ey...\",\n      \"refresh_token\": \"def...\",\n      \"discovery_cache\": {\n        \"expires_at\": \"2024-12-01T10:00:00Z\",\n        \"data\": {\n          \"token_endpoint\": \"...\",\n          \"jwks_uri\": \"...\"\n        }\n      }\n    },\n    \"https://guard2.another-provider.de\": {\n      \"client_id\": \"client-id-beim-zeta-guard-2\",\n      \"session_private_key\": \"...\",\n      \"access_token\": \"...\",\n      \"refresh_token\": null,\n      \"discovery_cache\": { ... }\n    }\n  }\n}\n</code></pre>"},{"location":"api/v1/#sicherheitsempfehlungen-fur-die-schlusselspeicherung","title":"Sicherheitsempfehlungen f\u00fcr die Schl\u00fcsselspeicherung","text":"<p>Private Schl\u00fcssel (<code>Client Instance Key</code>, <code>DPoP Key</code>) sind hochsensible Daten. Ihre Kompromittierung erm\u00f6glicht es einem Angreifer, die Identit\u00e4t des Clients zu missbrauchen. Sie m\u00fcssen daher mit den sichersten, vom jeweiligen Betriebssystem bereitgestellten Mitteln gesch\u00fctzt werden.</p> <p>Grundprinzip: Speichern Sie private Schl\u00fcssel niemals unverschl\u00fcsselt im Dateisystem oder in einer Klartext-Konfigurationsdatei.</p> <p>Nutzen Sie stattdessen plattformspezifische, sichere Speicherorte (sog. \"Keystores\" oder \"Secret Vaults\"), die die Schl\u00fcssel an das Benutzerkonto oder die Maschinenidentit\u00e4t binden.</p> <ul> <li>Microsoft Windows:</li> <li>Empfehlung: Verwenden Sie die Data Protection API (DPAPI), die \u00fcber die Funktionen <code>CryptProtectData</code> und <code>CryptUnprotectData</code> zug\u00e4nglich ist.</li> <li> <p>Funktionsweise: DPAPI verschl\u00fcsselt Daten mithilfe eines Schl\u00fcssels, der aus den Anmeldeinformationen des Benutzers abgeleitet wird. Die Daten k\u00f6nnen somit nur von demselben Benutzer auf demselben Computer wieder entschl\u00fcsselt werden. Dies ist ideal f\u00fcr Desktop-Anwendungen. F\u00fcr Dienste, die unter einem Systemkonto laufen, kann der Schutz an die Maschinenidentit\u00e4t gebunden werden.</p> </li> <li> <p>Apple macOS:</p> </li> <li>Empfehlung: Nutzen Sie den macOS Keychain (Schl\u00fcsselbund).</li> <li> <p>Funktionsweise: Der Schl\u00fcsselbund ist ein zentraler, verschl\u00fcsselter Speicher f\u00fcr Passw\u00f6rter, Zertifikate und Schl\u00fcssel. Der Zugriff wird vom Betriebssystem streng kontrolliert und erfordert in der Regel die Zustimmung des Benutzers. Verwenden Sie die <code>Security</code> Framework-APIs, um Schl\u00fcssel sicher zu speichern und abzurufen.</p> </li> <li> <p>Linux:</p> </li> <li>Empfehlung (Desktop-Umgebungen): Verwenden Sie den Secret Service DBus API, der von Diensten wie dem GNOME Keyring oder KWallet implementiert wird. Dies ist der Freedesktop.org-Standard und die bevorzugte Methode f\u00fcr Desktop-Anwendungen.</li> <li>Empfehlung (Server/Headless-Umgebungen):         1. Dateibasierte Verschl\u00fcsselung: Speichern Sie den Schl\u00fcssel in einer Datei, die mit einem Master-Passwort verschl\u00fcsselt ist (das z.B. beim Start der Anwendung abgefragt wird).         2. Strikte Dateiberechtigungen: Als absolutes Minimum muss die Schl\u00fcsseldatei durch strikte Dateisystemberechtigungen gesch\u00fctzt werden. Der private Schl\u00fcssel sollte nur f\u00fcr den Benutzer lesbar sein, unter dem die Anwendung l\u00e4uft.             <pre><code># Setzt die Berechtigung, sodass nur der Eigent\u00fcmer lesen und schreiben darf\nchmod 600 /pfad/zum/privaten_schluessel.key\n</code></pre>         Diese Methode bietet jedoch keinen Schutz, wenn ein Angreifer Lesezugriff auf das Dateisystem als der betreffende Benutzer erlangt. Sie sollte m\u00f6glichst mit zus\u00e4tzlicher Verschl\u00fcsselung kombiniert werden.</li> </ul> <p>Cross-Plattform-Bibliotheken: F\u00fcr in h\u00f6heren Programmiersprachen (z.B. Python, Go, Rust, C#) entwickelte Clients existieren oft Bibliotheken, die die plattformspezifischen Speicher abstrahieren und eine einheitliche API f\u00fcr den Zugriff auf den Windows DPAPI, den macOS Keychain und den Secret Service unter Linux bieten. Die Verwendung solcher Bibliotheken wird empfohlen.</p>"},{"location":"api/v1/#versionierung","title":"Versionierung","text":"<p>Um eine stabile und vorhersagbare Entwicklungsumgebung f\u00fcr Client-Anwendungen zu gew\u00e4hrleisten, folgt die ZETA API strikt den Prinzipien von Semantic Versioning 2.0.0 (SemVer). Jede \u00c4nderung an der API wird klassifiziert, um die Auswirkungen auf bestehende Clients transparent zu machen.</p>"},{"location":"api/v1/#versionierungsschema-majorminorpatch","title":"Versionierungsschema: MAJOR.MINOR.PATCH","text":"<p>Jede ZETA Guard Instanz deklariert ihre API-Version im Format <code>MAJOR.MINOR.PATCH</code> (z.B. <code>1.2.3</code>). Die Bedeutung der einzelnen Komponenten ist wie folgt definiert:</p> <ul> <li>MAJOR-Version (z.B. <code>1</code>.2.3): Wird erh\u00f6ht, wenn r\u00fcckw\u00e4rtsinkompatible (\"breaking\") \u00c4nderungen an der API vorgenommen werden. Dies erfordert eine Anpassung aufseiten des Clients, um weiterhin korrekt zu funktionieren.</li> <li> <p>Beispiele: Entfernen eines Endpunkts, Umbenennung eines JSON-Feldes, \u00c4nderung eines Felddatentyps, Hinzuf\u00fcgen eines verpflichtenden Request-Parameters.</p> </li> <li> <p>MINOR-Version (z.B. 1.<code>2</code>.3): Wird erh\u00f6ht, wenn neue Funktionalit\u00e4t in einer r\u00fcckw\u00e4rtskompatiblen Weise hinzugef\u00fcgt wird. Bestehende Clients d\u00fcrfen durch diese \u00c4nderungen nicht beeintr\u00e4chtigt werden.</p> </li> <li> <p>Beispiele: Hinzuf\u00fcgen eines neuen API-Endpunkts, Hinzuf\u00fcgen eines neuen, optionalen Feldes in einer JSON-Antwort, Hinzuf\u00fcgen eines neuen, optionalen Request-Parameters.</p> </li> <li> <p>PATCH-Version (z.B. 1.2.<code>3</code>): Wird erh\u00f6ht, wenn r\u00fcckw\u00e4rtskompatible Fehlerbehebungen (\"bug fixes\") vorgenommen werden, die das Verhalten der API korrigieren, aber keine neue Funktionalit\u00e4t einf\u00fchren.</p> </li> <li>Beispiele: Korrektur einer fehlerhaften Validierungslogik, Behebung eines internen Fehlers, der zu einem <code>500 Internal Server Error</code> f\u00fchrte.</li> </ul> <p>Zus\u00e4tzlich k\u00f6nnen Prerelease-Tags verwendet werden (z.B. <code>2.0.0-beta.1</code>), um instabile Vorabversionen zu kennzeichnen.</p>"},{"location":"api/v1/#implementierung-der-versionierung","title":"Implementierung der Versionierung","text":"<p>Die Versionierung wird durch eine Kombination aus URL-Pfad, HTTP-Headern und dem Discovery-Dokument umgesetzt.</p>"},{"location":"api/v1/#1-url-pfad-fur-die-major-version","title":"1. URL-Pfad f\u00fcr die MAJOR-Version","text":"<p>R\u00fcckw\u00e4rtsinkompatible \u00c4nderungen sind am einschneidendsten. Daher wird die MAJOR-Version direkt und explizit im URL-Pfad der API gef\u00fchrt.</p> <ul> <li>Schema: <code>https://&lt;guard-base-url&gt;/zeta/v{major-version}/&lt;endpoint&gt;</code></li> <li>Beispiel f\u00fcr Version <code>1.4.2</code>: <code>POST https://guard.example.com/zeta/v1/token</code></li> <li>Beispiel f\u00fcr Version <code>2.0.0</code>: <code>POST https://guard.example.com/zeta/v2/token</code></li> </ul>"},{"location":"api/v1/#2-discovery-dokument-als-source-of-truth","title":"2. Discovery-Dokument als \"Source of Truth\"","text":"<p>Die Discovery-Dokumente (<code>/.well-known/oauth-protected-resource</code> und <code>/.well-known/oauth-authorization-server</code>) sind die zentrale Anlaufstelle f\u00fcr einen Client, um die exakten, vom ZETA Guard unterst\u00fctzten Versionen zu ermitteln.</p> <ul> <li><code>api_versions_supported</code>: Dieses JSON-Objekt listet alle vom ZETA Guard angebotenen MAJOR-Versionen mit ihrer jeweiligen vollen SemVer-Version auf.</li> </ul> <pre><code>// Beispiel-Ausschnitt aus /.well-known/...\n{\n  \"issuer\": \"https://zeta-guard.example.com\",\n  // ... andere Endpunkte\n  \"api_versions_supported\": [\n    {\n      \"major_version\": 1,\n      \"version\": \"1.4.2\", // Die volle, stabile SemVer-Version f\u00fcr v1\n      \"status\": \"stable\",\n      \"documentation_uri\": \"https://gematik.github.io/ZETA/v1/\"\n    },\n    {\n      \"major_version\": 2,\n      \"version\": \"2.0.0-beta.3\", // Eine instabile Vorabversion f\u00fcr v2\n      \"status\": \"beta\",\n      \"documentation_uri\": \"https://gematik.github.io/ZETA/v2/\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/v1/#3-http-header-zur-laufzeit-identifikation","title":"3. HTTP-Header zur Laufzeit-Identifikation","text":"<p>Jede Antwort des ZETA Guards enth\u00e4lt einen <code>ZETA-API-Version</code>-Header, der die exakte SemVer-Version der ausf\u00fchrenden Instanz angibt. Dies ist besonders f\u00fcr Debugging und Logging wertvoll.</p> <ul> <li>Beispiel-Response-Header: <code>HTTP/1.1 200 OK</code> <code>Content-Type: application/json</code> <code>ZETA-API-Version: 1.4.2</code></li> </ul>"},{"location":"api/v1/#client-verhalten-und-kompatibilitatsregeln","title":"Client-Verhalten und Kompatibilit\u00e4tsregeln","text":"<p>Um die Stabilit\u00e4t zu gew\u00e4hrleisten, m\u00fcssen Clients die folgenden Regeln befolgen:</p> <ol> <li> <p>Toleranz gegen\u00fcber MINOR- und PATCH-Versionen: Ein Client, der f\u00fcr eine bestimmte API-Version entwickelt wurde (z.B. <code>1.2.0</code>), muss nahtlos mit jeder neueren, r\u00fcckw\u00e4rtskompatiblen Version derselben MAJOR-Version (z.B. <code>1.3.0</code> oder <code>1.2.1</code>) funktionieren. Dies bedeutet konkret:</p> <ul> <li>Unbekannte Felder ignorieren: Der Client-Parser muss unbekannte Felder in JSON-Antworten ignorieren und darf keinen Fehler ausl\u00f6sen.</li> <li>Reihenfolgeunabh\u00e4ngigkeit: Der Client darf sich nicht auf die Reihenfolge von Feldern in JSON-Objekten verlassen.</li> </ul> </li> <li> <p>Explizite Wahl der MAJOR-Version: Der Client w\u00e4hlt die MAJOR-Version aktiv \u00fcber den verwendeten URL-Pfad (z.B. <code>/v1/</code>). Ein Wechsel zu einer neuen MAJOR-Version (z.B. auf <code>/v2/</code>) ist eine bewusste Entwicklungsentscheidung und erfordert eine Code-Anpassung.</p> </li> </ol>"},{"location":"api/v1/#deprecation-policy-auerbetriebnahme","title":"Deprecation Policy (Au\u00dferbetriebnahme)","text":"<p>Wenn eine neue MAJOR-Version (z.B. <code>v2</code>) den Status <code>stable</code> erreicht, wird die vorherige MAJOR-Version (<code>v1</code>) als <code>deprecated</code> (veraltet) markiert.</p> <ol> <li>Ank\u00fcndigungsphase: Die veraltete Version wird im Discovery-Dokument als <code>deprecated</code> gekennzeichnet. Anfragen an diese Version k\u00f6nnen einen <code>Warning</code>-HTTP-Header zur\u00fcckgeben, der auf die bevorstehende Abschaltung hinweist.</li> <li>Migrationszeitraum: Es wird einen klar kommunizierten Zeitraum geben, in dem beide MAJOR-Versionen parallel betrieben werden, um Clients eine reibungslose Migration zu erm\u00f6glichen. Zus\u00e4tzlich wird \u00fcberwacht, welche ZETA Client-Versionen aktiv sind, um die Migration zu unterst\u00fctzen.</li> <li>Abschaltung: Nach Ablauf des Migrationszeitraums und wenn die \u00dcberwachung der ZETA Clients ergeben hat, dass keine veralteten Clients mehr aktiv genutzt werden, wird die veraltete Version abgeschaltet. Anfragen an die Endpunkte dieser Version f\u00fchren dann zu einem <code>HTTP 410 Gone</code>-Fehler.</li> </ol>"},{"location":"api/v1/#performance-und-lastannahmen","title":"Performance- und Lastannahmen","text":"<p>Informationen zu den erwarteten Leistungs- und Lastannahmen f\u00fcr die ZETA API werden nachgereicht.</p> <ul> <li>SM(C)-B Signaturerstellung</li> <li>TPM Attestation</li> <li>ZETA Guard Clientregistrierung</li> <li>ZETA Guard Authentifizierung</li> <li>ZETA Guard Refresh Token Exchange</li> <li>ZETA Guard PEP</li> </ul>"},{"location":"api/v1/#rate-limits-und-einschrankungen","title":"Rate Limits und Einschr\u00e4nkungen","text":"<p>Der OAuth Protected Resource Well-Known Endpoint ist so konfiguriert, dass er eine Rate-Limiting-Strategie implementiert. Der ZETA Client muss die Rate Limits beachten, um eine \u00dcberlastung des Endpunkts zu vermeiden. Die genauen Limits k\u00f6nnen je nach Implementierung variieren, aber typischerweise gelten folgende Richtlinien:</p> <ul> <li>X-RateLimit-Limit</li> <li>X-RateLimit-Remaining</li> <li>X-RateLimit-Reset</li> </ul> <p>oder:</p> <ul> <li>RateLimit-Policy</li> <li>RateLimit</li> </ul> <p>Beispiele: Draft RFC f\u00fcr Rate Limits</p>"},{"location":"api/v1/#support-und-kontaktinformationen","title":"Support und Kontaktinformationen","text":"<p>Hilfe: Informationen dar\u00fcber, wo und wie Benutzer Unterst\u00fctzung erhalten k\u00f6nnen (z.B. Forum, E-Mail-Support). Fehlerberichterstattung: Wie k\u00f6nnen Nutzer Bugs melden oder Feature-Anfragen stellen?</p>"},{"location":"zeta-guard/v1/","title":"ZETA Guard v1","text":"<p>ZETA Guard ist die zentrale Komponente von ZETA, die als Policy Enforcement Point (PEP) und Policy Decision Point (PDP) fungiert. ZETA Guard ist verantwortlich f\u00fcr die Durchsetzung von Sicherheitsrichtlinien und die Entscheidung \u00fcber Zugriffsanfragen auf gesch\u00fctzte Resource Server. ZETA Guard bietet eine RESTful API, die es ZETA Clients erm\u00f6glicht, sich zu registrieren, zu authentifizieren und Autorisierungsanfragen zu stellen. Die API ist so gestaltet, dass sie eine einfache Integration in bestehende Systeme erm\u00f6glicht und gleichzeitig die Sicherheitsanforderungen des Zero Trust Modells erf\u00fcllt.</p>"},{"location":"spec-vsdm2/","title":"Index","text":""},{"location":"spec-vsdm2/#spezifikation-vsdm-20-fhir-profile-und-api","title":"Spezifikation VSDM 2.0 FHIR-Profile und API","text":""},{"location":"spec-vsdm2/#disclaimer","title":"Disclaimer","text":"<p>Dieses Dokument beschreibt die f\u00fcr die Implementierung des Versicherungsstammdatenmanagements (VSDM) 2.0 erforderlichen Vorgaben. Weitere Vorgaben zur Implementierung der Anteile von PoPP und Zero Trust sind zum Stand der Ver\u00f6ffentlichung von VSDM 2.0 nicht Bestandteil dieses Dokuments. Die Aufnahme der Implementierungsvorgaben aus PoPP und Zero Trust in den ILF f\u00fcr VSDM 2.0 erfolgt iterativ sobald die notwendigen Informationen aus diesen Implementierungsleitf\u00e4den vorliegen.</p> <p>Die in der Spezifikation VSDM 2.0 [gemSpec_VSDM_2] enthaltenen und in den Steckbrief [gemSST_CS_VSDM_2] ausgeleiteten Anforderungen an Clientsysteme haben informativen Charakter und treffen Festlegungen \u00fcber diesen Implementierungsleitfaden hinaus. Die Anforderungen dienen zur Unterst\u00fctzung der Implementierung durch Prim\u00e4rsystemhersteller.</p>"},{"location":"spec-vsdm2/#einleitung","title":"Einleitung","text":"<p>Die gematik geht neue Wege und m\u00f6chte auf diesem Weg die Nutzung der Schnittstellen rund um das VSDM 2.0 vorstellen. Die Beschreibung dieser API erg\u00e4nzt die normativen Dokumente der gematik sowie die Festlegungen \u00fcber die VSDM-Profile (inkl. Beispielen) des genutzten FHIR-Standards.</p> <p>Auf den folgenden Seiten stellt die gematik die Nutzung der Schnittstellen durch die Prim\u00e4rsysteme der Leistungserbringer vor.</p>"},{"location":"spec-vsdm2/#was-ist-vsdm-20","title":"Was ist VSDM 2.0","text":"<p>VSDM steht f\u00fcr \u201eVersichertenstammdatenmanagement\u201c. Es ist ein Teil der Telematikinfrastruktur (TI) im deutschen Gesundheitswesen und dient der Verwaltung und dem Abgleich der Stammdaten von gesetzlich versicherten Personen. VSDM 2.0 ist die Weiterentwicklung des bestehenden VSDM 1.0. Die Versichertenstammdaten (VSD) werden mit VSDM 2.0 nicht mehr auf der eGK des Versicherten gespeichert und aktualisiert sondern direkt vom Prim\u00e4rsystem (PS) des Leistungserbringers (LE) vom Fachdienst der Krankenkasse abgerufen und ggf. im PS aktualisiert. W\u00e4hrend bei VSDM 1.0 in den Anwendungsf\u00e4llen die Komponenten Konnektor, eHealth Kartenterminals, eGK, SMC-B, Intermedi\u00e4r und schlie\u00dflich die VSDM-Backend-Dienste des Versicherers zum Einsatz kommen, reduziert VSDM 2.0 die Abh\u00e4ngigkeiten von diesen Komponenten.  Mit der Initiative TI 2.0 wird die gesamte Infrastruktur modernisiert und auf den neuesten Stand der Sicherheits- und Architekturprinzipien gebracht.</p> <p>In der TI 2.0 wird der Nachweis des Versorgungskontextes mittels PoPP (\u201eProof-of-Patient-Presence\u201c) von fachlichen Anwendungsf\u00e4llen entkoppelt. Bei VSDM 2.0  ist dies die Bereitstellung demografischer Daten. Die Versicherer stellen also eine einfache FHIR-REST-API bereit, mit der die Client-Software der Arztpraxis \u201enur\u201c zus\u00e4tzliche Daten anfordert, indem sie ein legitimes PoPP-Token bereitstellt.</p> <p>Im nachfolgend verlinkten Kapitel finden Sie eine \u00dcbersicht, in welchem Kontext VSDM, PoPP und Zero Trust zueinander stehen:</p> <p>Kontext VSDM/PoPP/ZeroTrust</p> <p>Funktionen des VSDM: - Stammdatenabgleich: \u00dcber das VSDM 2.0 werden die Versichertenstammdaten, wie Name, Geburtsdatum, Anschrift, und Versicherungsschutz, bei jedem Arztbesuch online abgerufen und ggf.  aktualisiert. - Sicherstellung der Aktualit\u00e4t: Es soll sichergestellt werden, dass die im Prim\u00e4rsystem gespeicherten Daten stets aktuell sind. - Datensicherheit: Die Daten werden verschl\u00fcsselt und sicher \u00fcber die Telematikinfrastruktur \u00fcbertragen.</p>"},{"location":"spec-vsdm2/#anwendungsszenarien","title":"Anwendungsszenarien","text":"<p>In diesem Kapitel finden Sie eine Beschreibung der Anwendungsszenarien VSDM 2.0 f\u00fcr die relevanten Sektoren des Gesundheitswesens.</p> <p>Anwendungsszenarien</p>"},{"location":"spec-vsdm2/#anwendungsfalle-in-vsdm-20","title":"Anwendungsf\u00e4lle in VSDM 2.0","text":"<p>Im nachfolgend verlinkten Kapitel finden Sie die \u00dcbersicht der Anwendungsf\u00e4lle im Kontext VSDM 2.0.</p> <p>Anwendungsf\u00e4lle</p>"},{"location":"spec-vsdm2/#ablaufe-im-primarsystem","title":"Abl\u00e4ufe im Prim\u00e4rsystem","text":"<p>Im Rahmen der Anwendungsf\u00e4lle finden im Prim\u00e4rsystem weitere Abl\u00e4ufe im Zusammenhang mit der Versorgung des Versicherten statt. Hier finden Sie Informationen zu den Abl\u00e4ufen im Prim\u00e4rsystem und Interaktionen des Prim\u00e4rsystems mit dem Nutzer.</p> <p>Abl\u00e4ufe</p> <p>Prim\u00e4rsystem-Interaktionen</p>"},{"location":"spec-vsdm2/#informationsmodell-vsd","title":"Informationsmodell VSD","text":"<p>Hier geht es zur Informationsseite zum neuen Informationsmodell f\u00fcr VSDM 2.0.</p> <p>Anmerkung: Die Festlegung der finalen Inhalte des Informationsmodells erfolgt im Rahmen der Fortschreibung dieser Spezifikation. Die in diesem Dokument dargestellten Informationen stellen somit lediglich den bis zum Zeitpunkt der Ver\u00f6ffentlichung abgestimmten Stand dar.</p> <p>Informationsmodell</p>"},{"location":"spec-vsdm2/#prufziffer","title":"Pr\u00fcfziffer","text":"<p>Bei jedem erfolgreich durchgef\u00fchrten Abruf der VSD wird von Fachdienst VSDM 2.0 auch immer die Pr\u00fcfziffer \u00fcbermittelt. Diese wird im Prim\u00e4rsystem gespeichert und kann den Abrechnungsunterlagen beigef\u00fcgt werden.</p> <p>Hier finden Sie weitere Informationen zur Pr\u00fcfziffer f\u00fcr VSDM 2.0.</p> <p>Pr\u00fcfziffer </p>"},{"location":"spec-vsdm2/#fehlerbehandlung","title":"Fehlerbehandlung","text":"<p>Hier geht es zur Informationsseite zum Umgang mit Fehlermeldungen</p> <p>Fehlermeldungen</p> <p>Hier geht es zur Informationsseite zu Statuscodes </p> <p>Statuscodes</p>"},{"location":"spec-vsdm2/#fhir-profile-vsdm-20","title":"FHIR Profile VSDM 2.0","text":"<p>In VSDM 1.0 wurde ein propriet\u00e4res XML-Datenformat in einer SOAP-Servicekette verwendet. Mit VSDM 2.0 wird der VSD Datensatz in den FHIR-Standard migriert, der im deutschen Gesundheitswesen immer mehr zum Einsatz kommt. Die FHIR-Profile und Beispielressourcen werden im offiziellen VSDM 2 simplifier project ver\u00f6ffentlicht.</p>"},{"location":"spec-vsdm2/#mitgeltende-dokumente-und-informationen","title":"Mitgeltende Dokumente und Informationen","text":"<p>Hier finden Sie eine \u00dcbersicht zu den weiterf\u00fchrenden Dokumenten zur Implementierung.</p> <ul> <li>Spezifikation VSDM 2.0</li> <li>FHIR-Profile VSDM 2.0</li> <li>Steckbrief Clientsystem-Schnittstelle zum VSDM 2.0</li> </ul>"},{"location":"spec-vsdm2/#branch-modell","title":"Branch Modell","text":"<p>In diesem Repository werden Branches verwendet um den Status der Weiterentwicklung und das Review von \u00c4nderungen abzubilden. Folgende Branches werden verwendet</p> <ul> <li> <p>main (enth\u00e4lt den letzten freigegebenen Stand der Entwicklung; besteht permanent)</p> </li> <li> <p>develop (enth\u00e4lt den Stand der fertig entwickelten Features und wird zum Review durch Industriepartner und Gesellschafter verwendet; basiert auf main; nach Freigabe erfolgt ein merge in main und ein Release wird erzeugt; besteht permanent)</p> </li> <li> <p>feature/ilf (in feature branches werden neue Features entwickelt (ggf. basierend auf develop); nach Fertigstellung erfolgt ein merge in develop; der feature branch wird nach dem merge gel\u00f6scht)</p> </li> </ul>"},{"location":"spec-vsdm2/#lizenzbedingungen","title":"Lizenzbedingungen","text":"<p>Copyright (c) 2022 gematik GmbH</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"spec-vsdm2/#api-dokumentation-vsdm-20","title":"API Dokumentation VSDM 2.0","text":"<p>Wie oben erw\u00e4hnt, wird das VSDM 2.0 auf die Verwendung einer RESTful FHIR-API reduziert, die hier dokumentiert ist:</p> <p>vsdm2.yaml.</p>"},{"location":"spec-vsdm2/#kontakt","title":"Kontakt","text":"<p>Gehen Sie zu https://www.gematik.de oder OSPO@gematik.de</p>"},{"location":"spec-vsdm2/docs/temp/","title":"Temp","text":""},{"location":"spec-vsdm2/docs/temp/#specification-vsdm-2-fhir-profiles-and-api","title":"Specification VSDM 2 FHIR-Profiles and API","text":"<p>This repo holds FHIR-Profiles, sample Resources and OpenAPI specification for the VSDM 2 interface.</p> <ul> <li>Specification VSDM 2 FHIR-Profiles and API</li> <li>What is VSDM 2</li> <li>FHIR Profiles VSDM 2</li> <li>API Documentation VSDM 2</li> <li>License</li> <li>Contact</li> </ul>"},{"location":"spec-vsdm2/docs/temp/#what-is-vsdm-2","title":"What is VSDM 2","text":"<p>The Versichertenstammdatenmanagement VSDM was introduced around 2017 and both provides patient democraphic data to healthcare professionals and proof of treatement to be used in quarterly statements to the KV. All these use cases make use of Konnektor, eHealth Card Terminals, eGK, SMC-B, Intermedi\u00e4r and finaly the insurant provider's VSDM backend services.</p> <ul> <li>VSDM 2 firstly decouples the proof-of-treatment (\"Proof-of-Patient-Presence PoPP) from the use case of providing demographic data. So the PoPP can be used in other applications, too.</li> <li>Secondly, all the named infrastructure-components formed an unfexible and time consuming use case environment. So VSDM 2 reduces dependencies to those components.</li> <li>Finally, with the TI 2.0 initiative, the whole infrastructure will get modernized and updated to state of the art security and architecture principles.</li> </ul> <p>VSDM 2 basically will become a simple application, where a healthcare professional can (and in most cases should) get demographic and additional billing information AFTER a PoPP was determined. So the insurant providers provide a simple FHIR-REST-API where doctor's office client software \"just\" requests additional data by providing a legitimate PoPP-token.</p> <p></p>"},{"location":"spec-vsdm2/docs/temp/#fhir-profiles-vsdm-2","title":"FHIR Profiles VSDM 2","text":"<p>The first VSDM used a proprietary XML data format in a SOAP-service-chain. VSDM 2 migrates to the FHIR-standard that is used more and more in the German healthcare sector. The FHIR-profiles and sample resources will be published in the official VSDM 2 simplifier project.</p>"},{"location":"spec-vsdm2/docs/temp/#api-documentation-vsdm-2","title":"API Documentation VSDM 2","text":"<p>As stated above, the VSDM 2 will be reduced to the use of a small RESTful FHIR-API, that is documented here vsdm2.yaml.</p>"},{"location":"spec-vsdm2/docs/temp/#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"spec-vsdm2/docs/temp/#contact","title":"Contact","text":"<p>Please refer to https://www.gematik.de or OSPO@gematik.de</p>"},{"location":"spec-vsdm2/docs/vsdm_ablauf_ps/","title":"Abl\u00e4ufe im PS","text":"<p>Aufnahme des Versicherten</p> <p>Im Prim\u00e4rsystem dient bei der Anmeldung die eGK und zuk\u00fcnftig die GesundheitsID des Versicherten zur Aufnahme bzw. Identifikation des Versicherten. </p> <p>Dies beinhaltet   - die Herstellung des Versorgungskontextes   - den Abruf der VSD beim Fachdienst VSDM 2.0   - den Abruf der Pr\u00fcfziffer f\u00fcr die Abrechnung   - bei unbekannten Versicherten das Anlegen des Patientenstammblatts   - bei bekannten Versicherten ggf. das Aktualisieren des Patientenstammblatts</p> <p>Beim ersten Kontakt des Versicherten im laufenden Quartal muss das PS den Abruf der VSD beim Fachdienst VSDM durchf\u00fchren. Bei Folgebesuchen des Versicherten im laufenden Quartal kann immer ein erneuter Abruf der VSD erfolgen, um \u00c4nderungen in den VSD in das PS \u00fcbernehmen zu k\u00f6nnen. Dies kann insbesondere wichtig sein in Bezug auf Anpassungen zum Versicherungsschutz oder zur Kostenabdeckung. </p> <p>Patientenstammblatt anlegen</p> <p>Ist ein Versicherten beim Besuch der LEI bis dahin unbekannt, muss eine neues Patientenstammblatt angelegt werden. Dies kann unmittelbar an den Abruf der VSD gekoppelt sein, d.H. nach dem Erhalt der VSD erstellt das PS automatisch ein Patientenstammblatt und \u00fcberf\u00fchrt alle Informationen aus dem Abruf der VSD.  Der Nutzer soll einen Hinweis erhalten, dass der Versicherte noch nicht im PS existiert und eine neues Patientenstammblatt angelegt wird.</p> <p>Patientenstammblatt anzeigen</p> <p>Existiert bereits ein Patientenstammblatt, soll das PS den Abruf der VSD automatisch starten wenn das Patientenstammblatt im Rahmen eines Folgebesuchs ge\u00f6ffnet wird. Liegt im laufenden Quartal noch keine Pr\u00fcfziffer vor muss der Abruf der VSD erfolgen. Das PS soll dem Nutzer die M\u00f6glichkeit bieten, den Abruf der VSD manuell zu starten.</p> <p>Die Anzeige des zum Versicherten geh\u00f6rigen Patientenstammblatt kann auf unterschiedliche Arten erfolgen:</p> <ul> <li>Automatische Identifikation des Patientenstammblatts im PS anhand der KVNR durch Stecken der eGK oder Verwendung der GesundheitsID des Versicherten</li> <li>Manuelle Identifikation des Patientenstammblatts des Versicherten, z.B. anhand des Namens und Geburtsdatums </li> </ul> <p>Bei der automatischen Identifikation soll die Zuordnung von Versichertem und Patientenstammblatt im PS \u00fcber die KVNR erfolgen, da diese einen eindeutigen Bezug zum Versicherten herstellt.</p> <p>Auf welche Weise der Aufnahmeprozess durchgef\u00fchrt wird, wird in der Konfiguration des PS festgelegt oder ist ein Leistungsmerkmal des PS. Empfohlen wird die automatische Unterst\u00fctzung einer Neuanlage oder Aktualisierung des Patientenstammblatts.</p> <p>Konfigurationsparameter zum online Abruf VSD im PS |       |         |       | |:-------------:|:---------------:|:-------------:| | MODE_ONLINE_CHECK | ALWAYS (Immer) | Ein Abruf VSD wird ungeachtet eines vorangegangenen Abrufs immer angefordert | | MODE_ONLINE_CHECK | FIRST (Quartal) | Ein online Abruf VSD wird nur beim ersten Kontakt im Quartal angefordert. Die Pr\u00fcfung wird wiederholt, wenn der vorangegangene Abruf wegen technischer Probleme abgebrochen wurde | | MODE_ONLINE_CHECK | USER (Benutzerinteraktion) | Der Nutzer entscheidet individuell \u00fcber die Durchf\u00fchrung eines Abrufs VSD. Falls das PS die Notwendigkeit einer Online-Pr\u00fcfung festgestellt hat, sollte dies in Form einer Best\u00e4tigung erfolgen. |</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsfaelle/","title":"VSD vom Fachdienst abrufen","text":"<p>Der Anwendungsfall erm\u00f6glicht dem Leistungserbringer, - das g\u00fcltige Versicherungsverh\u00e4ltnis beim erstmaligen Quartalsbesuch zu pr\u00fcfen, - die jeweils zum Besuch aktuellen VSD und - die Pr\u00fcfziffer f\u00fcr die Abrechnung zu erhalten</p> <p>Vorraussetzungen f\u00fcr die Durchf\u00fchrung des VSDM-Anwendungsfalls ist die Herstellung des Versorgungskontextes. Versorgungskontext bedeutet, dass ein Zusammenhang zwischen einem berechtigten Versicherten und einer behandelnden oder versorgenden Leistungserbringerinstitution (LEI) hergestellt wird.</p> <p>Der Versorgungskontext wird durch die folgenden Schritte realisiert: - Authentisierung der LEI am PoPP-Service mittels einer SM-B Identit\u00e4t (Karte oder HSM) - Authentisierung des Versicherten mittels eGK oder GesundheitsID</p> <p>Nach der erfolgreichen Authentisierung der LEI und des Versicherten wird das Vorhandensein des Versorgungskontextes in Form eines PoPP-Tokens, welcher an das PS \u00fcbergeben wird, attestiert. Anschlie\u00dfend kann das Prim\u00e4rsystems den PoPP-Token als Autorisierung verwenden, um den Abruf der Versichertenstammdaten am Fachdienst VSDM 2.0 durchzuf\u00fchren. Die Herstellung des Versorgungskontextes ist nur beim ersten Besuch des Versicherten im laufenden Quartal notwendig. Bei Folgebesuchen kann der im PS bereits vorhandene PoPP-Token f\u00fcr jeden weiteren Abruf der VSD im laufenden Quartal verwendet werden.</p> <p>Die Authentisierung der LEI gegen\u00fcber dem PoPP-Dienst und gegen\u00fcber dem Fachdienst ist einmal am Tag erforderlich. Zuk\u00fcnftig kann der Versicherte auch die GesundheitsID in Verbindung mit einem Frontend des Versicherten (FdV) nutzen, um sich gegen\u00fcber dem PoPP-Dienst zu authentisieren.</p> <p>Die Anwendungsf\u00e4lle zur Authentisierung des Versicherten und der LEI sind im Dokument [gemSpec_PoPP_Service] beschrieben.</p> <p>\u00dcbersicht der Varianten beim Abruf VSD</p> <p>Die nachfolgend aufgef\u00fchrte Tabelle stellt die m\u00f6glichen Varianten des Anwendungsfalls Abruf VSD dar.</p> <p>Tabelle \u00dcbersicht Varianten Abruf VSD | Variante | Art des Besuchs | Versicherter | VSD | Bemerkung | | :-- | :---------- | :---------- | :---------- | ------------ | | 1 | 1. x im Quartal | unbekannter Versicherter | mit Aktualisierung | \u00dcbertragung VSD und Anlage Patientenstammblatt | | 2 | 1. x im Quartal | bekannter Versicherter | ohne Aktualisierung | keine \u00dcbertragung VSD | | 3 | 1. x im Quartal | bekannter Versicherter | mit Aktualisierung | \u00dcbertragung VSD und Aktualisierung Patientenstammblatt | | 4 | Folgebesuch | bekannter Versicherter | ohne Aktualisierung | keine \u00dcbertragung VSD | | 5 | Folgebesuch | bekannter Versicherter | mit Aktualisierung | \u00dcbertragung VSD und Aktualisierung Patientenstammblat |</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsfaelle/#varianten-des-abrufs-der-vsd","title":"Varianten des Abrufs der VSD","text":""},{"location":"spec-vsdm2/docs/vsdm_anwendungsfaelle/#variante-1","title":"Variante 1","text":"<p>Ein unbekannter Versicherter wird in der LEI als Patient aufgenommen</p> <p>Eingangsbedingung: - Abruf der VSD erfolgt erstmalig f\u00fcr einen unbekannten Versicherten - Versicherter authentisiert sich mit eGK oder GesundheitsID - LEI ist am PoPP-Service registriert und angemeldet - Dienstlokalisierung des FD VSDM 2.0 ist erfolgt</p> <p>Vorraussetzungen: - Versorgungskontext ist in Form einen vorliegenden PoPP-Tokens attestiert - PoPP-Token liegt im PS vor - KVNR und IK-Nummer sind im PS gespeichert (z.B. im Patientenstammblatt)</p> Nr Aktivit\u00e4t Komponente Beschreibung 1 VSD am FD anfragen PS Zur Anfrage an den zust\u00e4ndigen Fachdienst wird der g\u00fcltige Versorgungskontextnachweis in Form eines PoPP-Tokens, der Access-Token und der VSD-\u00c4nderungsindikator (ETag) \u00fcbertragen. ETag muss auf \"0\" gesetzt werden 2 Access-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen Access-Token und leitet den Request an den FD weiter. 3 PoPP-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen PoPP-Token und leitet den Request an den FD weiter. 4 KVNR \u00fcbermitteln ZT-Cluster Der HTTP-Proxy des ZT-Clusters \u00fcbermittelt dem FD VSDM die KVNR in Form des Elements patientId des HTTP-Headers ZETA-PoPP-Token-Content zur Lokalisierung der VSD-Version und der Versichertenstammdaten. 5 VSD-Version pr\u00fcfen FD Der FD f\u00fchrt beim Aufruf der HTTP-GET-Operation vor der Verarbeitung eines Versichertenstammdatensatzes\u00a0eine VSD-Aktualit\u00e4tspr\u00fcfung durch 6 VSD lokalisieren FD Der FD f\u00fchrt bei Unterschieden in der VSD Version zwischen PS und FD eine Lokalisierung der VSD anhand der KVNR durch und ruft diese ab 7 PZ und VSD \u00fcbermitteln FD Der FD \u00fcbermittelt die Pr\u00fcfziffer, den etag_value und die VSD an den HTTP-Proxy des ZT-Clusters 8 PZ und VSD an PS \u00fcbermitteln ZT-Cluster Der HTTP-Proxy des ZT-Clusters \u00fcbermittelt die Pr\u00fcfziffer, den etag_value und die VSD an das PS 9 PZ und VSD speichern PS Die \u00fcbermittelte PZ, der etag_value und die VSD werden gespeichert <p>Nachbedingung - PS: Die VSD wurden im Patientenstammblatt gespeichert - PS: Die Pr\u00fcfziffer ist im PS gespeichert - PS: der etag_value wurde aktualisiert</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsfaelle/#variante-2-und-3","title":"Variante 2 und 3","text":"<p>Ein der LEI bereits bekannter Versicherter wird zum ersten Mal im laufenden Quartal als Patient behandelt. In Variante 2 erfolgt keine Aktualisierung der VSD.</p> <p>Eingangsbedingung: - Abruf der VSD erfolgt erstmalig im Quartal f\u00fcr einen bekannten Versicherten - Versicherter authentisiert sich mit eGK oder GesundheitsID - LEI ist am PoPP-Service registriert und angemeldet - Dienstlokalisierung des FD VSDM 2.0 ist erfolgt</p> <p>Vorraussetzungen: - Versorgungskontext ist in Form einen vorliegenden PoPP-Tokens attestiert - PoPP-Token liegt im PS vor - KVNR und IK-Nummer sind im PS gespeichert (z.B. im Patientenstammblatt)</p> Nr Aktivit\u00e4t Komponente Beschreibung 1 VSD am FD anfragen PS Zur Anfrage an den zust\u00e4ndigen Fachdienst wird der g\u00fcltige Versorgungskontextnachweis in Form eines PoPP-Tokens, der Access-Token und der VSD-\u00c4nderungsindikator (ETag) \u00fcbertragen. 2 Access-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen Access-Token und leitet den Request an den FD weiter. 3 PoPP-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen PoPP-Token und leitet den Request an den FD weiter. 4 KVNR \u00fcbermitteln ZT-Cluster Der HTTP-Proxy des ZT-Clusters \u00fcbermittelt dem FD VSDM die KVNR in Form des Elements patientId des HTTP-Headers ZETA-PoPP-Token-Content zur Lokalisierung der VSD-Version und der Versichertenstammdaten. 5 VSD-Version pr\u00fcfen FD Der FD f\u00fchrt beim Aufruf der HTTP-GET-Operation vor der Verarbeitung eines Versichertenstammdatensatzes\u00a0eine VSD-Aktualit\u00e4tspr\u00fcfung auf Basis der KVNR durch 6.1 PZ \u00fcbermitteln FD Der FD \u00fcbermittelt bei \u00dcbereinstimmung des etag_values mit dem \u00c4nderungsindikator die Pr\u00fcfziffer und den etag_value an den HTTP-Proxy des ZT-Clusters 6.2 VSD lokalisieren FD Der FD \u00fcbermittelt bei Unterschieden zwischen etag_value und dem \u00c4nderungsindikator die auf Basis der KVNR lokalisierten VSD, die Pr\u00fcfziffer und den etag_value an den HTTP-Proxy des ZT-Clusters 7 PZ und ggf. VSD an PS \u00fcbermitteln ZT-Cluster Der HTTP-Proxy des ZT-Clusters \u00fcbermittelt die Pr\u00fcfziffer, den etag_value und bei Unterschieden in der VSD Version die VSD an das PS 8 PZ und ggf. VSD speichern PS Die \u00fcbermittelte PZ, der etag_value und bei Unterschieden in der VSD Version die VSD werden gespeichert <p>Schritt 6.1: Variante 2 ohne Aktualisierung VSD Schritt 6.2: Variante 3 mit Aktualisierung VSD</p> <p>Nachbedingung - PS: Variante 3 - Die VSD sind im Patientenstammblatt aktualisiert - PS: Die Pr\u00fcfziffer ist im PS gespeichert - PS: der etag_value wurde aktualisiert</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsfaelle/#variante-4-und-5","title":"Variante 4 und 5","text":"<p>Ein der LEI bereits bekannter Patient wird im Rahmen eines Folgebesuchs behandelt und ist bereits im laufenden Quartal aufgenommen/ behandelt worden. In Variante 4 erfolgt keine Aktualisierung der VSD.</p> <p>Eingangsbedingung: - Abruf der VSD erfolgt erneut im laufenden Quartal f\u00fcr einen bekannten Versicherten - Dienstlokalisierung des FD VSDM 2.0 ist erfolgt</p> <p>Vorraussetzungen: - PoPP-Token liegt im PS vor (aus erstem VSD-Abruf des laufenden Quartals) - KVNR und IK-Nummer sind im PS gespeichert (z.B. im Patientenstammblatt)</p> Nr Aktivit\u00e4t Komponente Beschreibung 1 VSD am FD anfragen PS Zur Anfrage an den zust\u00e4ndigen Fachdienst wird der g\u00fcltige Versorgungskontextnachweis in Form eines PoPP-Tokens, der Access-Token und der VSD-\u00c4nderungsindikator (ETag) \u00fcbertragen. 2 Access-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen Access-Token und leitet den Request an den FD weiter. 3 PoPP-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen PoPP-Token und leitet den Request an den FD weiter. 4 KVNR \u00fcbermitteln ZT-Cluster Der HTTP-Proxy des ZT-Clusters \u00fcbermittelt dem FD VSDM die KVNR in Form des Elements patientId des HTTP-Headers ZETA-PoPP-Token-Content zur Lokalisierung der VSD-Version und der Versichertenstammdaten. 5 VSD-Version pr\u00fcfen FD Der FD f\u00fchrt beim Aufruf der HTTP-GET-Operation vor der Verarbeitung eines Versichertenstammdatensatzes\u00a0eine VSD-Aktualit\u00e4tspr\u00fcfung auf Basis der KVNR durch 6.1 PZ \u00fcbermitteln FD Der FD \u00fcbermittelt bei \u00dcbereinstimmung des etag_values mit dem \u00c4nderungsindikator die Pr\u00fcfziffer und den etag_value an den HTTP-Proxy des ZT-Clusters 6.2 VSD lokalisieren FD Der FD \u00fcbermittelt bei Unterschieden zwischen etag_value und dem \u00c4nderungsindikator die auf Basis der KVNR lokalisierten VSD, die Pr\u00fcfziffer und den etag_value an den HTTP-Proxy des ZT-Clusters 7 PZ und ggf. VSD an PS \u00fcbermitteln ZT-Cluster Der HTTP-Proxy des ZT-Clusters \u00fcbermittelt die Pr\u00fcfziffer, den etag_value und bei Unterschieden in der VSD Version die VSD an das PS 8 PZ und ggf. VSD speichern PS Die \u00fcbermittelte PZ, der etag_value und bei Unterschieden in der VSD Version die VSD werden gespeichert <p>Schritt 6.1: Variante 4 ohne Aktualisierung VSD Schritt 6.2: Variante 5 mit Aktualisierung VSD</p> <p>Nachbedingung - PS: Variante 5 - Die VSD sind im Patientenstammblatt aktualisiert - PS: Die Pr\u00fcfziffer ist im PS gespeichert - PS: der etag_value wurde aktualisiert</p> <p>Anmerkung Der Patient muss weder seine eGK oder GesundheitsID verwenden noch muss ein neuer PoPP-Token vom PoPP-Service bezogen werden, da der im PS bereits vorliegende PoPP-Token f\u00fcr alle Folgebesuche im laufenden Quartal verwendet werden kann.</p> <p>Hinweise zum Entity Tag (ETag)</p> <p>Der ETag oder auch VSD-\u00c4nderungsindikator dienst dazu, die Version der VSD eindeutig zu identifizieren. Der ETag selbst ist eine Zeichenkette. Erh\u00e4lt das PS Versichertenstammdaten vom Fachdienst VSDM 2.0 wird durch diesen auch ein ETag \u00fcbertragen. Dieser wird im PS gespeichert und darf nicht ver\u00e4ndert werden. Wird ein erneuter Abruf der VSD gestartet, \u00fcbertr\u00e4gt das PS diesen ETag. Der Fachdienst vergleicht den Wert des ETags mit dem VSD-\u00c4nderungsindikator des Fachdienstes. Stimmen die Werte des ETags aus dem Request und des VSD-\u00c4nderungsindikators nicht \u00fcberein, werden als Ergebnis die VSD an das PS gesendet. Liegt dem PS bei einer Anfrage an den Fd noch kein VSD-\u00c4nderungsindikator vor, muss der ETag Wert durch das PS auf Null gesetzt werden.</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsfaelle/#vsd-von-egk-lesen","title":"VSD von eGK lesen","text":"<p>Dieser Anwendungsfall kommt dann zum tragen, wenn die VSD nicht online vom Fachdienst der Kasse abgerufen werden k\u00f6nnen. Die LEI muss dann in der Lage sein, die vorhandenen Daten von der eGk zu lesen, anzuzeigen und speichen zu k\u00f6nnen. Die erhaltenen Daten dienen dann zur Nutzung von bereits etablierten Ersatzverfahren ausserhalb des VSDM 2.0. Das PS muss in der Lage sein, die eGK mit den in der LEI vorhandenen Kartenleseger\u00e4ten auslesen zu k\u00f6nnen. Das k\u00f6nnen sowohl eHealth-Kartenterminals als auch handels\u00fcbliche USB Smartcard-Reader sein.  Die Daten werden aus dem ungesch\u00fctzten Bereich der eGK aus den Containern PD und VD gelesen. Zu beachten ist, dass sich auf der eGk einerseits der komplette VSD-Datensatz und andererseits auch ein verk\u00fcrzter Datensatz (siehe gemSpec_VSDM2, Kapitel \"7.2\u00a0Informationsmodell verk\u00fcrzte VSD auf eGK\") befinden kann. Keiner dieser Datens\u00e4tze kann jedoch den notwendigen Abruf der VSD im laufenden Quartal ersetzen, da es sich lediglich um statische Daten auf der eGK handelt. Eine Aktualisierung der VSD auf der eGK findet nicht statt.</p> <p>Auslesen der VSD mittels eHealth-Kartenterminal</p> <p>Die in der LEI bereits vorhandenen eHealth_Kartenterminals (eHKT), welche mit dem Konnektor gepairt sind, k\u00f6nnen weiterhin zum Auslesen der VSD von der eGK verwendet werden. Die Schnittstelle I_VSDService stellt daf\u00fcr die Operation ReadVSD zum Lesen der VSD zur Verf\u00fcgung. Im PS muss folgender Konfigurationsparameter verwendet werden:</p> Konfigurationsparameter zum Lesen der VSD MODE-ONLINE-CHECK / NEVER / Eine Online-Pr\u00fcfung wird niemals vom PS angefordert <p>Parametrisierung ReadVSD</p> ReadVSD Paramter ReadOnlineReceipt=false PerformOnlineCheck=false <p>Auslesen der VSD mittels handels\u00fcblichem USB Smartcard-Reader</p> <p>F\u00fcr das Aulesen der VSD kann alternativ zum eHKT auch ein handels\u00fcblicher Smartcard-Reader verwendet werden. Dieser ist an das PS angeschlossen und liefert die VSD aus den frei auslesbaren Containern der eGK zur \u00dcbernahme direkt in das PS. Die Beteiligung eines Konnektors und eHKT f\u00fcr das Auslesen der eGK findet in diesem Szeanrio nicht statt. Das PS muss f\u00fcr dieses Szenarion entsprechend erweitert werden.  F\u00fcr die Implementierung kann das nachfolgend verlinkte Beispielprogramm zum Auslesen der eGK bei Nutzung eines USB Smartcard_Readers genutzt werden:</p> <p>Beispielprogramm zum Auslesen der eGK</p> <p>Hinweis 1: Die Daten werden ausgelesen und decodiert in einer Log-Datei angezeigt (auch als XML). Hinweis 2: Das Programm pr\u00fcft NICHT die Echtheit der eGK.</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsszenarien/","title":"Anwendungsszeanarien aus Sicht der Sektoren","text":""},{"location":"spec-vsdm2/docs/vsdm_anwendungsszenarien/#niedergelassener-sektor","title":"Niedergelassener Sektor","text":"<p>Die Aufnahme eines Patienten in einer Arzt-/ Zahnarztpraxis oder in psychotherapeutischen Praxen folgt typischerweise einem standardisierten Prozess, der je nach Art der Praxis und organisatorischen Abl\u00e4ufen leicht variieren kann. Um eine Behandlung durchf\u00fchren und abrechnen zu k\u00f6nnen ist in jedem Fall die Herstellung des Versorgungskontextes sowie der sich daran anschlie\u00dfende Abruf der Versichertenstammdaten (VSD) notwendig. F\u00fcr jeden Versicherten wird ein Patientenstammblatt angelegt (der Begriff kann variieren und ist nicht mit der elektonischen Patientenakte zu verwechseln) die alle relevanten medizinischen und administrativen Daten enth\u00e4lt. Das Patientenstammblatt ist integrativer Teil des Prim\u00e4rsystems und dient sowohl der Dokumentation als auch der Nachverfolgbarkeit des Behandlungsverlaufs und ist f\u00fcr eine korrekte Diagnose, Therapie und Nachsorge unerl\u00e4sslich. F\u00fcr Versicherte die der Praxis noch nicht bekannt sind wird ein Patientenstammblatt im Zusammenhang mit dem Abruf der VSD angelegt. Existiert zum Versicherten bereits ein Patientenstammblatt wird diese im Laufe der Behandlung fortgeschrieben und aktualsiert. Der Abruf der VSD muss immer beim ersten Besuch des Versicherten im laufenden Quartal durchgef\u00fchrt werden. Auch bei Folgebesuchen im entsprechenden Quartal kann der Leistungserbringer (LE) einen Abruf der VSD durchf\u00fchren, um auch unterquartalige \u00c4nderungen in den VSD im PS zu dokumentieren. Das PS muss zudem auch die bei jedem Abruf mitgelieferte Pr\u00fcfziffer f\u00fcr Abrechnungsunterlagen speichern. </p> <p>Kann der Abruf der VSD zur Herstellung des Versorgungskontextes nicht erfolgen (z.B. aus technischen Gr\u00fcnden) muss die Aufnahme des Versicherten \u00fcber ein definiertes Ersatzverfahren erfolgen (Regelungen innerhalb des BMV-\u00c4).</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsszenarien/#stationarer-sektor","title":"Station\u00e4rer Sektor","text":"<p>Die Versorgung innerhalb eines Krankenhauses unterscheidet sich vom niedergelassenen Sektor in sofern, dass eine Aufnahme des Versicherten an verschiedenen Stellen erfolgen kann. </p> <p>Der Abruf der VSD im Rahmen der Aufnahme oder Erfassung erfolgt hier - in der ambulanten Versorgung durch einen f\u00fcr die ambulante Versorgung erm\u00e4chtigten Arzt - in der Notaufnahme der Rettungstelle f\u00fcr eine Akutversorgung (z.B. Einlieferung durch den Rettungswagen oder Selbsteinweisung des Versicherten) - in der Zentralaufnahme bei der station\u00e4re Versorgung (geplante Einweisung auf Grundlage eines Einweisungsscheins)</p>"},{"location":"spec-vsdm2/docs/vsdm_anwendungsszenarien/#apotheken","title":"Apotheken","text":"<p>Apotheken ben\u00f6tigen f\u00fcr die Versorgung eines Versicherten im Rahmen der Bereitstellung von Medikamenten keine Stammdaten. Der Abruf der VSD kann die Apotheken aber in ihren prozessualen Abl\u00e4ufen unterst\u00fctzen, z.B. durch das Anlegen und Bef\u00fcllen eines Kundenstamms.  </p>"},{"location":"spec-vsdm2/docs/vsdm_errorcodes/","title":"Fehlerbehandlung","text":"<p>Im Arbeitsablauf des Nutzers k\u00f6nnen Fehler beim Abruf der VSD vom Fachdienst VSDM 2.0 auftreten. Da vom Nutzer kein technisches Vorwissen erwartet werden darf sind Fehlermeldungen so anzugeben, dass dieser nach M\u00f6glichkeit darauf reagieren kann. Hierbei sollen Fehlermeldungen so aufbereitet werden, dass der Nutzer versteht welches System im Prozess den Fehler verursacht hat. Au\u00dferdem sollen bei technischen Fehlern diese sprachlich aufbereitet werden, so dass der Nutzer den Inhalt des Fehlers verstehen kann.</p> <p>Nutzer sollen an der Anwendungsoberfl\u00e4che des Prim\u00e4rsystems eine Handlungsanweisung erhalten die ihm erlauben, auf Warnungen und Fehlermeldungen in geeigneter Weise reagieren zu k\u00f6nnen.</p> <p>Die nachfolgenden Tabellen der Fehlercodes sollen als Auszug einen \u00dcberblick \u00fcber m\u00f6gliche Fehlersituationen vermitteln. Die Fehlertexte in den Tabellen enthalten Kurzbeschreibungen der Fehler und sind keine Vorgaben f\u00fcr Fehlermeldungen des Prim\u00e4rsystems. Hier soll der Hersteller darauf achten, f\u00fcr die Zielgruppe verst\u00e4ndliche Formulierungen zu verwenden.</p> <p>Fehlermeldungen am PS</p> Code Anzeige Handlungsempfehlung VSDSERVICE_INVALID_IK Ung\u00fcltige oder nicht bekannte\u00a0 Institutionskennung (ik). Nachweis zum Versorgungskontext mittels eGK oder GesundheitsID am PoPP-Service 1 x erneuern. Bei erneutem Fehler: Abbruch, da wahrscheinlich ein Implementierungsfehler vorliegt (Clientsystem oder PoPP-Service) oder die KTR gar nicht bei diesem FD-Anbieter ist (fehlerhafter DNS-Eintrag). VSDSERVICE_INVALID_KVNR Ung\u00fcltige oder nicht bekannte Krankenversichertennummer\u00a0(kvnr). Nachweis zum Versorgungskontext mittels eGK oder GesundheitsID am PoPP-Service 1 x erneuern. Bei erneutem Fehler: Abbruch, da wahrscheinlich ein Implementierungsfehler vorliegt (Clientsystem oder PoPP-Service) VSDSERVICE_PATIENT_RECORD_NOT_FOUND Die Versichertenstammdaten zur Versichertennummer (kvnr) konnten f\u00fcr die Institutionskennung  nicht ermittelt werden. Nachweis zum Versorgungskontext mittels eGK oder GesundheitsID am PoPP-Service 1 x erneuern. Bei erneutem Fehler: Abbruch, da wahrscheinlich ein Implementierungsfehler vorliegt (Clientsystem,\u00a0PoPP-Service oder Schnittstelle zu KTR-Bestandssystemen). VSDSERVICE_MISSING_OR_INVALID_HEADER Der erforderliche HTTP-Header (header) fehlt oder ist undg\u00fcltig. Im Falle des Headers PoPP: Nachweis zum Versorgungskontext mittels eGK oder GesundheitsID am PoPP-Service 1 x erneuern. Bei erneutem Fehler: Abbruch, da wahrscheinlich ein Implementierungsfehler vorliegt (Clientsystem). VSDSERVICE_UNSUPPORTED_MEDIATYPE Der vom Clientsystem angefragte Medientyp (media type) wird nicht unterst\u00fctzt. ./. (Implementierungsfehler) VSDSERVICE_UNSUPPORTED_ENCODING Das vom Clientsystem angefragte Komprimierungsverfahren\u00a0(encoding scheme) wird nicht unterst\u00fctzt. ./. (Implementierungsfehler) VSDSERVICE_INVALID_PATIENT_RECORD_VERSION Der \u00c4nderungsindikator  kann nicht verarbeitet werden. ./. (Implementierungsfehler) VSDSERVICE_INVALID_HTTP_OPERATION Die HTTP-Operation (http-operation) wird nicht unterst\u00fctzt. ./. (Implementierungsfehler) VSDSERVICE_INVALID_ENDPOINT Der angefragte Endpunkt (endpoint) wird nicht unterst\u00fctzt.\u00a0 ./. (Implementierungsfehler) <p>Fehlermeldungen des Fachdienstes VSDM</p> Code Anzeige Handlungsempfehlung VSD_SERVICE_INTERNAL_SERVER_ERROR Unerwarteter interner Fehler des Fachdienstes VSDM.\u00a0 Wiederholungsversuch in 15 Minuten Abst\u00e4nden. Abbruch nach 8 Versuchen. VSDSERVICE_VSDD_NOTREACHABLE Fachdienst VSDM ist f\u00fcr den Kostentr\u00e4ger (ik) nicht erreichbar. Wiederholungsversuch in 15 Minuten Abst\u00e4nden. Abbruch nach 8 Versuchen. VSDSERVICE_VSDD_TIMEOUT Fachdienst VSDM f\u00fcr den Kostentr\u00e4ger (ik)\u00a0hat das Zeitlimit f\u00fcr eine Antwort \u00fcberschritten.\u00a0 Wiederholungsversuch in 15 Minuten Abst\u00e4nden. Abbruch nach 8 Versuchen."},{"location":"spec-vsdm2/docs/vsdm_errorcodes/#beispiel","title":"Beispiel","text":"<p>Abbruch des Anwendungsfall \"Abruf VSD\" aufgrund ung\u00fcltiger KVNR</p> <p>Variante: Ein unbekannter Versicherter wird in der LEI als Patient aufgenommen</p> <p>Eingangsbedingung: - Abruf der VSD erfolgt erstmalig f\u00fcr einen unbekannten Versicherten - Versicherter authentisiert sich mit eGK oder GesundheitsID - LEI ist am PoPP-Service registriert und angemeldet - Dienstlokalisierung des FD VSDM 2.0 ist erfolgt</p> <p>Vorraussetzungen: - Versorgungskontext ist in Form einen vorliegenden PoPP-Tokens attestiert - PoPP-Token liegt im PS vor - KVNR und IK-Nummer sind im PS gespeichert (z.B. im Patientenstammblatt)</p> Nr Aktivit\u00e4t Komponente Beschreibung 1 VSD am FD anfragen PS Zur Anfrage an den zust\u00e4ndigen Fachdienst wird der g\u00fcltige Versorgungskontextnachweis in Form eines PoPP-Tokens, der Access-Token und der VSD-\u00c4nderungsindikator (ETag) \u00fcbertragen. ETag muss auf \"0\" gesetzt werden 2 Access-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen Access-Token und leitet den Request an den FD weiter. 3 PoPP-Token pr\u00fcfen ZT-Cluster Der HTTP-Proxy des ZT-Clusters pr\u00fcft auf g\u00fcltigen PoPP-Token und leitet den Request an den FD weiter. 4 KVNR \u00fcbermitteln ZT-Cluster Der HTTP-Proxy des ZT-Clusters \u00fcbermittelt dem FD VSDM die KVNR in Form des Elements patientId des HTTP-Headers ZETA-PoPP-Token-Content zur Lokalisierung der VSD-Version und der Versichertenstammdaten. 5 VSD-Version pr\u00fcfen FD Der FD f\u00fchrt beim Aufruf der HTTP-GET-Operation vor der Verarbeitung eines Versichertenstammdatensatzes\u00a0eine VSD-Aktualit\u00e4tspr\u00fcfung durch 6 Fehler zur\u00fcckgeben FD Der FD kann zu der KVNR keine VSD lokalisieren und gibt den Fehler VSDSERVICE_INVALID_KVNR zur\u00fcck 7 Fehler anzeigen PS Das PS zeigt die Fehlerbeschreibung an: Ung\u00fcltige oder nicht bekannte Krankenversichertennummer (kvnr) 8 Handlungsempfehlung anzeigen PS Das PS zeigt die Handlungsempfehlung f\u00fcr den Fehlercode an <p>Nachbedingung - PS: Die VSD wurden wurden nicht im Patientenstammblatt gespeichert - PS: Die Pr\u00fcfziffer ist nicht im PS gespeichert - PS: der etag_value wurde nicht aktualisiert</p>"},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/","title":"FHIR in VSDM 2.0","text":"<p>FHIR-Profile im VSDM 2.0 Kontext Folgende FHIR-Profile sind im VSDM 2.0 -Kontext relevant und werden von den verschiedenen Beteiligten definiert:</p> Beteiligter FHIR-Projekt KBV KBV DAV DAV GKV ... gematik ..."},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/#fhir-releases","title":"FHIR Releases","text":""},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/#testportal","title":"Testportal??","text":""},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/#referenzierung-von-fhir-objekten-un-bundles","title":"Referenzierung von FHIR-Objekten un Bundles","text":""},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/#tools-und-hinweise-zu-fhir","title":"Tools und Hinweise zu FHIR","text":""},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/#vsdm-fhir-beispiele","title":"VSDM FHIR-Beispiele","text":""},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/#konvertierung-von-fhir-xml-und-json","title":"Konvertierung von FHIR XML und JSON","text":""},{"location":"spec-vsdm2/docs/vsdm_fhir_infos/#rwferenzen-in-bundles-und-parameters-objekten","title":"Rwferenzen in Bundles und Parameters Objekten","text":""},{"location":"spec-vsdm2/docs/vsdm_informationsmodell/","title":"1 Hinweise zum Informationsmodell VSDM 2.0","text":"<p>Mit der Einf\u00fchrung von VSDM 2.0 wird FHIR (Fast Healthcare Interoperability Resources) zur Daten\u00fcbertragung verwendet.  Ziel der FHIR-Implementierung f\u00fcr VSDM 2.0 ist eine konsistente Datenhaltung und einen effizienten Austausch von Versichertenstammdaten zwischen dem Fachdienst VSDM 2.0 und den Prim\u00e4rsystemen zu gew\u00e4hrleisten. FHIR bietet hierf\u00fcr eine Grundlage, die sich flexibel an spezifische Anforderungen anpassen l\u00e4sst.</p>"},{"location":"spec-vsdm2/docs/vsdm_informationsmodell/#logical-model","title":"Logical Model","text":"<p>Das Logical Model beschreibt die Struktur der Versichertenstammdaten aus fachlicher Sicht. Es dient als Grundlage f\u00fcr die Ableitung von FHIR-Profilen und unterst\u00fctzt die Kommunikation zwischen Fachdom\u00e4ne und technischer Umsetzung. Jedes Element des Datensatzen wird wiefolgt beschrieben: - Name des Attributs - Kardinalit\u00e4t - Datentyp - Beschreibung - Definition</p> <p>Link Simplifier LogicalModelVSDM2.0</p> <p>Die nachfolgenden Logical Models \"Versichertendaten\" und \"Versicherungsdaten\" dienen zur Beschreibung der VSD und als Grundlage zur Definition der FHIR-Profile f\u00fcr VSDM 2.0.</p> <p>Weitere in den FHIR-Profilen Patient und Coverage befindliche Felder aus dem Basisdatensatz werden bei der Bef\u00fcllung und \u00dcbertragung des Datensatzes nicht beachtet. Das Logical Model bildet den kompletten VSD-Datensatz ab.</p>"},{"location":"spec-vsdm2/docs/vsdm_informationsmodell/#versichertendaten","title":"Versichertendaten","text":""},{"location":"spec-vsdm2/docs/vsdm_informationsmodell/#versicherungsdaten","title":"Versicherungsdaten","text":"<p>Anmerkung: Die konkrete Ausgestaltung des Datensatzes befindet sich noch in Absprache zwischen den Gesellschaftern. Die in Abstimmung befindlichen Felder sind im Logical Model auf Simplifier mit \"WIP\" (WorkInProgress) gekennzeichnet. Die Festlegungen hierzu werden in einem sp\u00e4teren Release nachgef\u00fchrt.</p>"},{"location":"spec-vsdm2/docs/vsdm_informationsmodell/#mapping","title":"Mapping","text":"<p>Das Mapping beschreibt die Zuordnung der Attribute des Logical Models f\u00fcr Versicherungsdaten zu den entsprechenden Feldern in einer FHIR-Ressource Coverage und Patient. </p> <p>Ziel ist es sicherzustellen, dass die Daten aus dem Logical Model korrekt in beide Zielsysteme transformiert werden k\u00f6nnen.</p> <p>Die Mappingtabellen zu Patient und Coverage befinden sich hier:</p> <p>Mapping logicalmodel-FHIR-Profile</p>"},{"location":"spec-vsdm2/docs/vsdm_informationsmodell/#2-hinweise-zum-verkurzten-vsd-datensatz-auf-der-egk","title":"2. Hinweise zum verk\u00fcrzten VSD-Datensatz auf der eGK","text":"<p>Gem\u00e4\u00df den gesetzlichen Vorgaben aus \u00a7291 SGB V muss die eGK, wenn sie nach dem 1. Januar 2026 herausgegeben wird, die Speicherung folgender Daten erm\u00f6glichen:</p> <ul> <li>die Bezeichnung der ausstellenden Krankenkasse, einschlie\u00dflich eines Kennzeichens f\u00fcr die Kassen\u00e4rztliche Vereinigung, in deren Bezirk der Versicherte seinen Wohnsitz hat</li> <li>der Familienname und der Vorname des Versicherten</li> <li>das Geburtsdatum des Versicherten</li> <li>die Krankenversichertennummer des Versicherten</li> </ul> <p>Die Restdaten befinden sich in folgenden Containern der eGK: - Allgemeine Versicherungsdaten - Pers\u00f6nliche Versichertendaten</p> <p>Der Container \"Gesch\u00fctzte Versichertendaten\" wird nicht mehr bef\u00fcllt.</p> <p>Die Bereitstellung der Daten erfolgt mittels eines angepassten VSD Schemas auf der Basis des in VSDM 1 verwendeten Schemas VSD 5.2.</p> <p>XML-Schema zum verk\u00fcrzten VSD-Datensatz</p>"},{"location":"spec-vsdm2/docs/vsdm_kontext_popp_zt/","title":"VSDM 2.0 im Kontext PoPP und ZeroTrust","text":"<p>\u00dcberblick Zusammenspiel der Anwendungen</p> <p></p> <p>VSDM 2.0 setzt voraus, dass der Versorgungskontext f\u00fcr einen zu behandelnden Versicherten in Form eines PoPP-Tokens vom Prim\u00e4rsystem via PoPP-Client und PoPP-Service bezogen wurde, um den Anwendungsfall zum Abruf der VSD durchf\u00fchren zu k\u00f6nnen.</p> <p>Proof of Patient Presence\u00a0(PoPP) ist ein Nachweis, der belegt, dass sich\u00a0ein Versicherter zu einem bestimmten Zeitpunkt in einem Versorgungskontext mit einer bestimmten Leistungserbringerinstitution (LEI) befindet. Im kryptografisch gesicherten PoPP-Token sind somit Informationen \u00fcber die LEI und \u00fcber den Versicherten zusammengef\u00fchrt. Dabei ist es die Aufgabe der PoPP-L\u00f6sung, die Authentifizierung der LEI durchzuf\u00fchren und durch Authentifizierung des Versicherten per GesundheitsID oder Authentifizierung der elektronischen Gesundheitskarte (eGK) eines Versicherten, an einem eHealth-Kartenterminal oder handels\u00fcblichen USB Smartcard-Reader,\u00a0den Versorgungskontext zu best\u00e4tigen. Das Ergebnis ist das PoPP-Token, welches der LEI zur Autorisierung f\u00fcr den Zugriff auf die Daten des Versicherten in Diensten der Telematikinfrastruktur (TI) dient.</p> <p>Der http Proxy des ZETA Guards stellt sicher, dass nur Requests mit g\u00fcltigem Access Token sowie bestandenen zus\u00e4tzlichen Pr\u00fcfungen an den Ressource Server weitergeleitet werden. Welche Pr\u00fcfungen zus\u00e4tzlich erfolgen, wird \u00fcber Attribute im Access Token gesteuert.</p>"},{"location":"spec-vsdm2/docs/vsdm_pruefziffer/","title":"Hinweise zur Pr\u00fcfziffer","text":"<p>Im Gegensatz zu VSDM 1.0 wird mit VSDM 2.0 vom Fachdienst kein Pr\u00fcfungsnachweis mehr sondern die Pr\u00fcfziffer an das Prim\u00e4rsystem \u00fcbergeben. </p> <p>Bei einer erfolgreichen Durchf\u00fchrung einer VSD-Anfrage wird    - bei erstmaligem Abruf im laufenden Quartal und   - bei jedem weiteren Abruf der VSD im laufenden Quartal</p> <p>die Pr\u00fcfziffer unabh\u00e4ngig davon, ob sich \u00c4nderungen in den VSD ergeben haben an das Prim\u00e4rsystem \u00fcbermittelt.</p> <p>Das Prim\u00e4rsystem muss die Pr\u00fcfziffer zur Erstellung der Abrechnungsunterlagen speichern. </p> <p>Dieser Leitfaden zur Implementierung trifft keine Aussage dar\u00fcber, ob jede im laufenden Quartal erhaltene Pr\u00fcfziffer gespeichert werden muss oder eine \u00dcberschreibung der vorhandenen Pr\u00fcfziffer erfolgen soll. </p> <p>Die Regelungen dazu werden im Anforderungskatalog KVDT (KBV_ITA_VGEX_Anforderungskatalog_KVDT) getroffen und m\u00fcssen durch das Prim\u00e4rsystem entsprechend umgesetzt werden.</p> <p>Beispiele f\u00fcr \u00dcbertragung der Pr\u00fcfziffer sind in [gemSpec_VSDM2] dargestellt und beschrieben.</p>"},{"location":"spec-vsdm2/docs/vsdm_psinteraktionen/","title":"Vsdm psinteraktionen","text":""},{"location":"spec-vsdm2/docs/vsdm_psinteraktionen/#interaktionen-des-primarsystems","title":"Interaktionen des Prim\u00e4rsystems","text":"<p>Diese Seite enth\u00e4lt Hinweise und Empfehlungen zur Interaktion des Prim\u00e4rsystems mit dem Nutzer im VSDM 2.0 - Kontext</p> <p>Durch die in den Arztpraxen, Krankenh\u00e4usern oder Apotheken eingesetzten Clientsysteme soll vor allem die Interoperabilit\u00e4t, Benutzerfreundlichkeit und Sicherheit sichergestellt werden. Das Prim\u00e4rsystem sollte einfach und intuitiv zu bedienen sein, so dass Nutzer (\u00c4rzte, Praxispersonal) in ihren t\u00e4glichen Arbeitsabl\u00e4ufen unterst\u00fctzt werden. Nachfolgend werden Interaktionen des PS mit dem Nutzer aufgef\u00fchrt, die helfen k\u00f6nnen den Prozess m\u00f6glichst nutzerfreundlich zu gestalten. Ein Anspruch auf Vollst\u00e4ndigkeit bei der Abdeckung der Aufnahmeprozesse besteht nicht und die hier beschriebenen Inhalte sind als Interpretationshilfe zu verstehen. Der L\u00f6sungsraum geht dar\u00fcber hinaus.</p>"},{"location":"spec-vsdm2/docs/vsdm_psinteraktionen/#ps-interaktionen-im-kontext-abruf-vsd","title":"PS-Interaktionen im Kontext Abruf VSD","text":"<p>Hinweis bei Start Abruf VSD</p> <p>Der Nutzer soll einen Hinweis durch das PS erhalten wenn der Abruf der VSD gestartet wird.</p> <p>Abruf VSD kann nicht durchgef\u00fchrt werden</p> <p>Der Nutzer soll einen Hinweis erhalten wenn der Abruf VSD aufgrund Nichterreichbarkeit des Fachdienstes nicht durchgef\u00fchrt werden konnte.</p> <p>Abruf VSD bei fehlender Pr\u00fcfziffer</p> <p>Das PS soll dem Nutzer einen Hinweis anzeigen wenn der Abruf der VSD aufgrund einer fehlenden Pr\u00fcfziffer erforderlich ist. Die kann der Fall sein, wenn ein vorangegangener Abruf VSD nicht erfolgreich durchgef\u00fchrt werden konnte.</p> <p>Abruf VSD erfolgreich durchgef\u00fchrt</p> <p>Das PS soll dem Nutzer die VSD anzeigen wenn der Abruf fehlerfrei durchgef\u00fchrt wurde.</p> <p>Anzeige Delta VSD</p> <p>Das PS soll dem Nutzer nach dem Abruf der VSD und vor der \u00dcbernahme / Speicherung ge\u00e4nderte VSD im Vergleich zu bereits vorhandenen VSD anzeigen, z.B. Vergleich Alt/Neu mit Hervorhebung der Ver\u00e4nderungen.</p> <p>Fehlerfall Abruf VSD Das PS soll dem Nutzer im Fehlerfall eine aussagekr\u00e4ftige Meldung mit der Fehlerursache angezeigen, damit das Ersatzverfahren eingeleitet werden kann.</p> <p>Hinweis Versicherungsschutz Der Nutzer erh\u00e4lt einen Hinweis wenn kein Leistungsanspruch aufgrund der Pr\u00fcfung des Zeitraums zwischen \"Beginn Versicherungsschutz\" und \"Ende\" vorliegt.</p> <p>Hinweis ruhender Leistungsanspruch</p> <p>Der Nutzer erh\u00e4lt einen Hinweis wenn aufgrund eines ruhenden Leistungsanspruchs kein, oder nur ein eingeschr\u00e4nkter Leistungsanspruch besteht.</p>"},{"location":"spec-vsdm2/docs/vsdm_statuscodes/","title":"VSDM 2.0 API-Dokumentation Fehlerbehandlung am VSDM 2.0 Fachdienst","text":"<p>Der Fachdienst VSDM 2.0 stellt eine http-Schnittstelle f\u00fcr den Aufruf durch das Clientsystem bereit. Das Ergebnis der Operation wird in der Verwendung von Http-Status-Codes gem\u00e4\u00df [RFC2616] mitgeteilt. Folgende http Status Codes k\u00f6nnen Clients bei der Benutzung der Schnittstellen des VSDM-Fachdienstes erwarten. Fehler k\u00f6nnen sowohl im inneren http-Requests (bei fachlichen Fehlern) als auch im \u00e4u\u00dferen http-Request auftreten.</p>"},{"location":"spec-vsdm2/docs/vsdm_statuscodes/#status-codes","title":"Status Codes","text":"http Operation M\u00f6gliche http Statuscodes Bedeutung/Fehlerdetails Resource-Server GET /vsdservice/v1/vsdmbundle 200 Anfrage konnte erfolgreich bearbeitet werden. Versichertenstammdaten (VSDMBundle) und Pr\u00fcfziffer sind in der Antwort enthalten. 304 Anfrage konnte erfolgreich bearbeitet werden. Das Clientsystem besitzt schon die aktuellsten Versichertenstammdaten und es erfolgt keine Aktualisierung. Der Pr\u00fcfziffer ist in der Antwort enthalten. 400 79010, 79011, 79030, 79031, 79032, 79205, 79206, 79207, 79400, 79401, 79402 403 79041 404 79020 405 79040 428 79033 500 79100 502 79110 504 79111"},{"location":"zeta/","title":"Macro Syntax Error","text":"<p>File: <code>zeta/index.md</code></p> <p>Line 7 in Markdown file: expected token 'end of statement block', got 'name' <pre><code>{% include badge.html name=\"release_notes\" %}\n</code></pre></p>"},{"location":"zeta/docs/branch-modell/","title":"Branch Modell","text":"<p>Im ZETA GitHub Repository werden Branches verwendet um den Status der Weiterentwicklung und das Review von \u00c4nderungen abzubilden.</p> <p>Folgende Branches werden verwendet:</p> <ul> <li>main (enth\u00e4lt den letzten freigegebenen Stand der Entwicklung; besteht permanent)</li> <li>develop (enth\u00e4lt den Stand der fertig entwickelten Features und wird zum Review durch Industriepartner und Gesellschafter verwendet; basiert auf main; nach Freigabe erfolgt ein merge in main und ein Release wird erzeugt; besteht permanent)</li> <li>feature/name (in feature branches werden neue Features entwickelt; basiert auf develop; nach Fertigstellung erfolgt ein merge in develop; wird nach dem merge gel\u00f6scht)</li> <li>hotfix/name (in hotfix branches werden Hotfixes entwickelt; basiert auf main; nach Fertigstellung erfolgt ein merge in develop und in main; wird nach dem merge gel\u00f6scht)</li> <li>concept/name (in concept branches werden neue Konzepte entwickelt; basiert auf develop; dient der Abstimmung mit Dritten; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> <li>misc/name (nur f\u00fcr internen Gebrauch der gematik; es erfolgt kein merge; wird nach Bedarf gel\u00f6scht)</li> </ul>"},{"location":"zeta/docs/api/zeta-api-versionen/","title":"ZETA API Versionen","text":"<ul> <li>ZETA API v1</li> </ul>"},{"location":"zeta/docs/api/v1/","title":"Macro Syntax Error","text":"<p>File: <code>zeta/docs/api/v1/index.md</code></p> <p>Line 7 in Markdown file: expected token 'end of statement block', got 'name' <pre><code>{% include badge.html name=\"zeta_api\" %}\n</code></pre></p>"},{"location":"zeta/docs/zeta-guard/","title":"Macro Syntax Error","text":"<p>File: <code>zeta/docs/zeta-guard/index.md</code></p> <p>Line 7 in Markdown file: expected token 'end of statement block', got 'name' <pre><code>{% include badge.html name=\"zeta_guard\" %}\n</code></pre></p>"}]}